<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>selenium的学习-（一）</title>
      <link href="/2023/09/14/selenium/"/>
      <url>/2023/09/14/selenium/</url>
      
        <content type="html"><![CDATA[<h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><blockquote><p>id<br>name<br>class_name<br>tag_name<br>link_text<br>partial_link_text<br>Xpath<br>css</p><p>123给予元素属性特有定位方式<br>45基于元素标签内容定位<br>6基于元素路径定位<br>7基于选择器</p></blockquote><hr><h3 id="link-text"><a href="#link-text" class="headerlink" title="link_text"></a>link_text</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.只能定位a标签</span><br><span class="line">2.定位的元素内容必须为全部匹配</span><br></pre></td></tr></table></figure><h3 id="partial-link-text"><a href="#partial-link-text" class="headerlink" title="partial_link_text"></a>partial_link_text</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定位a标签</span><br><span class="line">partial_link_text定位元素的内容可以模糊部分值，但是必须能代表唯一性。假如不具有唯一性，它默认操作符合条件的第一个元素，不报错。</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id,name,class:依赖于元素对应的三个属性，如果元素没有这三个属性，就无法定位。</span><br><span class="line">link_text/partial_link_text只能适合超链接（即a标签）</span><br><span class="line">tag_name:只能找页面唯一元素，或者页面中多个相同元素中的第一个元素（非常不友好,一般页面基本会有很多相同的元素）</span><br></pre></td></tr></table></figure><hr><h3 id="xpath（重点）"><a href="#xpath（重点）" class="headerlink" title="xpath（重点）"></a>xpath（重点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpath依赖于元素的路径定位，是一门在xml文档中查找元素信息的语言。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xpath定位策略</span><br><span class="line">1.路径</span><br><span class="line">2.路径结合属性</span><br><span class="line">//*[@id=&#x27;id值&#x27;]</span><br><span class="line">3.路径结合逻辑（多个属性）</span><br><span class="line">//*[@id=&#x27;id值&#x27; and @属性=&#x27;属性值&#x27;]</span><br><span class="line">4.路径结合层级</span><br><span class="line">//*[@id=&#x27;父级id属性值&#x27;]/input</span><br><span class="line"></span><br><span class="line">提示：一般使用指定标签名称，不使用*代替，效率慢。</span><br><span class="line">无论是绝对还是相对路径，/后面必须为元素的名称或者*</span><br><span class="line">扩展：能使用相对路径绝对不使用绝对路径。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相对路径是//开头，后面也是用/，//后边跟元素名称，不知道元素名称可以用*代替。如：//input 、 //*</span><br><span class="line">绝对路径以/开头,不能跳级，根是html不是document。</span><br><span class="line"></span><br><span class="line">要写元素的属性要以@开头，如：//input[@name=&#x27;aaa&#x27;]</span><br><span class="line">结合多属性用and，如：//input[@name=&#x27;aaa&#x27; and @class=&#x27;login-text&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="xpath扩展"><a href="#xpath扩展" class="headerlink" title="xpath扩展"></a>xpath扩展</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.文本元素定位：//*[text()=&#x27;文本内容&#x27;]</span><br><span class="line">text()=&#x27;文本内容&#x27;</span><br><span class="line">一般适合p、a标签</span><br><span class="line">2.属性值模糊定位：//*[contains(@type,&#x27;password&#x27;)]</span><br><span class="line">语法：//*[contains(@attribute,&#x27;属性值&#x27;)]，属性值可以写部分</span><br><span class="line">contains是关键字，不可更改。</span><br><span class="line">3.属性值开头值定位：//*[starts-with(@type,&#x27;pass&#x27;)]</span><br><span class="line">语法：//*[starts-with(@attriture,&#x27;属性值&#x27;)]，属性值可以写值的开头部分值</span><br><span class="line">starts-with是关键字，不可更改。</span><br></pre></td></tr></table></figure><hr><h3 id="css定位（重点）"><a href="#css定位（重点）" class="headerlink" title="css定位（重点）"></a>css定位（重点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在selenium中推荐使用css定位，因为比xpath定位速度快</span><br><span class="line">主要用css选择器定位</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.id选择器</span><br><span class="line">2.class选择器</span><br><span class="line">3.元素选择器</span><br><span class="line">4.属性选择器</span><br><span class="line">5.层级选择器</span><br></pre></td></tr></table></figure><ol><li>id选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：#id</span><br></pre></td></tr></table></figure><ol start="2"><li>class选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：.class_name</span><br></pre></td></tr></table></figure><ol start="3"><li>元素选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：元素名</span><br></pre></td></tr></table></figure><ol start="4"><li>属性选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：[属性=&quot;属性值&quot;]</span><br><span class="line">任何属性都可以</span><br></pre></td></tr></table></figure><ol start="5"><li>层级选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：父级&gt;子级，或者用空格间隔。</span><br><span class="line">提示：&gt;必须为直属子元素，空格不用。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="css扩展"><a href="#css扩展" class="headerlink" title="css扩展"></a>css扩展</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input[type^=&#x27;p&#x27;]   type属性以p字母开头的元素</span><br><span class="line">input[type$=&#x27;d&#x27;]   type属性以d字母结束的元素</span><br><span class="line">input[type*=&#x27;w&#x27;]   type属性包含w字母的元素</span><br></pre></td></tr></table></figure><hr><h1 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h1><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.输入方法</span><br><span class="line">send_keys()</span><br><span class="line">2.点击方法</span><br><span class="line">click()</span><br><span class="line">3.清空方法</span><br><span class="line">clear()</span><br><span class="line"></span><br><span class="line">注意：输入内容之前要清空输入框，不然会在已有内容之后追加</span><br></pre></td></tr></table></figure><h3 id="操作浏览器常用方法"><a href="#操作浏览器常用方法" class="headerlink" title="操作浏览器常用方法"></a>操作浏览器常用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.最大化浏览器窗口</span><br><span class="line">maximize_window()</span><br><span class="line">2.设置浏览器窗口大小</span><br><span class="line">set_window_size(width,height)</span><br><span class="line">3.设置浏览器窗口位置</span><br><span class="line">set_window_position(x,y)</span><br><span class="line">4.后退</span><br><span class="line">back（）</span><br><span class="line">5.前进</span><br><span class="line">forward（）</span><br><span class="line">6.刷新</span><br><span class="line">refresh()</span><br><span class="line">7.关闭当前窗口（只关闭当前主窗口，默认启动哪个界面，哪个就是主窗口）</span><br><span class="line">close()</span><br><span class="line">8.关闭浏览器驱动对象(关闭由驱动对象打开的全部窗口)</span><br><span class="line">quit()</span><br><span class="line">9.获取页面title</span><br><span class="line">title</span><br><span class="line">10.获取当前页面URL</span><br><span class="line">current_url</span><br></pre></td></tr></table></figure><h3 id="获取元素信息常用方法"><a href="#获取元素信息常用方法" class="headerlink" title="获取元素信息常用方法"></a>获取元素信息常用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.返回元素大小</span><br><span class="line">size</span><br><span class="line">2.获取元素文本</span><br><span class="line">text</span><br><span class="line">3.获取属性值，传递的参数为元素的属性名</span><br><span class="line">get_attribute(&#x27;xxx&#x27;)</span><br><span class="line">4.判断元素是否可见</span><br><span class="line">is_displayed()</span><br><span class="line">5.判断元素是否可用</span><br><span class="line">is_enabled()</span><br><span class="line">6.判断元素是否选中，用来检查复选框或单选按钮是否被选中</span><br><span class="line">is_selected()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在selenium中将操作鼠标的方法封装在ActionChains类中</span><br><span class="line">实例化对象：</span><br><span class="line">action = ActionChains(driver)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">1.鼠标右击</span><br><span class="line">context_click(element)</span><br><span class="line">2.双击</span><br><span class="line">double_click(element)</span><br><span class="line">3.拖动</span><br><span class="line">drag_and_drop(source,target)</span><br><span class="line">4.悬停</span><br><span class="line">move_to_element(element)</span><br><span class="line">5.执行以上鼠标操作</span><br><span class="line">perform()</span><br><span class="line"></span><br><span class="line">注意：selenium虽然提供了右击鼠标方法，但是没有提供选中右击菜单方法，右击出来的浏览器菜单是点不了的。。。。。。</span><br></pre></td></tr></table></figure><h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.删除键（backspace）</span><br><span class="line">send_keys(Keys.BACK_SPACE)</span><br><span class="line">2.空格键（space）</span><br><span class="line">send_keys(Keys.SPACE)</span><br><span class="line">3.制表键（tab）</span><br><span class="line">send_keys(Keys.TAB)</span><br><span class="line">4.回退键（esc）</span><br><span class="line">send_keys(Keys.ESC)</span><br><span class="line">5.回车键（enter）</span><br><span class="line">send_keys(Keys.ENTER)</span><br><span class="line">6.全选（Ctrl+A）</span><br><span class="line">send_keys(Keys.CONTROL,&#x27;a&#x27;)</span><br><span class="line">7.复制（Ctrl+C）</span><br><span class="line">send_keys(Keys.CONTROL,&#x27;c&#x27;)</span><br></pre></td></tr></table></figure><h3 id="元素等待"><a href="#元素等待" class="headerlink" title="元素等待"></a>元素等待</h3><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法：driver.implicitly_wait(timeout)</span><br><span class="line">说明：隐式等待为全局设置（只需要设置一次，就会作用于所有元素）</span><br></pre></td></tr></table></figure><h4 id="显示等待-重点"><a href="#显示等待-重点" class="headerlink" title="显示等待(重点)"></a>显示等待(重点)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法：WebDriverWait(driver,timeout,poll_frequency=0.5)</span><br><span class="line">1.driver:浏览器驱动对象</span><br><span class="line">2.timeout：超时的时长，单位为秒</span><br><span class="line">3.poll_frequency:检测间隔时间，默认为0.5秒</span><br><span class="line">调用方法：until（method）：直到...时</span><br><span class="line">method：函数名称，该函数用来实现对元素的定位</span><br><span class="line">一般使用匿名函数来实现：lambda x:x.find_element_by_id(&#x27;userA&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待，如果不能定位到该元素，则间隔一段时间后再去定位元素，如果在达到最大时长时还没有找到指定元素，则抛出超时异常TimeoutException.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">操作：</span><br><span class="line">1.实例化WebDriverWait（）类并调用until（method）方法</span><br><span class="line">method：写匿名函数，如lambada x:x.find_element_by_id()</span><br><span class="line">x为driver，它是webDriverWait类将传入的driver赋值给了类self._driver,until方法调用了self.driver;</span><br><span class="line">timeout为超时时间</span><br><span class="line">poll_frequency为访问频率，默认0.5s找一次元素</span><br></pre></td></tr></table></figure><h2 id="切换frame-iframe"><a href="#切换frame-iframe" class="headerlink" title="切换frame&#x2F;iframe"></a>切换frame&#x2F;iframe</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原因：不切换frame会导致元素找不到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切换方法：driver.switch_to.frame()</span><br><span class="line">切回默认主页面：driver.switch_to.default_content()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多窗口切换"><a href="#多窗口切换" class="headerlink" title="多窗口切换"></a>多窗口切换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明：在HTML页面中，当点击超链接或者按钮时，有的会在新的窗口打开页面。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">1) driver.current_window_handle ---获取当前窗口句柄</span><br><span class="line">2) driver.window_handles ---获取所有窗口句柄</span><br><span class="line">3) driver.switch_to.window(handle) ---切换指定句柄窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">应用场景：失败时截图，让错误看的更直观</span><br><span class="line">方法：driver.get_screenshot_as_file（imgagepath）</span><br><span class="line">imagepath：为图片保存地址</span><br></pre></td></tr></table></figure><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录cookie进行跳过验证码登录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cookie是由web服务器生成的，并且保存在用户浏览器上的小文本文件，它可以包含用户相关的信息。</span><br><span class="line">cookie数据格式：键值对组成</span><br><span class="line">cookie的生成：客户端请求服务器，如果服务器需要记录该用户状态，就向客户端颁发一个cookie，客户端浏览器会自动记录下cookie，在下一次请求中会将cookie信息自动附加在请求中。</span><br><span class="line">cookie使用：当浏览器再次请求该网站时，浏览器把请求的数据和cookie数据一同提交给服务器，服务器检查该cookie，以此来辨认用户状态。</span><br></pre></td></tr></table></figure><h2 id="Selenium操作cookie"><a href="#Selenium操作cookie" class="headerlink" title="Selenium操作cookie"></a>Selenium操作cookie</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">1、get_cookie(name)  --&gt;获取指定cookie，name为cookie名称</span><br><span class="line">2、get_cookies() --&gt;获取本网站所有本地cookies</span><br><span class="line">3、add_cookie(cookie_dict)  --&gt;添加cookie</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API测试</title>
      <link href="/2023/09/14/API%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/09/14/API%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="postman基础使用"><a href="#postman基础使用" class="headerlink" title="postman基础使用"></a>postman基础使用</h3><ul><li>postman建立collection管理用例</li><li>导出用例集</li><li>导入用例集</li></ul><h3 id="postman断言"><a href="#postman断言" class="headerlink" title="postman断言"></a>postman断言</h3><ul><li>Status code: Code is 200（是否返回码为200）</li><li>Response body : Contains string(是否包含某个指定的字符串)</li><li>Response body:JSON value check（）</li><li>Response body : is equal to a string（）</li></ul><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><ul><li>全局变量：pm.globals.set(“var_name”,value);</li><li>环境变量：pm.environment.set(“en_name”,value);</li></ul><h4 id="获取变量值"><a href="#获取变量值" class="headerlink" title="获取变量值"></a>获取变量值</h4><ul><li>全局变量<ol><li>请求参数中获取：</li><li>代码中获取：var value &#x3D; pm.globals.get(“var_name”)</li></ol></li><li>环境变量<ol><li>请求参数中获取：</li><li>代码中获取：var value &#x3D; pm.environment.get(“var_name”)</li></ol></li></ul><h3 id="postman关联"><a href="#postman关联" class="headerlink" title="postman关联"></a>postman关联</h3><blockquote><p>应用于多个http请求之间，有数据关联，或依赖关系时。</p></blockquote><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>A接口依赖于B接口的数据</p><ol><li>向B接口发送http请求，获取数据</li><li>将数据设置至全局变量中</li><li>A接口获取全局变量中数据值，进行使用。</li></ol><h3 id="newman插件生成测试报告"><a href="#newman插件生成测试报告" class="headerlink" title="newman插件生成测试报告"></a>newman插件生成测试报告</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newman run 测试脚本文件 -e 环境变量文件 -d 测试数据文件 -r html --reporter-html-export report.html</span><br></pre></td></tr></table></figure><h3 id="postman读取外部文件（参数化）"><a href="#postman读取外部文件（参数化）" class="headerlink" title="postman读取外部文件（参数化）"></a>postman读取外部文件（参数化）</h3><blockquote><p>当http请求，使用的数据有较高相似度时，相同的请求时，考虑使用参数化（将数据组织到数据文件中）</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>第一种：</li><li>第二种：代码里用：data.字段名</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>K8S的浅要认知</title>
      <link href="/2023/09/14/K8S/"/>
      <url>/2023/09/14/K8S/</url>
      
        <content type="html"><![CDATA[<ul><li>DaemonSet</li></ul><blockquote><p>适合监控、日志等任务</p></blockquote><ul><li>Deployment</li></ul><blockquote><p>管理Pod</p></blockquote><ul><li>StatefulSets</li><li>Jobs</li><li>CustomObjects</li><li>Serivce</li></ul><blockquote><p>负责将服务提供给同一个集群内的其他服务使用</p><p>serivce是一个完全虚拟的网络层，通过修改集群内部的路由规则，仅对集群内部有效。</p></blockquote><ul><li>ingress</li></ul><blockquote><p>对集群外提供服务</p></blockquote><ul><li>Pod</li></ul><blockquote><p>Pod处理多个容器之间的关系</p><p>同一个Pod内的容器可以共享很多信息，也可能需要读取同一份配置</p><p>相关的配置信息写在ConfigMap里，敏感信息写在Secret中</p></blockquote><ul><li>Helm</li></ul><blockquote><p>Helm 是 Kubernetes 的一个包管理工具，用来简化应用的部署和管理。可以把 Helm 比作 CentOS 的 yum 工具。</p></blockquote><p>容器技术（代表：docker）</p><p>容器技术主要利用linux中的两种机制：namespace与cgroups机制</p><p>隔离技术：利用namespace技术营造出一种各自为营的环境，可以使每个容器只看到自己里面的情况。</p><p>资源限制：利用cgroups限制一个进程组能够使用的资源上限。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最近的一些学习</title>
      <link href="/2023/09/14/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/14/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ol><li>T1测试：一般是对于基层版本的更新点的一个测试，一般存在于协助开发一个项目的情况，合并代码时会保留一部分基版本更新的一些功能点，这时就得对于这部分功能点进行测试，这些测试就是T1测试，基于这些功能编写的测试点也叫T1测试点。</li><li>T2测试：有T1测试情况才会有T2测试的一种叫法，其实就是对于自己直接负责的这个项目的需求进行测试的点。</li><li>PRD文档：也就是需求分析文档，有Ctest（协助开发平台）的情况下一般就是Ctest平台中产品上传的一些需求项。</li></ol><p>一般测试点&#x2F;测试用例的编写是基于需求项和UI提供的设计稿的。</p><p>如果是新开的项目，一般流程为：TR1（项目需求的一些梳理及项目立项）–&gt;TR2（需求评审，就是三方在场看看需求合不合理）–&gt;TR3（技术评估，就是前后端对需求实现的一些技术预研以及开发所用技术的一些讲解，还有此时也是测试的测试方案的讲解及输出，一般没有要求的话是没有测试计划的单独编写的，这样是为了减轻测试的一个工作量）–&gt;TR4（目前还没参与，不清楚情况）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在TR3之后一般第二天就会出开发的排期以及提测时间，测试用例的评审呢一般是在产品体验前一周就应该发起，100条测试用例以内的一般是用例评审，100条外的一般是测试点评审。测试用例评审完后需要输出用例评审缺陷表，简单的说就是统计评审过程中哪些用例被修改和被删除。产品体验完后就会发起提测，测试这时就得进行一个系统测试，测试完后呢就得输出一个测试反馈表，然后TR4会出一个测试报告</span><br></pre></td></tr></table></figure><h3 id="测试点的编写："><a href="#测试点的编写：" class="headerlink" title="测试点的编写："></a>测试点的编写：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试点编写最好是先从主要的功能模块入手，然后先写业务主流程的正向测试点，然后再写逆向，还有剩余的就再加个操作的分级以及UI，其实测试点的编写大方向应该是从操作和显示入手，如何操作呢又可以分为正向和逆向，显示呢其实也就是UI层面的东西，这部分的优先级一般是P2，主流程一律为P0级，主流程不通的话往下也测不了。另外研发的自测用例可以从已经编写好的用例中抽出主流程用例来作为研发自测用例，一般是给p0级用例给开发测。</span><br></pre></td></tr></table></figure><h3 id="接口测试的一个学习："><a href="#接口测试的一个学习：" class="headerlink" title="接口测试的一个学习："></a>接口测试的一个学习：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.打开需要抓包的网页</span><br><span class="line">2.打开浏览器f12</span><br><span class="line">3.选择network</span><br><span class="line">4.操作网页执行动作</span><br><span class="line">5.查看接口的请求报文和响应报文</span><br><span class="line"></span><br><span class="line">一般是在headers看，headers有三个下拉框：General(概要，里面有请求地址、状态码、请求方式)，Response Headers(响应头)，Request Headers(请求头)</span><br><span class="line"></span><br><span class="line">发送请求需要有请求URL，请求方式，请求体</span><br></pre></td></tr></table></figure><p><img src="Users\Lenovo\Desktop\图片\image-20230803171756040.png" alt="image-20230803171756040"></p><h4 id="接口用例的编写："><a href="#接口用例的编写：" class="headerlink" title="接口用例的编写："></a>接口用例的编写：</h4><ol><li><p>接口用例设计方法</p><ol><li>单接口测试</li></ol><ul><li>正向测试<ul><li>必选参数：所有必选都包含</li><li>必选+任意一个或多个非必选</li><li>全部参数：所有的必选+所有的可选参数</li></ul></li><li>反向测试<ul><li>多参：多出一个或多个必选参数</li><li>少参：缺少一个或多个必选参数</li><li>无参：没有必选参数</li><li>错误参数：参数名输入错误</li></ul></li></ul><ol><li>业务场景测试（多接口）</li></ol><ul><li>针对业务功能用例中操作步骤，分析对应的接口请求</li></ul></li></ol><h4 id="接口测试10要素："><a href="#接口测试10要素：" class="headerlink" title="接口测试10要素："></a>接口测试10要素：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编号、用例标题、模块、优先级、预置条件、请求方法、URL、请求头、请求体、预期结果</span><br></pre></td></tr></table></figure><p>接口测试测试点分析与功能测试相同</p><h3 id="对于python深浅拷贝的认知和学习"><a href="#对于python深浅拷贝的认知和学习" class="headerlink" title="对于python深浅拷贝的认知和学习"></a>对于python深浅拷贝的认知和学习</h3><blockquote><p>深浅拷贝主要是对python中copy模块中的copy()和deepcopy()的用法</p></blockquote><ul><li>这里先总结下深拷贝（深拷贝较好理解）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深拷贝其实就是完全拷贝，可以理解为复制出来了一份新的东西，与原先的值完全无瓜葛，内存的地址是完全不一样的（即id()不同），无论改变深拷贝之后的值还是拷贝的值都不会互相影响。</span><br></pre></td></tr></table></figure><ul><li><p>接下来说说浅拷贝（浅拷贝需要分可变类型和不可变类型）</p><ul><li>可变类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python的可变类型有列表、字典、集合。</span><br></pre></td></tr></table></figure><ul><li>不可变类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python的不可变类型有字符串、元组、数值。</span><br></pre></td></tr></table></figure><ul><li>不可变类型的浅拷贝</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不可变类型的浅拷贝是和赋值一样的，拷贝的变量和被拷贝的变量id()一样。也就是改变值会互相影响</span><br></pre></td></tr></table></figure><ul><li>可变类型的浅拷贝（无嵌套复杂子对象）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可变类型的浅拷贝也是分两种情况，首先说说第一种，无嵌套复杂子对象的情况。如：l = [1,2,3,4]</span><br><span class="line">这种时候浅拷贝的变量和被拷贝的变量的id()是不一样的，也就是改变值不会互相影响</span><br></pre></td></tr></table></figure><ul><li>可变类型的浅拷贝（有嵌套复杂子对象）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二种情况是有嵌套复杂子对象，如：l = [1，2，3，[1,2]]</span><br><span class="line">这种情况只要浅拷贝的变量或者被拷贝的变量对复杂子对象的值即l[3]进行变更，那么都会影响到另一个变量。对外面一层即l[0]、l[1]、l[2]这些值进行变更就不会影响另外的变量。</span><br></pre></td></tr></table></figure></li></ul><h3 id="Linux一些命令的学习"><a href="#Linux一些命令的学习" class="headerlink" title="Linux一些命令的学习"></a>Linux一些命令的学习</h3><ul><li>查看GPU</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重温python</title>
      <link href="/2023/09/08/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/08/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Python特点"><a href="#Python特点" class="headerlink" title="Python特点"></a>Python特点</h3><ol><li>解释型语言,运行速度慢，代码要一行一行解释成机器码运行，编译型语言（C语言）在运行前就转换成机器码，所以非常快。</li><li>简单、代码量少。</li><li>代码透明，不能加密，这是解释型语言的特点。</li></ol><h3 id="Python语法"><a href="#Python语法" class="headerlink" title="Python语法"></a>Python语法</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li>逻辑运算符：and not or</li><li>算术运算符：&#x2F;(精确除法，结果为浮点数)，&#x2F;&#x2F;（结果向下取整），%（结果取余数）</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>可变类型：列表，字典</li><li>不可变类型：元组，字符串，数字</li></ul><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ol><li>append（）添加元素</li><li>insert（index，value），第一个参数填写要插入的索引号，第二个参数是要插入的值</li><li>pop（）删除末尾的元素，pop（index）删除指定索引位置的值，均会返回被删除的值</li><li>列表拼接可以直接用+</li></ol><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><ol><li>元组没有列表对元素进行变更的方法，因为tuple不可变，其他获取元素的方法和list一样。</li><li>要定义元组可以用以下方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = （1，2） #定义2个元素的tuple</span><br><span class="line">t = （）#定义空的tuple</span><br><span class="line">t = （1，） #定义一个元素的tuple，要在元素后加逗号，以此来消除数学括号带来的歧义。</span><br></pre></td></tr></table></figure><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;michael&#x27;:95,&#x27;Bob&#x27;:&#x27;75&#x27;&#125;</span><br><span class="line">key in d,判断key是否存在，或者用d.get(key),key不存在返回None，存在返回对应的value</span><br><span class="line">d.pop(key)删除对应的key和value，dict中的key是不可变对象。在python中字符串、整数等都是不可变的，因此，可以放心作为key。而list是可变的，就不能作为key。</span><br></pre></td></tr></table></figure><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">要创建一个set，需要提供一个list作为输入集合：s = set([1,2,3])</span><br><span class="line">添加元素：add(key),可以重复添加，但不会有效果</span><br><span class="line">删除元素：remove(key)</span><br><span class="line">set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</span><br><span class="line">s1 = set([1, 2, 3])</span><br><span class="line">s2 = set([2, 3, 4])</span><br><span class="line">s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</span><br></pre></td></tr></table></figure><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if addition ：</span><br><span class="line">代码块</span><br><span class="line">else：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if addition :</span><br><span class="line">代码块</span><br><span class="line">elif addition :</span><br><span class="line">代码块</span><br><span class="line">else :</span><br><span class="line">代码块</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for...in循环，依次把list或tuple中的每个元素迭代出来</span><br><span class="line">for l in lis ：</span><br><span class="line">代码块</span><br><span class="line">while循环，只要条件满足，就不断循环，条件不满足时退出循环。</span><br><span class="line">while n &gt; 0:</span><br><span class="line">   代码块</span><br><span class="line">break，在循环中，break语句可以提前退出循环。</span><br><span class="line">continue,跳出当前的循环，直接开始下一次的循环</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一是必选参数在前，默认参数在后，否则Python的解释器会报错。</span><br><span class="line">定义默认参数要牢记一点：默认参数必须指向不变对象！</span><br><span class="line">可变参数*args，参数args接收到的是一个元组。</span><br><span class="line">关键字参数**kwargs，这些关键字参数在函数内部自动组装为一个dict。</span><br></pre></td></tr></table></figure><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = [1,2,3,4]</span><br><span class="line">l[0:3]表示从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</span><br><span class="line">如果第一个索引是0还可以简写成：l[:3]。</span><br><span class="line">也可以从索引1开始，如：l[1:3]。</span><br><span class="line">这种切片操作理解为左闭右开就好了。</span><br><span class="line">[::2]这种操作表示每隔2个取1个。</span><br><span class="line">tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。</span><br><span class="line">字符串&#x27;xxx&#x27;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串。</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</span><br><span class="line">默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。</span><br></pre></td></tr></table></figure><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[s for s in str]</span><br></pre></td></tr></table></figure><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这种一边循环一边计算的机制，称为生成器：generator。</span><br><span class="line">要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()。</span><br><span class="line">g = (x for x in range(1,11))</span><br><span class="line">通过next()获取generator的下一个返回值，当然，一个个调用next（）不是很现实，可以用for循环，因为generator也是可迭代对象</span><br><span class="line">一般定义一个generator函数可以在里面加yield（作用相当于return，可以当函数使用，返回参数，下次用next（）调用同个generator对象的时候，从上次执行到的yield位置继续执行）。如：</span><br><span class="line">def odd():</span><br><span class="line">    print(&#x27;step 1&#x27;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&#x27;step 2&#x27;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&#x27;step 3&#x27;)</span><br><span class="line">    yield(5)</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">凡是可作用于for循环的对象都是Iterable类型；</span><br><span class="line"></span><br><span class="line">凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</span><br><span class="line">集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</span><br><span class="line"></span><br><span class="line">Python的for循环本质上就是通过不断调用next()函数实现的</span><br></pre></td></tr></table></figure><h4 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h4><h5 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关键字lambda表示匿名函数，冒号前面的x表示函数参数。</span><br><span class="line"></span><br><span class="line">匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</span><br><span class="line"></span><br><span class="line">用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</span><br></pre></td></tr></table></figure><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包是用来组织模块，避免相同模块名冲突。包的下面会有一个__init__.py文件，它可以是一个空文件，这样python就会把这个目录当成一个包。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>conda和django的学习</title>
      <link href="/2023/08/25/conda&amp;&amp;django%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/25/conda&amp;&amp;django%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ol><li><p>pip下载出现SSL连接超时问题可以在下载第三方库后面指定镜像：</p><blockquote><p>-i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p></blockquote></li><li><p>配置selenium：先下载selenium</p></li></ol><blockquote><p>pip install selenium -i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com –ignore-installed</p></blockquote><ol start="3"><li><p>下载对应浏览器版本的浏览器驱动</p></li><li><p>将浏览器驱动放置与python解释器一个目录下</p></li></ol><hr><p>添加Anaconda的TUNA镜像</p><blockquote><p>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></p></blockquote><blockquote><p>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</a></p></blockquote><blockquote><p>conda config –set show_channel_urls yes</p></blockquote><p>创建一个3.6版本的python环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name py36 python=3.6</span><br></pre></td></tr></table></figure><p>创建一个2.7版本的python环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name py27 python=2.7</span><br></pre></td></tr></table></figure><p>在window上使用activate激活环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate py36</span><br></pre></td></tr></table></figure><p>在Linux &amp; Mac中使用source activate激活</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate py36</span><br></pre></td></tr></table></figure><p>激活后，会发现terminal输入的地方多了(py34)的字样，这表示我们已经进入了py34的环境中。</p><ul><li>退出环境</li></ul><p>在windows环境下使用deactivate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>在Linux &amp; Mac中使用source deactivate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source deactivate</span><br></pre></td></tr></table></figure><ul><li>删除环境</li></ul><p>如果你不想要这个名为py36的环境，可以通过以下命令删除这个环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n py36 --all</span><br></pre></td></tr></table></figure><p>可以通过以下命令查看已有的环境列表，现在py34已经不在这个列表里，所以我们知道它已经被删除了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br></pre></td></tr></table></figure><ul><li>查看已安装的包</li></ul><p>使用这条命令来查看在当前环境中，已安装的包和对应版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><ul><li>查看可安装的包</li></ul><p>我们可以通过search命令检查pandas这个包是否可以通过conda来安装</p><p>命令返回了这个包的信息，所以是可以通过conda安装的</p><p>我们可以通过<!--search-->命令检查pandas这个包是否可以通过conda来安装</p><p> #命令返回了这个包的信息，所以是可以通过conda安装的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search pandas</span><br></pre></td></tr></table></figure><ul><li>安装包</li></ul><p>如果pandas已经存在于环境中，会提示已经安装，否则在提示proceed ([y]&#x2F;n)? 中输入y进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pandas</span><br></pre></td></tr></table></figure><ul><li>更新包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update pandas</span><br></pre></td></tr></table></figure><ul><li>卸载包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove pandas</span><br></pre></td></tr></table></figure><p>conda将conda、python等都视为包，因此，完全可以使用conda来管理conda和python的版本</p><ul><li>更新python</li></ul><p>例如我们所启用的环境是py34，使用的是python3.6,那么conda会将python升级为3.6.x系列中的最新版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update python </span><br></pre></td></tr></table></figure><blockquote><p>selenium自动化需要设置等待时间，给予网页元素显现出来，不然会报错</p></blockquote><hr><ul><li><p>定义变量不需要用上$符号</p></li><li><p>使用一个已经定义过的变量需要用${变量名}。</p></li><li><p>删除变量使用unset var_name</p></li><li><p>shell中只有字符串和数字两种变量，其中字符串可以单引号或者双引号</p><ul><li><p>单引号中任何字符都会原样输出，单引号字符串中的变量是无效的</p></li><li><p>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p></li><li><p>双引号里可以有变量，可以出现转义字符</p></li></ul></li><li><p>$</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>selenium的学习(一)</title>
      <link href="/2023/07/23/selenium%E7%9A%84%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
      <url>/2023/07/23/selenium%E7%9A%84%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selenium的send_keys（）可以上传文件，参数填文件路径即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">今日学习目标：</span><br><span class="line">1.下拉选择框</span><br><span class="line">2.弹出框</span><br><span class="line">3.滚动条操作</span><br><span class="line">4.frame表单切换</span><br><span class="line">5.多窗口切换</span><br><span class="line">6.窗口截图、验证码处理</span><br></pre></td></tr></table></figure><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><h4 id="Select类操纵select元素"><a href="#Select类操纵select元素" class="headerlink" title="Select类操纵select元素"></a>Select类操纵select元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.导入Select包</span><br><span class="line">2.实例化Select对象</span><br><span class="line"></span><br><span class="line">注意：Select类是通过select标签来控制其下的option元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">通过索引切换</span><br><span class="line">select_by_index()</span><br><span class="line">通过属性value值切换</span><br><span class="line">select_by_value()</span><br><span class="line">通过显示文本切换</span><br><span class="line">select_by_visible_text()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以直接用css方法定位</span><br></pre></td></tr></table></figure><h3 id="弹出框处理"><a href="#弹出框处理" class="headerlink" title="弹出框处理"></a>弹出框处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见的弹出框：</span><br><span class="line">1.警告框alert</span><br><span class="line">2.确认框confirm</span><br><span class="line">3.提示框prompt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">不处理掉弹出框的话，下面的操作会不生效</span><br><span class="line"></span><br><span class="line">如何处理？</span><br><span class="line">以上三种弹出框处理方法一样</span><br><span class="line">步骤：</span><br><span class="line">1.切换到对话框</span><br><span class="line">方法：driver.switch_to.alert默认返回的是alert对话框的对象</span><br><span class="line">2.处理对话框</span><br><span class="line">alert.text 获取文本</span><br><span class="line">alert.accept 同意</span><br><span class="line">alert.dismiss 取消</span><br><span class="line"></span><br><span class="line">提示：无论以上哪个对话框，都可以使用取消、同意；因为调用的是后台的事件，跟页面显示的按钮数量无关。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.driver.switch_to.alert 方法适合以上三种类型对话框，调用时没有括号</span><br><span class="line">2.获取文本的方法，调用时没有括号，如：alert.text</span><br><span class="line">3.在项目中不是所有的小窗口都是以上三种对话框。</span><br></pre></td></tr></table></figure><h3 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于前端技术框架的原因，现在的页面元素基本为动态显示。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.设置js脚本控制滚动条</span><br><span class="line">js = “window.scrollTo(0,1000)”</span><br><span class="line">(0:左边距,1000:上边距)</span><br><span class="line">2.selenium调用执行js脚本的方法</span><br><span class="line">driver.execute_script(js) </span><br></pre></td></tr></table></figure><h3 id="Frame切换-多窗口切换"><a href="#Frame切换-多窗口切换" class="headerlink" title="Frame切换&#x2F;多窗口切换"></a>Frame切换&#x2F;多窗口切换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（五）--web自动化测试</title>
      <link href="/2023/07/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%94%EF%BC%89-web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/07/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%94%EF%BC%89-web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="自动化测试能解决什么问题？"><a href="#自动化测试能解决什么问题？" class="headerlink" title="自动化测试能解决什么问题？"></a>自动化测试能解决什么问题？</h2><ol><li>回归测试（重点）</li><li>压力测试</li><li>兼容性测试（1、浏览器 ，2、分辨率，3、操作系统）</li></ol><h2 id="什么Web项目适合做自动化测试？"><a href="#什么Web项目适合做自动化测试？" class="headerlink" title="什么Web项目适合做自动化测试？"></a>什么Web项目适合做自动化测试？</h2><ol><li>需求变动不频繁</li><li>项目周期长</li><li>项目需要回归测试</li></ol><h2 id="Web自动化测试在什么阶段开始？"><a href="#Web自动化测试在什么阶段开始？" class="headerlink" title="Web自动化测试在什么阶段开始？"></a>Web自动化测试在什么阶段开始？</h2><p>功能测试完毕（手动测试之后），1是时间问题，2是手工测试的时候功能还不完善。</p><h2 id="Web自动化测试所属分类"><a href="#Web自动化测试所属分类" class="headerlink" title="Web自动化测试所属分类"></a>Web自动化测试所属分类</h2><ol><li>黑盒测试（功能测试）</li><li>白盒测试（单元测试）</li><li>灰盒测试（接口测试）</li></ol><blockquote><ol><li><p>以上分类是站在代码可见度上划分</p></li><li><p>web自动化测试属于黑盒测试</p></li></ol></blockquote><h2 id="自动化测试分类"><a href="#自动化测试分类" class="headerlink" title="自动化测试分类"></a>自动化测试分类</h2><ol><li>Web自动化测试</li><li>移动自动化测试（app自动化）</li><li>接口自动化（可以用工具或者代码实现）</li><li>单元测试</li></ol><h2 id="主流的web自动化测试工具"><a href="#主流的web自动化测试工具" class="headerlink" title="主流的web自动化测试工具"></a>主流的web自动化测试工具</h2><ol><li>qtp（收费）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">支持web、桌面自动化测试</span><br></pre></td></tr></table></figure><ol><li>selenium（免费）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个开源的web自动化测试工具，主要做功能测试</span><br></pre></td></tr></table></figure><ol><li>robot framework</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个基于python可扩展的关键字驱动的测试自动化框架（已淘汰）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（四）--阶段性总结</title>
      <link href="/2023/07/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89-%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89-%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><blockquote><p>功能测试阶段主要是用例的编写，测试点的提取。</p></blockquote><ul><li>测试点主要可以根据需求分为功能和非功能两点来编写，额外的功能模块可以通过显示与操作两点来提取。</li><li>功能方面就是一些功能性的模块，如输入框，列表，表单之类的。</li><li>非功能一般是兼容性，如浏览器兼容性，操作系统兼容性，或者还有安全测试等方面。</li><li>缺陷的判断主要根据需求、原型图、以及用户体验等等方面。</li><li>写测试点的时候比较熟悉的情况下可以之间按正向逆向划分编写，正向即有效等价类，逆向即无效等价类，统计用例数量的时候，正向一般按最多的算，而逆向呢就是每一条逆向测试点都算一条测试用例。</li><li>测试用例编写首先要先编写业务用例，其次才是编写单功能用例</li><li>如何保证设计用例最大可能覆盖需求？<ul><li>先功能<ul><li>覆盖面：正向、逆向</li><li>操作：1、提取测试点，2、编写用例覆盖测点</li></ul></li><li>后非功能<ul><li>易用性、兼容性、安全性等等</li></ul></li></ul></li></ul><blockquote><p>下个阶段为web自动化测试的学习。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试（三）-缺陷</title>
      <link href="/2023/07/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BC%BA%E9%99%B7/"/>
      <url>/2023/07/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BC%BA%E9%99%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><blockquote><p>定义：软件中存在的各种问题，都为缺陷，简称bug。</p></blockquote><h3 id="缺陷标准"><a href="#缺陷标准" class="headerlink" title="缺陷标准"></a>缺陷标准</h3><ol><li>少功能</li><li>功能错误</li><li>多功能</li><li>缺少隐形功能</li><li>易用性（软件测试人员专业角度）</li></ol><h3 id="缺陷产生的原因"><a href="#缺陷产生的原因" class="headerlink" title="缺陷产生的原因"></a>缺陷产生的原因</h3><ol><li>需求文档</li><li>架构设计</li><li>编码实现</li><li>环境（硬件、软件）</li></ol><h3 id="缺陷类型"><a href="#缺陷类型" class="headerlink" title="缺陷类型"></a>缺陷类型</h3><ol><li>功能错误</li><li>UI页面错误</li><li>兼容性</li><li>数据库</li><li>易用性</li><li>建议</li><li>架构缺陷</li></ol><ul><li>工作流程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设计用例-&gt;执行用例（执行测试）-&gt;缺陷（提交、验证、关闭）</span><br><span class="line">缺陷管理流程：提交、验证、关闭</span><br><span class="line">缺陷定义：任何问题</span><br><span class="line">缺陷标准：多功能、少功能、功能错误、缺少隐形功能、易用性</span><br><span class="line">描述缺陷：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注。</span><br><span class="line">提交缺陷信息：指派人、缺陷等级、修复优先级、类型</span><br></pre></td></tr></table></figure><h3 id="提交缺陷注意事项"><a href="#提交缺陷注意事项" class="headerlink" title="提交缺陷注意事项"></a>提交缺陷注意事项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">确定缺陷是否可重现</span><br><span class="line">确定是否为bug</span><br><span class="line">确定是否具有唯一性</span><br></pre></td></tr></table></figure><ul><li>缺陷标题模板<ul><li>测试数据描述+实际结果（预期结果）</li><li>测试数据描述+预期结果（实际结果）</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试(二)--用例方法</title>
      <link href="/2023/07/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="用例设计方法"><a href="#用例设计方法" class="headerlink" title="用例设计方法"></a>用例设计方法</h1><h2 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在所有测试数据中，具有某种共同特征的数据集进行划分。</span><br><span class="line">有效等价类：满足需求的数据集合</span><br><span class="line">无效等价类：不满足需求的数据集合</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重点：有效和单个无效等价各取其1即可。</span><br><span class="line">用法：有效等价取1个值</span><br><span class="line"> 每个无效集合取1个</span><br><span class="line">步骤：</span><br><span class="line">1.明确需求</span><br><span class="line">2.划分有效等价和无效等价</span><br><span class="line">3.设计数据编写用例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">适用场景：能对穷举场景设计测试点（解决穷举场景）</span><br><span class="line">针对：需要有大量数据测试输入，但是没法穷举测试的地方；</span><br><span class="line">输入框</span><br><span class="line">下拉列表</span><br><span class="line">单选复选框</span><br><span class="line">典型代表：页面的输入框类测试。</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote><p>需求：验证6-10位自然数的qq合法性</p></blockquote><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%BA%8C)-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230702155542254.png" alt="image-20230702155542254"></p><h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用场景：能对限定边界规则设计测试点（解决边界位数限制问题）</span><br><span class="line">典型代表：有边界范围的输入框类测试</span><br><span class="line">选取正好等于、刚好大于、刚好小于边界的值作为测试数据</span><br><span class="line">上点：边界上的点</span><br><span class="line">离点：离边界最近的点</span><br><span class="line">内点：范围内的点</span><br><span class="line">提示：</span><br><span class="line">1、有关范围限制，最多7条用例（暂时未优化）</span><br><span class="line">2、边界值能解决位数限制问题，但是不能解决类型问题（要结合等价类）</span><br><span class="line">3、开内闭外</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">边界值法设计用例步骤</span><br><span class="line">1.明确需求</span><br><span class="line">2.确定有效和无效等价类</span><br><span class="line">3.确定边界范围值</span><br><span class="line">4.提取数据编写测试用例</span><br></pre></td></tr></table></figure><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%BA%8C)-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230704234340477.png" alt="image-20230704234340477"></p><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%BA%8C)-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230704234247774.png" alt="image-20230704234247774"></p><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%BA%8C)-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230704234402702.png" alt="image-20230704234402702"></p><h3 id="边界值分析优化"><a href="#边界值分析优化" class="headerlink" title="边界值分析优化"></a>边界值分析优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结论：7个优化为5个点</span><br><span class="line">上点：必选（不考虑区间开闭）</span><br><span class="line">内点：必选（建议选择中间范围）</span><br><span class="line">离点：开内闭外（考虑开闭区间，开区间选择内部离点，闭区间选择外部离点）</span><br></pre></td></tr></table></figure><h2 id="判定表方法"><a href="#判定表方法" class="headerlink" title="判定表方法"></a>判定表方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用场景：解决多条件依赖测试问题，使用判定表来进行测试覆盖。</span><br><span class="line">定义：是一种以表格形式表达多条件逻辑判断的工具</span><br><span class="line">组成：</span><br><span class="line">条件桩：列出问题中的所有条件，列出条件的次序无关紧要。</span><br><span class="line">动作桩：列出问题中可能采取的操作，操作的排列顺序没有约束。</span><br><span class="line">条件项：列出条件对应的取值，所有可能情况下的真假值</span><br><span class="line">动作项：列出条件项的、各种取值情况下应该采取的动作结果。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1、明确需求</span><br><span class="line">2、画出判定表</span><br><span class="line">1.列出条件桩和动作桩</span><br><span class="line">2.填写条件项，对条件进行全组合</span><br><span class="line">3.根据条件项的组合确定动作项</span><br><span class="line">4.简化、合并相似规则（有相同的动作）</span><br><span class="line">3、根据规则编写测试用例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用场景：</span><br><span class="line">判定表一般适用于条件组合数量较少的情况（比如4个条件以下）</span><br><span class="line">有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖（制约）关系</span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="判断表"><a href="#判断表" class="headerlink" title="判断表"></a>判断表</h4><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%BA%8C)-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230706235527348.png" alt="image-20230706235527348"></p><h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%BA%8C)-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230706235951966.png" alt="image-20230706235951966"></p><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><blockquote><p>覆盖业务测试，需要使用流程图法</p><p>先测试业务，在测试单功能、单模块、单页面</p><p>场景法也可以叫流程图法。</p></blockquote><h2 id="错误推荐法"><a href="#错误推荐法" class="headerlink" title="错误推荐法"></a>错误推荐法</h2><blockquote><p>通过经验推测系统可能出现的问题</p><p>应用场景：当项目用例都执行完毕，且bug修复完成，离上线还有一段时间，在这段时间中可以使用错误推荐法复测主要业务或测试未覆盖的主要功能。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>等价类划分</p><ol><li><p>能对穷举场景设计测试点</p></li><li><p>难点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度：边界</span><br><span class="line">类型：等价</span><br><span class="line">规则：等价</span><br></pre></td></tr></table></figure></li></ol></li><li><p>边界值分析</p><ol><li>能对限定边界规则进行设计测试点</li></ol></li><li><p>判定表</p><ol><li>能对多条件依赖关系进行设计测试点</li></ol></li><li><p>流程图法（场景法）</p><ol><li><p>能对项目业务进行设计测试点</p></li><li><p>重点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先测业务，再测单功能、单模块</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试(一)——了解测试</title>
      <link href="/2023/06/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/06/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><blockquote><p>软件测试的定义：使用技术手段验证软件是否满足需求。</p></blockquote><h2 id="测试发展方向"><a href="#测试发展方向" class="headerlink" title="测试发展方向"></a>测试发展方向</h2><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%B8%80)-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95%5Cimage-20230628204736929.png" alt="image-20230628204736929"></p><ul><li>功能测试+接口测试</li><li>功能测试+web自动化</li><li>功能测试+性能测试</li></ul><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><h3 id="按阶段划分"><a href="#按阶段划分" class="headerlink" title="按阶段划分"></a>按阶段划分</h3><ul><li>单元测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对程序源代码进行测试</span><br></pre></td></tr></table></figure><ul><li>集成测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">又称接口测试，针对模块之间访问地址进行测试</span><br></pre></td></tr></table></figure><ul><li>系统测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对整个系统进行测试包括功能、兼容、文档等测试</span><br></pre></td></tr></table></figure><ul><li>验收测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要分为公测、内测。使用不同人群来发掘项目缺陷。</span><br></pre></td></tr></table></figure><h3 id="按代码可见度划分"><a href="#按代码可见度划分" class="headerlink" title="按代码可见度划分"></a>按代码可见度划分</h3><ul><li>黑盒测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不关注源代码，针对程序UI功能进行测试（系统测试）</span><br></pre></td></tr></table></figure><ul><li>灰盒测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对程序部分代码进行测试（集成测试）</span><br></pre></td></tr></table></figure><ul><li>白盒测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对程序源代码进行测试（单元测试）</span><br></pre></td></tr></table></figure><h3 id="专项"><a href="#专项" class="headerlink" title="专项"></a>专项</h3><ul><li>性能测试</li><li>安全测试</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><blockquote><p>一个优秀软件可以从以下八个维度进行衡量。</p></blockquote><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95(%E4%B8%80)-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95%5Cimage-20230628211432755.png" alt="image-20230628211432755"></p><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><ol><li>需求分析与评审</li><li>编写测试计划</li><li>编写测试用例与评审</li><li>执行用例与缺陷管理</li><li>编写测试报告及总结</li></ol><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="测试的作用"><a href="#测试的作用" class="headerlink" title="测试的作用"></a>测试的作用</h3><ul><li>防止漏测</li><li>实施测试的标准</li></ul><h3 id="测试用例设计编写格式"><a href="#测试用例设计编写格式" class="headerlink" title="测试用例设计编写格式"></a>测试用例设计编写格式</h3><ul><li>用例编号<ul><li>项目_模块__编号</li></ul></li><li>用例标题<ul><li>预期结果（测试点）</li></ul></li><li>模块&#x2F;项目<ul><li>所属项目或模块</li></ul></li><li>优先级<ul><li>表示用例的重要程度或者影响力p0~p4（p0最高）</li></ul></li><li>前置条件<ul><li>要执行此条用例，有哪些前置操作</li></ul></li><li>测试步骤<ul><li>描述操作步骤</li></ul></li><li>测试数据<ul><li>操作的数据，没有的话可以为空</li></ul></li><li>预期结果<ul><li>期望达到的结果</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维中段学习(二)</title>
      <link href="/2023/05/20/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/05/20/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h3 id="Nginx的简介"><a href="#Nginx的简介" class="headerlink" title="Nginx的简介"></a>Nginx的简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx可以用来做http服务与反向代理服务器。</span><br></pre></td></tr></table></figure><h3 id="Nginx的优势"><a href="#Nginx的优势" class="headerlink" title="Nginx的优势"></a>Nginx的优势</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IO多路复用</span><br><span class="line">时分多路复用</span><br><span class="line">频分多路复用</span><br></pre></td></tr></table></figure><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一种方法：最传统的多进程并发模型（每进来一个新的I/O流就分配一个新的进程管理）</span><br><span class="line">第二种方法：I/O多路复用（单个线程，通过记录跟踪每个I/O流（sock）的状态，来同时管理多个I/O流。）</span><br><span class="line">发明它的原因，是尽量多的提高服务器的吞吐能力</span><br><span class="line">在同一个线程里，通过拨开关的方式，来同时传输多个I/O流。</span><br><span class="line"></span><br><span class="line">技术类型：select、poll、epoll，epoll可以说是I/O多路复用最新的一个实现，epoll修复了poll和sellect绝大部分问题，比如：</span><br><span class="line">epoll现在是线程安全的。epoll现在不仅告诉你sock组里面数据，还会告诉你具体哪个sock有数据，不用自己找了。</span><br><span class="line">特点是异步，非阻塞。</span><br></pre></td></tr></table></figure><h3 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nginx-部署-yum"><a href="#Nginx-部署-yum" class="headerlink" title="Nginx 部署-yum"></a>Nginx 部署-yum</h3><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%5Cimage-20230522183750594.png" alt="image-20230522183750594"></p><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%5Cimage-20230522185948862.png" alt="image-20230522185948862"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rpm -lq nginx   ----查看nginx所有文件和路径的列表</span><br><span class="line">常用的配置文件：</span><br><span class="line">/etc/logrotate.d/nginx ---日志轮转</span><br><span class="line">/etc/nginx/nginx.conf  ---总配置文件</span><br><span class="line">/etc/nginx/conf.d  ---子配置文件夹</span><br><span class="line">/etc/nginx/conf.d/default.conf  ---默认的网站配置文件</span><br><span class="line">/etc/nginx/mime.type  ---文件关联程序，网站文件类型和相关处理程序。</span><br><span class="line">/etc/nginx/moubles   ---nginx模块，第三方模块在这放</span><br><span class="line">/usr/lib/systemd/system/nginx.service.systemctl   ---服务脚本</span><br><span class="line">/usr/sbin/nginx  ---主程序</span><br><span class="line">/var/cache/nginx  ---程序缓存</span><br><span class="line">/var/log/nginx    ---日志文件夹</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nginx编译参数"><a href="#Nginx编译参数" class="headerlink" title="Nginx编译参数"></a>Nginx编译参数</h3><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%5Cimage-20230522192254763.png" alt="image-20230522192254763"></p><h3 id="Nginx虚拟主机"><a href="#Nginx虚拟主机" class="headerlink" title="Nginx虚拟主机"></a>Nginx虚拟主机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx/conf.d/default.conf</span><br><span class="line">虚拟主机可以写在上面文件中的server，也可以写在/etc/nginx/nginx.conf中的http中去嵌套server</span><br><span class="line"></span><br><span class="line">用户默认访问 /usr/share/nginx/html</span><br><span class="line">实验：</span><br><span class="line">创建 /lifei目录</span><br><span class="line">创建 /lifei/index.html文件并写入内容</span><br><span class="line"></span><br><span class="line">创建nginx的配置文件，在/etc/nginx/conf.d/下创建lifei.conf,内容如下：</span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">        listen 80;   //访问端口</span><br><span class="line">        server_name www.lifei.com;  //服务器域名</span><br><span class="line">location / &#123;</span><br><span class="line">        root /lifei;      //网站文件存放目录</span><br><span class="line">        index index.html;  //网站默认首页</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">建立本地域名解析（如有真实域名可填写），在/etc/hosts文件内配置域名解析</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nginx日志Log"><a href="#Nginx日志Log" class="headerlink" title="Nginx日志Log"></a>Nginx日志Log</h3><h4 id="日志相关配置"><a href="#日志相关配置" class="headerlink" title="日志相关配置"></a>日志相关配置</h4><ul><li>相关指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  ---日志格式</span><br><span class="line">access_log  ---访问日志</span><br><span class="line">error_log   ---错误日志</span><br><span class="line">open_log_file_cache</span><br></pre></td></tr></table></figure><ul><li>日志的格式与命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_format</span><br><span class="line">定义位置：vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>访问日志和错误日志</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">access_log</span><br><span class="line"></span><br><span class="line">error_log</span><br><span class="line">在 /var/log/nginx/目录下。</span><br><span class="line">可以个性化404页面</span><br></pre></td></tr></table></figure><ul><li>日志缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大量访问到来时，对于每一条日志记录都是先打开文件，再写入文件，然后关闭文件，这样会占用大量的系统IO，所以可以用open_log_file_cache来设置。即用缓存来先记录日志。可以再/etc/nginx/conf.d/目录下的相应网站配置文件配置</span><br></pre></td></tr></table></figure><ul><li>日志轮转</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再/etc/logrotate.d/nginx文件下</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维中段学习(一)</title>
      <link href="/2023/05/02/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/05/02/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Ansible自动化运维"><a href="#Ansible自动化运维" class="headerlink" title="Ansible自动化运维"></a>Ansible自动化运维</h1><h3 id="ansible简介"><a href="#ansible简介" class="headerlink" title="ansible简介"></a>ansible简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible是基于python开发，实现了批量系统配置、批量程序部署登功能。无客户端。</span><br><span class="line"></span><br><span class="line">ansible工作原理：</span><br><span class="line">有一个management node（管理节点），若干个node。</span><br></pre></td></tr></table></figure><h3 id="ansible部署"><a href="#ansible部署" class="headerlink" title="ansible部署"></a>ansible部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ansible（如果没有epel.repo，请先安装epel的yum源）</span><br><span class="line">换yum源后出现404问题可以用yum clean all与rpm --rebuilddb解决。</span><br><span class="line">检查安装是否完成：</span><br><span class="line">yum list | grep ansible或者rpm -ql ansible（列出所有文件）</span><br><span class="line">rpm -qc ansible ---查看配置文件</span><br><span class="line">ansible-doc-l  ---查看所有模块</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh-key"></a>ssh-key</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh keygen  ---生成密钥</span><br><span class="line">ssh-copy-id IP地址  ---推送公钥</span><br></pre></td></tr></table></figure><h3 id="ansible基础"><a href="#ansible基础" class="headerlink" title="ansible基础"></a>ansible基础</h3><ul><li><p>1.定义主机清单</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在/etc/anisble/hosts文件下写入控制的主机如host1、host2</span><br></pre></td></tr></table></figure></li><li><p>2.测试连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible localhost -m ping或</span><br><span class="line">ansible host1 -m ping</span><br><span class="line">简洁输出加选项o即：</span><br><span class="line">ansible host1 -m ping -o</span><br></pre></td></tr></table></figure></li><li><p>4.know_hosts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible host2 —m ping -u root -k    ---未设置免密登录的主机host2的连接</span><br><span class="line">去掉yes/no询问</span><br><span class="line"> vim /etc/ssh/ssh_config</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line"> systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>5.inventory-主机清单</p><ul><li>1.增加主机组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">vim /etc/ansible/hosts</span><br><span class="line">  [webserver]</span><br><span class="line">host1</span><br><span class="line">host2</span><br><span class="line">host3</span><br><span class="line">连接组：ansible webserver -m ping -o</span><br></pre></td></tr></table></figure><ul><li><p>2.增加用户名密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">host1 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host2 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host3 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">或者：</span><br><span class="line">host[1:3] ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br></pre></td></tr></table></figure></li><li><p>3.修改端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">Port 22 改为 Port 要修改的端口</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>4.增加端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">host[1:2] ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host3 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27; ansible_ssh_port=&#x27;2222&#x27;</span><br></pre></td></tr></table></figure></li><li><p>5.组：变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">host[1:2] ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host3 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27; ansible_ssh_port=&#x27;2222&#x27;</span><br></pre></td></tr></table></figure></li><li><p>6.子分组</p></li></ul><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%B8%80)%5Cimage-20230508203542570.png"></p><ul><li>7.自定义清单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先写一份主机清单格式的文件，比如hostlist</span><br><span class="line">然后用命令：ansible -i 清单名字 组名字 -m ping -o</span><br><span class="line">如 ansible -i hostlist dockers -m ping -o</span><br></pre></td></tr></table></figure></li><li><ol start="6"><li>Ad-Hoc-点对点模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">临时的，在ansible中是指需要快速执行的指令，如果是比较复杂的就需要playbook</span><br></pre></td></tr></table></figure><ul><li>1.shell模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible webserver -m shell -a &#x27;linux命令&#x27; -o</span><br><span class="line">安装mariadb-server</span><br><span class="line">ansible webserver -m shell -a &#x27;yum install -y mariadb-server&#x27; -o</span><br></pre></td></tr></table></figure><ul><li>2.复制模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">ansible webserver -m copy -a &#x27;src=/etc/hosts dest=/tmp/2.txt owner=root group=bin mode=777&#x27;</span><br><span class="line">ansible webserver -m copy -a &#x27;src=/etc/hosts dest=/tmp/2.txt owner=root group=bin mode=777 backup&#x27;</span><br><span class="line">加了backup起到备份的作用，以前的文件会改了后缀，不会被覆盖</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>3.用户模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.创建用户</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei state=present&#x27;</span><br><span class="line"></span><br><span class="line">2.修改密码</span><br><span class="line">  1.生成加密密码</span><br><span class="line">  echo ‘20230508’ | openssl passwd -1 -stdin</span><br><span class="line">  2.修改密码</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei password=&quot;步骤1生成的加密密码&quot;&#x27;</span><br><span class="line">  3.修改shell</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei shell=/sbin/nologin append=yes&#x27;            ---设置账号lifei不能登录，append是追加、修改的意思</span><br><span class="line">  4.删除用户</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei state=absent&#x27;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>4.软件包管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">帮助手册：ansible-doc yum</span><br><span class="line">ansible webserver -m yum -a &#x27;name=&quot;*&quot; state=latest&#x27;   升级所有包</span><br><span class="line">ansible webserver -m yum -a &#x27;name=&quot;httpd&quot; state=latest&#x27;  安装最新版http</span><br><span class="line">ansible webserver -m yum -a &#x27;name=&quot;httpd&quot; state=absent&#x27;  卸载http</span><br></pre></td></tr></table></figure><ul><li>5.服务模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">设置httpd开机自启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=started enabled=yes&#x27;</span><br><span class="line">将httpd开启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=started&#x27;</span><br><span class="line">将httpd关闭</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=stopped&#x27;</span><br><span class="line">将httpd重启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=restarted&#x27;</span><br><span class="line">将httpd启动并设置开机不自启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=started enabled=no&#x27;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>6.文件模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建文件</span><br><span class="line">ansible webserver -m file -a &#x27;path=/tmp/88.txt mode=777 state=touch&#x27;</span><br><span class="line">创建目录</span><br><span class="line">ansible webserver -m file -a &#x27;path=/tmp/99 mode=777 state=directory&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>7.收集模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">帮助文档：ansible-doc setup</span><br><span class="line">收集信息</span><br><span class="line">ansiblehost1 -m setup</span><br><span class="line">收集过滤后的信息</span><br><span class="line">ansiblehost1 -m setup -a &#x27;filter=ansible_all_ipv4_addresses &#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>非标记语言</p><ul><li>准备工作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">卸载httpd与httpd-tools</span><br><span class="line">ansible all -m yum -a &#x27;name=httpd state=removed&#x27; -o</span><br><span class="line">ansible all -m yum -a &#x27;name=httpd-tools state=removed&#x27; -o</span><br><span class="line">服务器安装httpd</span><br><span class="line">yum install -y httpd</span><br><span class="line">准备工作目录</span><br><span class="line">mkdir apache</span><br><span class="line">cd apache</span><br><span class="line">cp -rf /etc/httpd/conf/httpd.conf .</span><br><span class="line">ls</span><br><span class="line">查看端口号</span><br><span class="line">grep &#x27;^Listen&#x27; httpd.conf</span><br><span class="line">默认为80端口，需要改为8080</span><br></pre></td></tr></table></figure><ul><li>编写剧本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim apache.yaml</span><br><span class="line">内容如下：</span><br><span class="line">- hosts: host2</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install apache packages</span><br><span class="line">    yum: name=httpd state=present</span><br><span class="line">  - name: copy apache conf</span><br><span class="line">    copy: src=./httpd.conf dest=/etc/httpd/conf/httpd.conf</span><br><span class="line">  - name: ensure apache is running</span><br><span class="line">    service: name=httpd state=started enabled=yes</span><br><span class="line">##name是一个别名，作为解释下方模块的作用。 </span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">检查语法是否有错</span><br><span class="line">ansible-playbook apache.yaml --syntax-check</span><br><span class="line">列出任务</span><br><span class="line">ansible-playbook apache.yaml  --list-tasks</span><br><span class="line">列出任务主机</span><br><span class="line">ansible-playbook apache.yaml  --list-hosts</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>handlers</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">假如配置文件发生改变需要</span><br><span class="line">  在剧本中加入handler：</span><br><span class="line">  handlers:</span><br><span class="line">   - name: restart apache service</span><br><span class="line">     service: name=httpd state=restarted</span><br><span class="line">     </span><br><span class="line">  handlers与tasks同级</span><br><span class="line">  </span><br><span class="line">  在apche.yaml文件中：</span><br><span class="line">  - hosts: host2</span><br><span class="line">    tasks:</span><br><span class="line">    - name: install apache packages</span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: copy apache conf</span><br><span class="line">      copy: src=./httpd.conf dest=/etc/httpd/conf/httpd.conf</span><br><span class="line">      notify: restart apache service </span><br><span class="line">    - name: ensure apache is running</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">       - name: restart apache service</span><br><span class="line">    handlers:</span><br><span class="line">    - name: restart apache service</span><br><span class="line">      service: name=httpd state=restarted</span><br><span class="line">  ###解释：假如httpd.conf文件中发生改变，则会启动handlers中的service模块。copy模块中的notify值要与handlers中的name值相同，用以触发handlers</span><br></pre></td></tr></table></figure></li><li><p>Role-角色扮演</p><ul><li>简介</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roles是在ansible中，playbooks的目录组织结构。将代码或文件进行模块化，成为roles的文件目录组织结构，易读，代码可重用，层次清晰。</span><br></pre></td></tr></table></figure><ul><li>目标</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过role运程部署nginx并配置</span><br></pre></td></tr></table></figure><ul><li>目录结构</li></ul><blockquote><p>准备目录结构，文件夹名字固定</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir roles/nginx/&#123;files,handlers,tasks,templates,vars&#125; -p</span><br><span class="line">touch roles/site.yaml roles/nginx/&#123;handlers,tasks,vars&#125;/main.yaml</span><br><span class="line">echo 1234 &gt; roles/nginx/files/index.html</span><br><span class="line">yum install -y nginx &amp;&amp; cp /etc/nginx/nginx.conf roles/nginx/templates/nginx.conf.j2</span><br></pre></td></tr></table></figure><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%B8%80)%5Cimage-20230514121011679.png" alt="image-20230514121011679"></p><ul><li>编写任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/tasks/main.yaml</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">- name: install epel-release package</span><br><span class="line">  yum: name=epel-release state=latest</span><br><span class="line">- name: install nginx package</span><br><span class="line">  yum: name=nginx state=latest</span><br><span class="line">- name: copy index.html</span><br><span class="line">  copy: src=index.html dest=/usr/share/nginx/html/index.html</span><br><span class="line">- name: copy nginx.conf template</span><br><span class="line">  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  notify: restart nginx</span><br><span class="line">- name: make sure nginx service running</span><br><span class="line">  service: name=nginx state=started enabled=yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>准备配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/tmplates/nginx.conf.j2(金甲文件是带有变量的文件)</span><br><span class="line">里面有两个变量：worker_processes&#123;&#123;ansible_processor_cores&#125;&#125;  ---调用内部已知的变量</span><br><span class="line"> worker_connections&#123;&#123;worker_connections&#125;&#125;  ---自定义变量</span><br></pre></td></tr></table></figure><ul><li>编写变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/vars/main.yaml</span><br><span class="line"></span><br><span class="line">worker_connections: 10241</span><br></pre></td></tr></table></figure><ul><li>编写处理程序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/handlers/main.yaml</span><br><span class="line">---</span><br><span class="line">- name: restart nginx</span><br><span class="line">  service: name=nginx state=restarted</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>编写剧本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/site.yaml </span><br><span class="line">- hosts: webserver</span><br><span class="line">  roles:</span><br><span class="line">  - nginx       </span><br></pre></td></tr></table></figure><ul><li>实施</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd roles</span><br><span class="line">ansible-playbook site.yaml --syntax-check  --检查site.yaml的语法</span><br><span class="line"></span><br><span class="line">ansible-playbook site.yaml   --实施剧本</span><br></pre></td></tr></table></figure><blockquote><p>总结：其实编写剧本是一套流程，如同写一套系统项目代码一样，每个文件夹里的文件是各司其职的，如roles中nginx文件夹，里面的5个文件夹名字是固定的，files，handlers，vars，tasks，templates。，运行剧本是运行roles文件夹下的site.yaml，它才是整个剧本的核心运行文件。一般来指定运行哪个剧本，假如roles下有mysql、k8s、dockers等等已经写好的如同nginx文件夹一样的文件夹，site.yaml就可以指定运行哪个文件夹，并指定对象服务器集群</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维学习（七）</title>
      <link href="/2023/04/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2023/04/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="域名服务"><a href="#域名服务" class="headerlink" title="域名服务"></a>域名服务</h1><ul><li>hosts文件(老的)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：实现名字解析，主要为本地主机名、集群节点提供快速解析</span><br><span class="line">Linux位置:/etc/hosts</span><br><span class="line">缺点：不便于查询，更新</span><br></pre></td></tr></table></figure><ul><li>DNS</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：实现名字解析。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>FQDN（完全合格域名&#x2F;全称域名）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机名.二级域.顶级域.（根域）</span><br></pre></td></tr></table></figure><ul><li>命名空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name space ： 用于给互联网上的主机命名的一种机制</span><br></pre></td></tr></table></figure><ul><li>域名解析过程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.客户端先查询自己的缓存（包括hosts中的记录）和浏览器中的DNS解析器缓存</span><br><span class="line">2.如果没有，将查询发送到/etc/resolv.conf中的DNS服务器（即本地的DNS服务器）</span><br><span class="line">3.如果还没有，就往根服务器查询，根服务器往下一级级查询，然后找到之后返回给客户机。</span><br><span class="line">客户机--&gt;本地DNS服务器 （递归查询）</span><br><span class="line">本地DNS服务器--&gt;DNS服务器（迭代查询）</span><br><span class="line"></span><br><span class="line">服务器类型：主服务器、从服务器、缓存服务器</span><br><span class="line"></span><br><span class="line">正向解析：可把对应域名解析为对应的IP地址叫正向解析。</span><br><span class="line">反向解析：可把对应IP地址解析为对应的域名叫反向解析。（反垃圾邮件）</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维学习（六）</title>
      <link href="/2023/04/29/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/04/29/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="网站服务"><a href="#网站服务" class="headerlink" title="网站服务"></a>网站服务</h1><h2 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h2><ul><li>LAMP<ul><li>Linux+Apache+MySQL+PHP</li><li>PHP是中间件（网站和数据库之间的程序）</li><li>Apache是服务器程序</li></ul></li></ul><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Apache软件包名称：httpd</span><br><span class="line">服务器端口：80/tcp(http)  443/tcp(https)</span><br><span class="line">配置文件：/etc/httpd/conf/httpd.conf</span><br><span class="line">子配置文件：/etc/httpd/conf.d/*.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装httpd：</span><br><span class="line">yum install -y httpd</span><br><span class="line">软件启动：</span><br><span class="line">systemctl start httpd</span><br><span class="line">检查httpd状态：</span><br><span class="line">systemctl status httpd</span><br><span class="line">开机自启：</span><br><span class="line">systemctl enable httpd</span><br><span class="line">关闭防火墙：</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">关闭selinux防火墙：</span><br><span class="line">setenforce 0</span><br><span class="line">查看httpd版本及下载时间：</span><br><span class="line">httpd -v</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">firewalld简介：保护互联网对服务器的影响</span><br><span class="line">selinux简介：保护服务器内部程序（ftp）对内部文件（/var/ftp)的访问</span><br><span class="line">firewall临时关闭：systemctl stop firewalld</span><br><span class="line">firewall永久关闭：systemctl disable firwalld</span><br><span class="line"></span><br><span class="line">selinux临时关闭：setenforce 0</span><br><span class="line">selinux永久关闭：vim /etc/selinux/config，修改内容SELINUX=disabled</span><br><span class="line">selinux状态查看：getenforce(enfircing开启，permi放行，disable关闭)</span><br></pre></td></tr></table></figure><hr><h3 id="Apache主目录"><a href="#Apache主目录" class="headerlink" title="Apache主目录"></a>Apache主目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache默认工作目录：/var/www/html/</span><br><span class="line">主页面：/var/www/html/index.html</span><br></pre></td></tr></table></figure><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">虚拟主机目的：虚拟主机VirtualHost,作用：在一台物理服务器上运行多个网站</span><br><span class="line">类型：</span><br><span class="line">基于域名</span><br><span class="line">配置虚拟主机目标：在一台服务器上，实现两个网站的架构</span><br><span class="line">网站域名：网站资源存放目录</span><br><span class="line">例如：www.a.org  /var/www/html/a.org</span><br><span class="line">  www.b.org  /var/www/html/b.org</span><br><span class="line">  </span><br><span class="line">服务器：</span><br><span class="line">www.a.org站点设置：</span><br><span class="line">准备网站源码目录：mkdir /var/www/html/a.org</span><br><span class="line">创建a.org的网站配置文件：</span><br><span class="line">vim /etc/httpd/conf.d/a.org.conf，写如下内容：</span><br><span class="line">    &lt;VirtualHost *:80&gt;---某个虚拟主机</span><br><span class="line">    ServerName www.a.org---设置域名</span><br><span class="line">    DocumentRoot /var/www/html/a.org    ---网站的根目录</span><br><span class="line">    &lt;/VirtualHost&gt;</span><br><span class="line">检测配置文件语法，重启服务：</span><br><span class="line">httpd -t</span><br><span class="line">systemctl restart httpd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">www.b.org站点设置：</span><br><span class="line">准备网站源码目录：mkdir /b.org</span><br><span class="line">创建a.org的网站配置文件：</span><br><span class="line">vim /etc/httpd/conf.d/b.org.conf，写如下内容：</span><br><span class="line">    &lt;VirtualHost *:80&gt;---某个虚拟主机</span><br><span class="line">    ServerName www.b.org---设置域名</span><br><span class="line">    DocumentRoot /b.org    ---网站的根目录</span><br><span class="line">    &lt;/VirtualHost&gt;</span><br><span class="line">    ###授权部分，因为/b.org不是apache的默认工作目录，所以要有授权部分</span><br><span class="line">    &lt;Directory &quot;/b.org&quot;&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">要在真机windows做客户机访问要修改C:\Windows\System32\drivers\etc下的hosts</span><br></pre></td></tr></table></figure><h4 id="部署动态站点-论坛"><a href="#部署动态站点-论坛" class="headerlink" title="部署动态站点-论坛"></a>部署动态站点-论坛</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">基础环境：</span><br><span class="line">关闭firewalld与selinux</span><br><span class="line">yum install -y httpd mariadb-server mariadb php php-mysql gd php-gd</span><br><span class="line">启动：</span><br><span class="line">systemctl start httpd mariadb</span><br><span class="line">下载Discuz源码 wget https://gitee.com/Discuz/DiscuzX/attach_files/1344965/download</span><br><span class="line">解压包：</span><br><span class="line">unzip download</span><br><span class="line">复制源代码到指定目录下：</span><br><span class="line">cp -rf upload/* /webroot/discuz/</span><br><span class="line">然后对/webroot/discuz/里的目录授权：</span><br><span class="line">chown -R apache.apache /webroot/discuz/</span><br><span class="line"></span><br><span class="line">在/etc/httpd/conf.d/discuz.conf写入以下内容：</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">ServerName www.discuz.com</span><br><span class="line">DocumentRoot /webroot/discuz</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory &quot;/webroot/discuz&quot;&gt;</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">写完配置文件重启http：</span><br><span class="line">systemctl restart httpd</span><br><span class="line">准备数据库：</span><br><span class="line">在mysql环境下：</span><br><span class="line">create database discuz;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维学习（五）</title>
      <link href="/2023/04/14/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/04/14/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h3><h4 id="FTP（File-Transfer-Protocol-文件传输协议）"><a href="#FTP（File-Transfer-Protocol-文件传输协议）" class="headerlink" title="FTP（File Transfer Protocol 文件传输协议）"></a>FTP（File Transfer Protocol 文件传输协议）</h4><ul><li>作用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提供文件共享服务</span><br><span class="line">互联网上多的媒体资源和软件资源。绝大部分都是通过FTP服务器传递</span><br></pre></td></tr></table></figure><ul><li>FTP Server</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">软件包：vsftpd</span><br><span class="line">控制端口command 21/tcp</span><br><span class="line">数据端口data 20/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装vsftpd： yum install -y vsftpd</span><br><span class="line">准备分发的文件：touch /var/ftp/abc.txt</span><br><span class="line">注释：FTP服务器的主目录：“/var/ftp/”，是FTP程序分享内容的本机目录，这个目录是固定的，vsftpd下载下来就有这个目录</span><br><span class="line">启动服务：</span><br><span class="line">systemctl start vsftpd</span><br><span class="line">systemctl enable vsftpd ---开机自启</span><br><span class="line">关闭防火墙：</span><br><span class="line">systemctl stop firewalld  </span><br><span class="line">systemctl disable firewalld ---禁用防火墙，防止下次开机自启</span><br><span class="line">关闭selinux防火墙：</span><br><span class="line">setenfore 0</span><br><span class="line">设置selinux防火墙开机不自启：</span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">修改内容为：SELINUX=disabled</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>FTP Client</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">纯字符界面访问FTP服务器</span><br><span class="line">LinuxFTP客服端程序1：lftp</span><br><span class="line">安装客服端工具：yum -y install lftp</span><br><span class="line">访问服务器：lftp  服务器的IP地址</span><br><span class="line">ls  ----查看ftp服务器下的文件</span><br><span class="line">get 文件名 ---下载文件</span><br><span class="line">mirror 目录名  ---下载目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LinuxFTP客服端程序2：wget</span><br><span class="line">wget ftp://ip地址/文件名</span><br><span class="line">wget -m ftp://ip地址/文件名 ---下载文件夹</span><br><span class="line"></span><br><span class="line">启动上传功能</span><br><span class="line">配置文件--用于设定FTP服务器的功能开启或关闭的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>NFS（network file system）</li></ul><blockquote><p>Linux&#x2F;Unix系统之间共享文件的一种协议，它最大的功能就是可以<strong>通过网络，让不同的机器、不同的操作系统可以共享彼此的文件</strong>。NFS的客户端主要为linux，支持多节点同时挂载，以及并发写入</p></blockquote><p>  NFS存储器端（NAS【网络存储】）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">安装NFS服务器：</span><br><span class="line">yum install nfs-utils</span><br><span class="line">mkdir /webdata  --存储网站代码（网站目录创建非必须）</span><br><span class="line">echo &#x27;nfs test00&#x27; &gt; /webdata/index.html  --放置测试页面</span><br><span class="line"></span><br><span class="line">配置NFS服务器：</span><br><span class="line">vim /etc/exports</span><br><span class="line">/webdata 192.168.26.0/24(rw)  ---/webdata指的是发布资源的目录，192.168.26.0/24允许访问NFS的客户机，（rw）可读可写</span><br><span class="line"></span><br><span class="line">启动NFS服务器：</span><br><span class="line">systemctl start nfs-server</span><br><span class="line">systemctl enble  enble nfs-server ---设置开机自启</span><br><span class="line">exportfs -v    ----检查nfs输出是否正常</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  NFS客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">安装NFS客户端：</span><br><span class="line">yum install -y nfs-utilshttpd</span><br><span class="line">systemctl start httpd</span><br><span class="line">systemctl enble httpd</span><br><span class="line">查看存储端共享：</span><br><span class="line">showmount -e 192.168.26.128  ---查询nfs服务器可用目录</span><br><span class="line">Export list for 192.168.26.128</span><br><span class="line">/webdata 192.168.26.0/24</span><br><span class="line">mount -t nfs  192.168.26.128:/webdata   /var/www/html  ---挂载文件</span><br><span class="line">取消挂载用umount</span><br><span class="line">查看挂载用df</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以用elinks命令工具查看web页面，格式为elinks <a href="http://ip地址/">http://ip地址</a></p></blockquote><p>总结</p><p>NFS是网络文件系统</p><ul><li><p>目的：通过网络分发文件，这不跟FTP冲突。</p></li><li><p>核心：集中的管理多台WEB服务器文件系统，一对多：一个文件服务器，对应多个客户端（WEB）</p></li><li><p>步骤</p><ul><li>安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line">systemctl start nfs-server</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>输出目录设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建输出目录</span><br><span class="line">mkdir /webdata</span><br><span class="line">写入要显示的网页文件</span><br><span class="line">输出目录设置</span><br><span class="line">vim /etc/exports</span><br><span class="line">/webdata   192.168.26.0/24(rw)</span><br></pre></td></tr></table></figure><ul><li>客户端挂载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line">mount -t 192.168.26.128(存储端ip地址):/webdata  /var/www/html</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维学习（四）</title>
      <link href="/2023/04/05/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/04/05/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ol><li>网卡</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置路径：/etc/sysconfig/network-script/</span><br><span class="line">NetworkManager服务：</span><br><span class="line">systemctl status NetworkManager </span><br><span class="line">systemctl status network</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令行配置：修改/etc/sysconfig/network-script/下的网卡，如ifcfg-ens33名字之类的文件，也可以用emcli命令</span><br></pre></td></tr></table></figure><ol start="3"><li>配置网络参数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network-script/ens33文件：</span><br><span class="line">ONBOOT=yes    ---开机是否启用该设备</span><br><span class="line">BOOTPROTO=none     ---ip地址手动（none/static）还是自动（dhcp）</span><br><span class="line">protocol协议分三种：dhcp（自动）、none（手动）、static（静态）</span><br><span class="line">IPADDR=ip地址</span><br><span class="line">NETMASK=掩码          ---掩码是用来定义网络的</span><br><span class="line"></span><br><span class="line">GATEWAY=             ----网关，也叫默认路由，带我们上网的路由器地址</span><br><span class="line">DNS=                ----域名解析</span><br><span class="line"></span><br><span class="line">网卡信息：</span><br><span class="line">NAME</span><br><span class="line">UUID</span><br><span class="line">DEVICE</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>主机名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hostname  ---查看主机名</span><br><span class="line">改名方式1：</span><br><span class="line">hostnamectl set-hostname  要改的名字  ---配置主机名</span><br><span class="line">改名方式2：</span><br><span class="line">cat  /etc/hostname    ---查看和配置主机名</span><br><span class="line">vim  /etc/hostname      ---改名</span><br><span class="line">reboot       ---重启生效</span><br></pre></td></tr></table></figure><ol start="5"><li>网络测试工具</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip a      ----查看所有ip</span><br><span class="line">ip route  ---查看路由，查看网关</span><br><span class="line">ip neigh    ---另一台主机ping通，查看邻居</span><br><span class="line">ss -tnl       ---查看端口号</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭selinux</span><br><span class="line">临时关闭：setenforece 0</span><br><span class="line">永久关闭：vim /etc/sysconfig/selinux     ---设置SELINUX=disabled</span><br></pre></td></tr></table></figure><hr><p>OSI开放系统互联模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开放式系统互联，定义了不同计算机互联的标准</span><br><span class="line">OSI7层次结构：全世界网络通信的工作分为7层，应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</span><br><span class="line"></span><br><span class="line">TCP/IP5层结构：应用层、传输层、网络层、数据链路层、物理层</span><br><span class="line">TCP/IP4层结构：应用层、传输层、网络层、网络接口层</span><br><span class="line"></span><br><span class="line">OSI模型和TCP/IP模型的区别：OSI推出的时间早，只有理论，没有实践。实践上现在用的都是TCP/IP结构模型，当今通信标准。</span><br></pre></td></tr></table></figure><p>TCP&#x2F;IP：数据单元&#x2F;DU</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据传输中数据会以不一样的形式呈现</span><br><span class="line">应用层数据：APDU：应用协议数据单元</span><br><span class="line">传输层数据：分段数据</span><br><span class="line">网络层数据：包数据</span><br><span class="line">数据链路层数据：帧数据</span><br><span class="line">物理层数据：比特数据</span><br><span class="line"></span><br><span class="line">数据通过网络进行传输，在发送端从高层一层层向下传送，先把数据装到一个特殊协议报头中，这个过程叫做封装。接收端会从底层一层层向上进行解封装。</span><br></pre></td></tr></table></figure><hr><p>TCP&#x2F;IP协议族</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层：http（超文本传输协议/网站）、SSH（远程连接协议/远程控制）、FTP（文件传输协议）、SMTP（简单邮件传输协议/Email）、DNS(域名服务/www)</span><br><span class="line"></span><br><span class="line">传输层：TCP（传输控制协议）、UDP（用户数据报协议）</span><br><span class="line"></span><br><span class="line">网络层：IP（互联网协议）、ICMP（网络消息管理协议）</span><br><span class="line"></span><br><span class="line">数据链路层：MAC </span><br><span class="line"></span><br><span class="line">物理层：网线、光纤</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单位换算：</span><br><span class="line">比特=bit=b=1/0</span><br><span class="line">字节=byte=B=8个比特</span><br><span class="line">1KB=1024B</span><br><span class="line">1MB=1024KB</span><br><span class="line">1GB=1024MB</span><br><span class="line">1TB=1024GB</span><br></pre></td></tr></table></figure><hr><p>物理层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">物理层</span><br><span class="line"></span><br><span class="line">信号是数字信号传递。用分立脉冲信号表示0和1</span><br><span class="line"></span><br><span class="line">传输介质：双绞线、光纤（传输光信号）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>数据链路层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数据链路层</span><br><span class="line"> MAC地址（媒体访问控制地址）</span><br><span class="line"> 数字结构：48位2进制数字，12位16进制数字</span><br><span class="line">前六位是厂商标识，后六位是硬件标识</span><br><span class="line"> 帧封装：</span><br><span class="line">  MAC地址写入到信息中</span><br><span class="line">  目标MAC-源AMC-数据（通信一定是双向的）-CRC循环冗余校验和</span><br><span class="line"></span><br><span class="line"> 交换机工作原理（switch）：</span><br><span class="line">MAC地址表（将双方通信的MAC地址记录下来，第二列记录端口号）</span><br><span class="line">VLAN（虚拟局域网）：</span><br><span class="line">划分VLAN的方法：1、创建VLAN（2~1024），2、根据接口和VLAN的关系</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">划分VLAN：</span><br><span class="line">enable         ---特权</span><br><span class="line">config t     ---进入配置模式</span><br><span class="line">vlan 10        ---创建局域网10</span><br><span class="line">vlan 20          ---创建局域网20</span><br><span class="line">interface fastethernet0/1   ---接口模式下输入</span><br><span class="line">switch access vlan 10 ---将端口加入vlan</span><br><span class="line"></span><br><span class="line">所有交换机买回来默认将接口都划分到vlan1，设置了trunk的接口不属于任何vlan</span><br><span class="line">交换机核心技术：vlan标签技术</span><br><span class="line">交换机的接口有两种模式：</span><br><span class="line">1.access访问模式某个VLAN（连接计算机用的）</span><br><span class="line">2.trunk模式承载多个VLAN（连接交换机用的）</span><br><span class="line"></span><br><span class="line">Trunk（干道）理论：在同一条线缆上，传递多个VLAN的信息，适用于多个交换机之间相同vlan之间的通信</span><br><span class="line">vlan标签只存在trunk线路，交换机之间的线路才叫trunk线路</span><br><span class="line">连接两台交换机，在连接的端口上需要配置trunk</span><br><span class="line">实验2：</span><br><span class="line">1.准备交换机1</span><br><span class="line">2.在交换机1，划分VLAN10和VLAN20.主机配置IP地址</span><br><span class="line">3.准备交换机2</span><br><span class="line">4.在交换机2，划分VLAN10和VLAN20.主机配置IP地址</span><br><span class="line">5.连接两台交换机，在连接的端口上，配置TRUNK</span><br><span class="line">6.相同VLAN的主机互通</span><br><span class="line">7.不同VLAN的主机不可通信</span><br><span class="line"></span><br><span class="line">实验步骤：</span><br><span class="line">en（enable简写）</span><br><span class="line">config t</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">int f0/1</span><br><span class="line">sw ac vlan 10</span><br><span class="line">int f0/2</span><br><span class="line">sw ac vlan 20</span><br><span class="line">在两头接口配置trunk：</span><br><span class="line">int f0/3</span><br><span class="line">switch mode trunk</span><br></pre></td></tr></table></figure><hr><p>网络层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">跨域网络通信，需要网络层，需要IP地址</span><br><span class="line">网络层的核心目的：分割广播域、便于寻址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">路由器第一要务就是分割广播域</span><br><span class="line"></span><br><span class="line">网络层：</span><br><span class="line">ip地址有32位二进制数  ip地址每八位二进制为1组，用’.‘分割，用十进制标识。</span><br><span class="line">4组十进制表示范围就是0.0.0.0~255.255.255.255</span><br><span class="line">ip地址分类为5类：</span><br><span class="line">A类（1~126）                 ---127：被作为回环地址：我</span><br><span class="line">B类（128~191）</span><br><span class="line">C类（192~223）</span><br><span class="line">D类（224~239）组播</span><br><span class="line">E类（240~255）科研</span><br><span class="line">ip地址总数43亿个</span><br><span class="line"></span><br><span class="line">私有IP（私有IP用在局域网内）分类：</span><br><span class="line">A类：10.0.0.0~10.255.255.255</span><br><span class="line">B类：172.16.0.0~172.31.255.255</span><br><span class="line">C类：192.168.0.0~192.168.255.255</span><br><span class="line"></span><br><span class="line">子网掩码：</span><br><span class="line">作用：32位2进制数字，运算出IP地址的网络部分</span><br><span class="line">分类：</span><br><span class="line">A类：255.0.0.0</span><br><span class="line">B类：255.255.0.0</span><br><span class="line">C类：255.255.255.0</span><br><span class="line"> 子网掩码：把IP和子网掩码逻辑运算，得出网络地址。</span><br><span class="line">两个IP地址是不是同一网络，依靠以下四步骤：</span><br><span class="line">1.IP地址转换2进制</span><br><span class="line">192.168.1.254</span><br><span class="line">1100 0000.1010 1000.0000 0001.1111 1110</span><br><span class="line">2.子网掩码转换2进制</span><br><span class="line">255.255.255.0</span><br><span class="line">1111 1111.1111 1111.1111 1111.0000 0000</span><br><span class="line">3.IP地址和子网掩码逻辑运算。</span><br><span class="line">1100 0000.1010 1000.0000 0001.1111 1110</span><br><span class="line">1111 1111.1111 1111.1111 1111.0000 0000</span><br><span class="line">---------------------------------------</span><br><span class="line">1100 0000.1010 1000.0000 0001.0000 0000</span><br><span class="line">4.得出网络地址（这个IP属于哪个网络）</span><br><span class="line">192.168.1.0（网络地址，代表一大片地址）</span><br><span class="line"></span><br><span class="line">如下地址，</span><br><span class="line">192.168.1.2</span><br><span class="line">192.168.1.254</span><br><span class="line">是同一网段，可以直接通信。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">192.168.1.2这个IP。</span><br><span class="line">问题1：哪个网段的：192.168.1.0网段</span><br><span class="line">      总数是256个。192.168.1.0~192.168.1.255</span><br><span class="line">      可用的IP地址是254个。因为去掉网络地址（1.0）和广播地址（1.255）</span><br><span class="line">      工程师可以分配的地址：192.168.1.1-192.168.1.254</span><br><span class="line">      经验之谈，不要配第一个地址和最后一个。</span><br><span class="line">      </span><br><span class="line">问题2：我有260个人的公司，能否用标准的C类地址？</span><br><span class="line">不能。</span><br><span class="line">解决方案：使用B类地址。</span><br><span class="line">172.16.1.1  IP地址</span><br><span class="line">255.255.0.0   子网掩码</span><br><span class="line">172.16.0.0    网络地址</span><br><span class="line">172.16.0.0~172.16.255.255   网络范围</span><br><span class="line">B类地址主机位有16位，可以分配2的16次方个主机</span><br><span class="line"></span><br><span class="line">问题3：超过6万人的局域网，使用什么类型的地址呢？</span><br><span class="line">解决方案：使用A类地址。</span><br><span class="line">A类地址主机位有24位。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小结：私有IP地址是由路由器生成的，用于识别。</span><br></pre></td></tr></table></figure><p>包封装</p><ul><li>网络层封装<ul><li>20字节160位</li><li>32位版本号。首部长度，检验和，标识标志偏移量，TTL，协议类型，可选项。</li><li>网络层封装时会携带2个ip，目的ip和源ip</li><li>如果计算发现，访问的地址是其他网段，会把这个数据包丢给网关（路由器）。</li></ul></li></ul><p>路由器</p><ul><li><p>两个不同网段之间实现通信中间必须要有路由器</p></li><li><p>路由器分割网络，连接不同的网络，需要寻址。</p></li><li><p>路由</p><ul><li>跨越从源主机到目标主机的一个互联网络来转发数据包的过程</li></ul></li><li><p>路由器工作原理</p><ul><li><p>路由器的每个接口处于不同的网段</p></li><li><p>网关一定要是同一网段的</p></li><li><p>路由器之间的连接接口要设置同一网段</p></li><li><p>路由表</p><ul><li><p>路由表记网段地址，记自身接口</p></li><li><p>路由表是路由器中维护的路由条目的集合。</p></li><li><p>路由表的形成</p><ul><li>直连网段</li></ul><p>​      自动配置IP地址，自动将这个接口的网段添加到路由表</p><ul><li><p>非直连网段</p><p>对于非直连网段，需要静态路由或动态路由，将网段添加到路由表</p></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维学习（三）</title>
      <link href="/2023/03/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/03/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="查找和压缩"><a href="#查找和压缩" class="headerlink" title="查找和压缩"></a>查找和压缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">which      ----命令查找</span><br><span class="line">find       ----文件查找，针对文件名</span><br><span class="line">locate     ----文件查找，依赖数据库</span><br><span class="line">查找ls命令的位置</span><br><span class="line">which ls或whereis vim</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">按文件名</span><br><span class="line">find   /etc  -name  &#x27;文件名&#x27;</span><br><span class="line">find   /etc  -iname  &#x27;文件名&#x27;</span><br><span class="line"></span><br><span class="line">按文件大小</span><br><span class="line">find   /etc  -size   +5M           ----查找文件大小大于5M的</span><br><span class="line">find   /etc  -size   5M             ----查找文件大小等于5M的</span><br><span class="line">find   /etc  -size   -5M            ----查找文件大小小于5M的</span><br><span class="line"></span><br><span class="line">按指定查找目录深度查找</span><br><span class="line">find / -maxdepth 4 -a -name ifcfg-en*    ---查找文件在第4级的，名字叫ifcg-en..的文件</span><br><span class="line"></span><br><span class="line">按属组</span><br><span class="line">find /home/  -group  jack      ---查找属组为jack的文件</span><br><span class="line">find /home/  -user  jack----查找属主为jack的文件</span><br><span class="line"></span><br><span class="line">按文件类型</span><br><span class="line">find /tmp  -type f</span><br><span class="line">find /tmp -type d</span><br><span class="line">find /tmp -type b         ----搜索块文件</span><br><span class="line"></span><br><span class="line">按文件权限</span><br><span class="line">find  ./  -perm  644 -ls        ----带文件类型显示文件，-ls是find的动作之一，精准权限</span><br><span class="line">find默认print动作，也就是find  ./  -perm  644 -print</span><br><span class="line"></span><br><span class="line">先找到文件后复制</span><br><span class="line">find /etc/ -name ifclg*  -ok cp -rvf &#123;&#125;   /tmp  \;</span><br><span class="line">ok是引用符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语法：find 【path】【option】【expression】【action】</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="打包tar"><a href="#打包tar" class="headerlink" title="打包tar"></a>打包tar</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -cf   etc.tar   /etc ----未压缩，只是打包</span><br><span class="line">tar -cf  打包文件名  要打包的文件或目录  </span><br><span class="line">tar -czf   etc.gzip.tar.gz   /etc ----压缩成.gip文件</span><br><span class="line">tar -czf 打包文件名  要打包的文件或目录 加z压的更小</span><br><span class="line"></span><br><span class="line">wc -l 统计命令</span><br></pre></td></tr></table></figure><p>解压tar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xf  要解压的文件名          --解压 -xf 要解压文件要带f</span><br><span class="line"></span><br><span class="line">tar -xf  要解压的文件名  -C  解压后放的目录  ---指定存放解压文件的目录</span><br></pre></td></tr></table></figure><hr><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><ol><li>RPM包管理</li></ol><blockquote><p>RPM包是由Red HAt公司提出，被众多Linux发行版使用</p><p>也称二进制，无需编译，可以直接使用</p><p>无法设定个人设置，开关功能</p><p>软件包后缀为.rpm</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPM包是二进制，无需编译，直接使用，但是无法设定个人设置，开关功能</span><br><span class="line">源码需要GCC，C++编译环境编译才能运行，可以设定个人设置</span><br></pre></td></tr></table></figure><ul><li>yum工具</li></ul><blockquote><p>是一个在Fedora和RedHat以及CentOS中的SHell前端软件包管理器<br>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装<br>可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐一次次安装。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1. yum本地源：系统安装光盘，目的是通知linux服务器，通过本机的系统光盘获取软件包，并安装软件。所以第一步需要换源，</span><br><span class="line">yum核心配置目录：/etc/yum.repos.d</span><br><span class="line">repo中文是报告</span><br><span class="line">这里目录下的文件都是.repo后缀</span><br><span class="line">    编写本地yum库配置文件</span><br><span class="line">    [文件名]</span><br><span class="line">    name</span><br><span class="line">    baseurl</span><br><span class="line">    gpgcheck</span><br><span class="line">   【dvd】某一个库的名称，中括号【】是必须的</span><br><span class="line">    name=dvd是库的说明，name是必须的</span><br><span class="line">    baseurl=file:///mnt/cdrom下载库的具体地址</span><br><span class="line">    gpgcheck=0是关闭校验</span><br><span class="line"></span><br><span class="line">cdrom是光盘、光驱的意思，里面有自带的压缩rpm包，可以选择一个路径挂载到/dev/cdrom，然后在dvd.repo的baseurl选择挂载点作为下载地址</span><br><span class="line">当然，仅仅用mount挂载是不行的，要对其进行永久挂载。</span><br><span class="line">可以通过/root/.bashrc文件进行永久挂载。因为/root/.bashrc文件是开机启动项。可以将挂载命令直接写在这个文件里，开机自动挂载。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">2. 使用yum管理RPM包</span><br><span class="line">yum install -y 软件名  ----安装软件命令，参数y是yes的意思，可以自动回复是否安装。</span><br><span class="line">yum reinstall -y 软件名 ----当软件缺失文件时，可尝试重新安装。</span><br><span class="line">yum update -y 软件名   ----升级安装</span><br><span class="line">yum update -y        ----升级系统</span><br><span class="line">yum list 软件名      ----搜索已安装的软件包，第三列带@就是已安装的意思</span><br><span class="line">yum remove -y 软件名  ----卸载软件包</span><br><span class="line">systemctl start 软件名  ----启动软件</span><br><span class="line">systemctl stop firewalld  ----关闭防火墙</span><br><span class="line">systemctl  disable  firewalld  ----禁用防火墙开机自启</span><br><span class="line"></span><br><span class="line">yum makecache  ----更新yum仓库</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>rpm工具</li></ul><blockquote><p>自带的，但不太好用，是rpm包管理工具，它无法处理依赖</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 安装</span><br><span class="line"> rpm  -ivh 包名.rpm    ----安装，参数i是安装，v是可视，h是百分比</span><br><span class="line"> rpm -q  包名    ----查询是否安装成功，参数q是询问</span><br><span class="line"> rpm -evh  包名    ----卸载，参数e是卸载</span><br></pre></td></tr></table></figure><ol start="2"><li>源码包管理</li></ol><ul><li>下载tengine</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://tengine.taobao.org/download/tengine-2.3.0.tar.gz</span><br></pre></td></tr></table></figure><ul><li>配置tengine</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure  --user=www --group=www  --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure><ul><li>编译及安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编译：make</span><br><span class="line">安装：make install</span><br><span class="line">报错的话是编译环境出问题</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><hr><h3 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h3><h4 id="一次性调度执行at（了解）"><a href="#一次性调度执行at（了解）" class="headerlink" title="一次性调度执行at（了解）"></a>一次性调度执行at（了解）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法格式：at&lt;timespec&gt;</span><br><span class="line">如：at now +2min    ----在两分钟后执行以下输入的命令</span><br><span class="line">atq         ----查询未执行的命令</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环调度执行cron"><a href="#循环调度执行cron" class="headerlink" title="循环调度执行cron"></a>循环调度执行cron</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cron的概念和crontab是不可分割的</span><br><span class="line">crontab是一个命令</span><br><span class="line">用于设置周期性被执行的指令</span><br><span class="line">该命令从标准输入设备读取指令，并被其存放于crontab文件中，以供以后调度和执行</span><br><span class="line">----查看进程状态</span><br><span class="line">systemctl status crond.service   </span><br><span class="line">ps aux | grep crond          </span><br><span class="line">crond程序运行是计划任务执行的根本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建计划：crontab -e </span><br><span class="line">查询计划：crontab -l</span><br><span class="line">管理员可以使用-u username，去管理其他用户的计划任务</span><br><span class="line">删除计划：crontab -r</span><br><span class="line"></span><br><span class="line">语法格式：</span><br><span class="line">* * * * * command</span><br><span class="line">五颗*代表分时日月周</span><br><span class="line">例如：</span><br><span class="line">*/5 * * * * /usr/bin/ls /tmp</span><br><span class="line">每隔5分钟查一次tmp目录，以邮件的方式将结果返回</span><br><span class="line">0 2 1，4，6 * *  /usr/bin/ls </span><br><span class="line">0 * * * *表示每月每周每日每小时的0点执行</span><br><span class="line">0 2 14 * *表示每月14号的2点整执行</span><br><span class="line">月周都写的话，两者都运行。</span><br></pre></td></tr></table></figure><hr><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><h4 id="日志进程rsyslog"><a href="#日志进程rsyslog" class="headerlink" title="日志进程rsyslog"></a>日志进程rsyslog</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/var/log/messages ----系统主日志文件</span><br><span class="line">tail -f /var/log/messages  ----动态查看日志文件的尾部</span><br><span class="line">常见的日志文件：均在/var/log/目录下</span><br><span class="line">secure  ---安全</span><br><span class="line">yum.log  ---yum</span><br><span class="line">maillog   ---跟邮件postfix相关</span><br><span class="line">cron          ---跟crond 、at进程产生的日志</span><br><span class="line">dmesg    ---和系统启动相关</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rsyslogd：系统专职日志程序，处理绝大部分日志记录</span><br><span class="line">rsyslogd配置</span><br><span class="line">yum install rsyslog  logrotate  ---有问题可以重装</span><br><span class="line">systemtcl start rsyslog.service  ---启动程序</span><br><span class="line"></span><br><span class="line"> rpm -qc rsyslog ---查询相关程序：/etc/rsyslog.conf  ---主配置文件</span><br><span class="line">   /etc/sysconfig/rsyslog</span><br><span class="line">   /etc/logrotate.d/syslog</span><br><span class="line"> 主配置文件一般有共同特征：在/etc/目录下，程序名+.conf后缀。</span><br><span class="line"> /etc/rsyslog.conf告诉rsyslogd进程什么日志，应该存到哪里。</span><br><span class="line"> 日志记录问题级别：emerg、error、info、debug，配置文件里的.*代表的任何级别，所有问题都记录下来的意思</span><br></pre></td></tr></table></figure><p>日志轮转logrotate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主文件：/etc/logrotae.conf</span><br><span class="line">子文件夹：/etc/logrotate.d/*</span><br><span class="line">（带.d的是子配置文件）</span><br><span class="line">工作原理：按配置进行轮转</span><br><span class="line"></span><br><span class="line">主配置文件是程序启动必须运行的文件</span><br></pre></td></tr></table></figure><blockquote><p>总结：日志一般是由rsyslog这个程序产生的</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维学习--二</title>
      <link href="/2023/03/22/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/22/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>进程是已启动的可执行程序的运行实例，进程有以下组成部分：</p><ul><li><p>一个文件</p></li><li><p>被配内存的地址空间</p></li><li><p>有权限限制</p></li><li><p>程序代码的一个或多个副本（也叫执行线程）</p></li><li><p>像人一样拥有状态</p></li><li><p>查看资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps aux    静态查看进程ps</span><br><span class="line">里面的状态STAT有sleeping（S）、running（R）、zombie（非正常结束进程Z）、stopped（T），状态后有+代表优先级较高</span><br><span class="line">PID是进程ID</span><br><span class="line">%CPU cpu占用率</span><br><span class="line">%MEM:内存占用率</span><br><span class="line">VSZ：占用虚拟内存</span><br><span class="line">RSS：占用实际内存</span><br><span class="line">TTY：进程运行的终端</span><br><span class="line">TIME：进程占用CPU的总时间</span><br><span class="line">COMMAND：进程文件，进程名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef      查看进程的父子关系，观察PID和PPID</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top        动态查看进程top</span><br></pre></td></tr></table></figure></li><li><p>信号控制进程</p><p>9）SIGKILL  强制退出，无条件</p><p>15）正常退出。</p></li><li><p>进程优先级nice</p><p>在top中显示的优先级有两个，PR值和nice值</p><p>nice的范围在-20~+19，有40个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看系统的优先级</span><br><span class="line">ps axo pid，command，nice --sort=-nice</span><br><span class="line">赋予优先级</span><br><span class="line">nice -n 优先值</span><br><span class="line">修改nice值</span><br><span class="line">renice nice值 pid</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep --倒计时程序，让系统睡眠一段时间，没什么意义</span><br></pre></td></tr></table></figure></li><li><p>作业控制jobs（了解）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;命令（重点）。是把放在后台运行，不占用终端。当然，通过ps仍然看得见</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jobs命令。查看后台运行程序。</span><br><span class="line">fg 进程序号    将进程放回前台终端</span><br><span class="line">bg 进程序号    将进程重新运行起来</span><br></pre></td></tr></table></figure><p>kill命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill 1  与  kill  %1区别</span><br><span class="line">kill 1 是杀死前台进程程序</span><br><span class="line">kill %1是杀死后台进程程序</span><br></pre></td></tr></table></figure></li><li><p>虚拟文件系统（了解）</p><p>&#x2F;proc&#x2F;，虚拟文件系统：采集服务器自身内核、进程运行的状态信息</p><p>cpu：&#x2F;proc&#x2F;cpuinfo里面放在cpu的硬件各种信息</p><p>内存：&#x2F;proc&#x2F;meminfo 里面放着内存的各种信息</p><p>内核：&#x2F;proc&#x2F;cmdline 里面放着内核信息</p></li></ul><hr><h4 id="管道和重定向"><a href="#管道和重定向" class="headerlink" title="管道和重定向"></a>管道和重定向</h4><ol><li><p>输出重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   正确输出：</span><br><span class="line">   &gt;:将左边的东西定向到右边，会覆盖原来的内容。1&gt;等价于&gt;</span><br><span class="line">   &gt;&gt;:追加内容。1&gt;&gt;等价于&gt;&gt;</span><br><span class="line">   错误输出：</span><br><span class="line">   2&gt; </span><br><span class="line">   2&gt;&gt;</span><br><span class="line">   加了&gt;等于调用了FD文件</span><br><span class="line">   FD(file descriptors)文件描述符，进程使用文件描述符来管理打开的文件，每个文件都有fd，为了省去冗长的绝对路径</span><br><span class="line">   0 标准输入</span><br><span class="line">1 标准输出</span><br><span class="line">   2 标准错误输出</span><br><span class="line">   3+普通文件</span><br><span class="line">   要想将错误正确信息均将其输入到文件内可用：</span><br><span class="line">   &amp;&gt;符号</span><br><span class="line">   如果不想看输出错误和正确结果可以将其丢入垃圾桶/dev/null</span><br></pre></td></tr></table></figure></li><li><p>输入重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt;  文件</span><br><span class="line">以文本内容，作为进程的标准输入，通常在编程中使用。</span><br><span class="line">主要用于将文件的内容一次性输入到一些命令，如发邮件案例，可以创建一个邮件格式模板，然后一次性发放到其他人手中。</span><br></pre></td></tr></table></figure></li><li><p>管道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">管道命令可以将多条命令组合起来，一次性完成复杂的处理任务</span><br><span class="line">命令1的输出，作为命令2的输入，命令2的输出作为命令3的输入</span><br><span class="line">|</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>tee管道</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tee命令</span><br><span class="line">三通，把输出保留副本·如：</span><br><span class="line">cat /etc/passwd | tee 1.txt</span><br></pre></td></tr></table></figure><ul><li><p>参数传递xargs</p><p>把输入和输出进行格式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp、rm是不服从管道命令的。</span><br><span class="line">在一个1.txt文件中写入/home/file1</span><br><span class="line">                   /home/file2</span><br><span class="line">                   /home/file3</span><br><span class="line"> 如果直接输入命令：cat 1.txt | rm -rvf，当然删不了/home/下的文件，因为两者性质不同，一个是文件，一个是文本内容。</span><br><span class="line"> 可以用以下命令：</span><br><span class="line"> cat 1.txt | xargs rm -rvf，就可以删除/home/下的文件，当然1.txt中的文本内容还在。</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><h4 id="1-基本分区"><a href="#1-基本分区" class="headerlink" title="1.基本分区"></a>1.基本分区</h4><p><code>磁盘、硬盘、disk是同一个东西。</code></p><ul><li><p>命名：SATA(串口)：&#x2F;dev&#x2F;sda，&#x2F;dev&#x2F;sdb</p><ul><li><p>&#x2F;dev&#x2F;sda:&#x2F;dev设备文件目录</p><pre><code>            sda是一个文件</code></pre><p>​s代表sata就是串口</p><p>​d代表磁盘</p><p>​a第一块</p></li><li><p>&#x2F;dev&#x2F;sdb:第二块硬盘名字</p></li></ul></li><li><p>硬盘的分区方式</p><ul><li><p>MBR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MBR有64字节大小,64字节又划分4个部分，所以有四个主分区</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ul><p>默认分为4个主分区</p><pre><code> 为了多几个分区，MBR有了扩展分区的概念。 扩展分区:扩展分区一般是放弃最后一个主分区作为扩展分区。当然扩展分区是不放数据的，想放东西、文件必须要放在逻辑分区。 当然，扩展分区也不用挂载  逻辑分区：逻辑分区是扩展分区划分出来的，想划分多少都可以  只能管理&lt;2T的硬盘</code></pre></li></ul><p>​<br>​       一块硬盘<br>​       使用MBR，划分分区。数量上只能由如下选择：<br>​       1、4主<br>​       2、3主+1扩展（N个逻辑）<br>​       ~~~</p><p>​<br>​<br>​     + GPT</p><h4 id="2-管理硬盘三部曲"><a href="#2-管理硬盘三部曲" class="headerlink" title="2.管理硬盘三部曲"></a>2.管理硬盘三部曲</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分区（MBR或GPT）--&gt;格式化/文件系统Filesystem--&gt;挂载mount</span><br></pre></td></tr></table></figure>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll   /dev/sd*  查看系统有几块硬盘</span><br></pre></td></tr></table></figure><p>   <img src="%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0--%E4%BA%8C%5Cimage-20230325220749609.png" alt="image-20230325220749609"></p><p>   图中brw中b开头的是block的缩写，其中&#x2F;dev&#x2F;sda、&#x2F;dev&#x2F;sda1、&#x2F;dev&#x2F;sda2是一块硬盘</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk命令能看块设备，可以查看硬盘</span><br></pre></td></tr></table></figure><ol><li>创建分区</li></ol><ul><li><p>启动分区工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk  硬盘路径（/dev/sdb或/dev/sdc)</span><br></pre></td></tr></table></figure><ul><li>操作</li></ul></li></ul><p>   <img src="%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0--%E4%BA%8C%5Cimage-20230325222559152.png" alt="image-20230325222559152"></p><ul><li>刷新分区表</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partprobe /dev/sdb</span><br></pre></td></tr></table></figure><ul><li>查看磁盘信息</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sdb或者lsblk命令查看</span><br></pre></td></tr></table></figure><ol start="2"><li>创建文件系统(格式化)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4  /dev/sdb1</span><br></pre></td></tr></table></figure><ol start="3"><li>创建挂载点，一个分区一个挂载点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/disk1</span><br><span class="line">mount -t ext4   /dev/sdb1   /mnt/disk1</span><br><span class="line">当然，mount这种挂载方式是临时的。</span><br></pre></td></tr></table></figure><ol start="4"><li><p>查看挂载信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -hT或者mount命令</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-逻辑卷"><a href="#3-逻辑卷" class="headerlink" title="3. 逻辑卷"></a>3. 逻辑卷</h4><p><code>物理磁盘的空间是固定的，单靠物理磁盘，是解决不了空间增长的问题的</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">逻辑卷LVM的目的：管理磁盘的一种方式，性质与基本磁盘无异。</span><br><span class="line"></span><br><span class="line">特点：随意扩张大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">逻辑卷管理方式：</span><br><span class="line">1.买物理盘</span><br><span class="line">2.变成物理卷</span><br><span class="line">3.加入卷组</span><br><span class="line">4.在卷组中，抽调空间，制作逻辑卷</span><br><span class="line">5.格式化</span><br><span class="line">6.挂载</span><br><span class="line"></span><br><span class="line">基本磁盘管理：</span><br><span class="line">1.买物理盘，分区</span><br><span class="line">2.格式化</span><br><span class="line">3.挂载</span><br><span class="line">-------------</span><br><span class="line">逻辑卷管理方式比基本磁盘管理方式就多了三步。</span><br></pre></td></tr></table></figure><hr><p>术语：</p><p>PV：物理卷（physical volume）</p><p>VG：卷组(volume Group)</p><p>LV：逻辑卷(Logical Volume)</p><hr><h5 id="创建LVM"><a href="#创建LVM" class="headerlink" title="创建LVM"></a>创建LVM</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. pv:pvcreate /dev/磁盘名字   ---创建物理卷</span><br><span class="line">2. vg：vgcreate  卷组名字  /dev/磁盘名字   ---创建卷组</span><br><span class="line">3. lv：lvcreate -L 大小  -n 卷名  组名     ---创建逻辑卷</span><br><span class="line">4. mkfs.ext4  /dev/vg1/lv1  ---格式化</span><br><span class="line">注意：/dev/卷组名/逻辑卷名</span><br><span class="line">5. mount /dev/vg1/lv1  /mnt/lv1</span><br></pre></td></tr></table></figure><hr><h5 id="VG扩容"><a href="#VG扩容" class="headerlink" title="VG扩容"></a>VG扩容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. pvcreate /dev/磁盘名字   ---创建PV</span><br><span class="line">2. vgextend 卷组名字 /dev/磁盘名字  ---扩展卷组</span><br><span class="line">额外命令：</span><br><span class="line">pvs  ---查看物理卷</span><br><span class="line">vgs  ---查看卷组信息</span><br></pre></td></tr></table></figure><hr><h5 id="LV扩容"><a href="#LV扩容" class="headerlink" title="LV扩容"></a>LV扩容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. vgs        ---查看VG空间，观察VG是否有剩余空间</span><br><span class="line">2. lvextend -Ｌ　扩容大小　/dev/卷组名/逻辑卷名    ---逻辑卷扩容</span><br><span class="line">3. resize2fs /dev/卷组名/逻辑卷名     ---重置文件系统</span><br></pre></td></tr></table></figure><hr><h4 id="4-交换分区管理Swap"><a href="#4-交换分区管理Swap" class="headerlink" title="4.交换分区管理Swap"></a>4.交换分区管理Swap</h4><ul><li>作用：‘提升’内存的容量，防止OOM（Out Of Memory）</li><li>硬盘上的一个分区</li><li>设置交换分区大小一般为内存的2倍</li></ul><p>如何设置交换分区swap？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">准备将/dev/sdc硬盘，划分为1G分区为例</span><br><span class="line">划分分区后，将类型设置为82(也可以不改)</span><br><span class="line"></span><br><span class="line">格式化：mkswap  /dev/sdc1</span><br><span class="line"></span><br><span class="line">交换分区的挂载:swapon /dev/sdc1</span><br><span class="line">取消挂载：swapoff  /dev/sdc2</span><br><span class="line"></span><br><span class="line">验证/查看结果：free -m</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">卸载挂载：umount /dev/sdb5(卸载挂载只是把挂载目录取消了，重新挂载之后，文件依然还在。相当于把u盘拔了)</span><br></pre></td></tr></table></figure><hr><p>小总结：</p><p>1.LVM磁盘管理是为了更方便的扩容磁盘大小，毕竟物理磁盘大小是固定的。</p><p>LVM磁盘管理可以帮助我们把多个物理磁盘变为一个整体，变相的扩容。</p><p>2.基本磁盘管理无非是三步：先要有物理磁盘，然后分区，格式化，挂载。</p><p>3.sda这个硬盘并不能格式化，这个硬盘是系统启动盘，如果格式化，那可能系统就崩溃了。</p><p>4.先要卷组里有空间才可以对逻辑卷进行扩容。</p><p>5.嗯，，当把一个硬盘变为物理卷之后，这个盘就变相“不存在”了，df -hT查看的时候，只能看到&#x2F;dev&#x2F;卷组&#x2F;逻辑卷这个盘名(文件)。</p><hr><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>window：FAT16、FAT32、NTFS</p><p>Liunx：EXT3、EXT4、XFS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">索引文件系统</span><br><span class="line">系统限制：EXT3-&gt;文件系统最大16TB</span><br><span class="line">EXT4-&gt;文件系统最大16TB</span><br><span class="line">XFS：文件系统最大100TB</span><br><span class="line"></span><br><span class="line">inode：记录文件的属性（文件的元数据metadata）</span><br><span class="line">   一个文件占用一个inode，同时记录此文件数据所在的block number</span><br><span class="line">   inode大小为128bytes</span><br><span class="line"></span><br><span class="line">block：存储文件的实际数据</span><br><span class="line">  实际存储文件的内容，若文件较大，会占用多个block。</span><br><span class="line">  block大小默认为4k</span><br><span class="line"></span><br><span class="line">superblock：block与inode的总量</span><br><span class="line">   未使用与已使用的inode/block数量</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>inode决定了文件系统中文件的数量</p><p>block决定了存储空间。</p></blockquote><hr><h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><ul><li>创建软链接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令：ln -s 文件绝对路径  文件被链接的路径</span><br><span class="line">软连接记录的只是源文件的绝对路径</span><br><span class="line">软连接失去源文件不可用</span><br><span class="line">软连接源文件没了，会对链接文件产生影响</span><br></pre></td></tr></table></figure><h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><ul><li>创建硬链接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令：ln 文件绝对路径  文件被链接的路径</span><br><span class="line">硬链接只能针对文件做，不能对目录做</span><br><span class="line">硬链接只能在同分区做</span><br><span class="line">硬链接相当于做了一个备份，删除原文件对被链接的文件没有影响</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="RAID（了解）"><a href="#RAID（了解）" class="headerlink" title="RAID（了解）"></a>RAID（了解）</h5><p>RAID是廉价磁盘冗余陈列，作用是容错、提升对写速率</p><p>类型</p><ul><li>RAID0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAID0条带集2块磁盘以上，读写速率快100%*N，但不容错。</span><br></pre></td></tr></table></figure><ul><li>RAID1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAID1俗称镜像集 2块硬盘，核心是容错</span><br></pre></td></tr></table></figure><ul><li>RAID5</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要相同容量的硬盘，核心是可靠、高速</span><br><span class="line">RAID5带奇偶校验条集  3块磁盘以上</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>根据devstack安装openstack</title>
      <link href="/2023/03/17/%E6%A0%B9%E6%8D%AEdevstack%E5%AE%89%E8%A3%85openstack/"/>
      <url>/2023/03/17/%E6%A0%B9%E6%8D%AEdevstack%E5%AE%89%E8%A3%85openstack/</url>
      
        <content type="html"><![CDATA[<h3 id="配置阿里镜像"><a href="#配置阿里镜像" class="headerlink" title="配置阿里镜像"></a>配置阿里镜像</h3><ol><li>安装wget工具</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><p><img src="image-20230317103756922.png" alt="image-20230317103756922"></p><ol start="2"><li><p>备份CentOS 7系统自带yum源配置文件&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure></li><li><p>下载新的 CentOS-Base.repo 到 &#x2F;etc&#x2F;yum.repos.d&#x2F;</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p><img src="image-20230317104939390.png" alt="image-20230317104939390"></p><ol start="4"><li><p>清理缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><p><img src="image-20230317110202491.png" alt="image-20230317110202491"></p></li><li><p>生成缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><img src="image-20230317110828899.png" alt="image-20230317110828899"></p></li></ol><p>非阿里云ECS用户会出现 ’Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’信息，不影响使用，可以修改配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e &#x27;/mirrors.cloud.aliyuncs.com/d&#x27; -e &#x27;/mirrors.aliyuncs.com/d&#x27; /etc/yum.repos.d/CentOS-Base.repo </span><br></pre></td></tr></table></figure><ol start="6"><li><p>验证是否更换源成功</p><p><img src="image-20230317115506233.png" alt="image-20230317115506233"></p></li></ol><blockquote><p>有aliyun的网址出来，说明更换源成功</p></blockquote><ol start="7"><li><p>下载git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></li><li><p>下载devstack</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/openstack-dev/devstack.git  /home/devstack</span><br></pre></td></tr></table></figure></li><li><p>创建 Stack 用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/devstack/tools/</span><br><span class="line">./create-stack-user.sh</span><br></pre></td></tr></table></figure><p>运行<code>./create-stack-user.sh</code>出现错误。尝试更新python为python3.升级这步是必须的</p></li></ol><p>如果更新python后运行yum install命令出现</p><p><img src="image-20230317133722131.png" alt="image-20230317133722131"></p><p>解决方法如下：</p><p><img src="image-20230317133554170.png" alt="image-20230317133554170"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运维学习笔记</title>
      <link href="/2023/03/14/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/03/14/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p>普通ip，分为两段</p><hr><p>网络地址+主机地址</p><p>如192.168.0.135</p><p>192.168.0这部分叫做局域网段</p><p>135叫做主机地址</p><hr><p>每一个机器，会有三种ip形式</p><ul><li>127.0.0.1 回环地址（特殊ip，系统自带）做服务器测试使用的</li><li>0.0.0.0</li><li>网卡地址（用户自己分配的ip）</li></ul><hr><p>特殊ip：0.0.0.0（系统自带，会绑定所有的网卡） 作用：当程序部署在这个地址上，即表示，绑定机器所有的网卡，包括127.0.0.1以及其他的ip</p><hr><p>想让程序让其他人访问到，必须要绑定网卡</p><p>非网卡的绑定就访问不了，比如127.0.0.1</p><ul><li><p>ip地址是会变的。</p></li><li><p>任何连上互联网的电脑都可以通过一个公共ip访问到</p></li></ul><p>公网ip：所有人都可以访问的</p><p>内网ip：</p><p>内网：一般情况下，内网就是指的局域网（LAN），公网就是指的广域网（WAN）</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>域名的作用就是绑定难以记住的ip地址，让用户好记。</p><p>DNS就是域名映射系统</p><p>CDN服务器加速–让访问者可以就近访问到服务器</p><hr><p>路由器–网络地址映射–NAT（网络地址转换）</p><p>局域网–&gt;公网</p><hr><p>NAT可以让虚拟机也可以上外网，NAT是一个地址映射表，作用呢，就是比桥接可以分配更多的局域网ip，桥接是和宿主用的同一个ip，而使用NAT创建的虚拟机使用的是宿主机又分配的ip地址，其他电脑是访问不了这个虚拟机的。</p><hr><p>浏览器直接访问taobao.com与<a href="http://www.taobao.com的区别/">www.taobao.com的区别</a></p><blockquote><p>这个是运维配置的域名重写机制，淘宝服务器自动判断，用户只要访问的是taobao.com</p><p>自动url重写机制，nginx部署的功能</p></blockquote><p>域名是从右往左读。</p><p>顶级域名用于告诉用户该域名提供的服务类型</p><p>顶级域名就是最后一个小数点.结尾的字母，如.net,.com</p><p>用户花钱买的域名就叫二级域名</p><hr><p>域名可以是在公网中解析到的</p><p>也可以是企业内部自己用的</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口就是ip:port 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">80端口是和443绑定在一起的。80是http端口,443是https端口</span><br><span class="line">https://wwww.taobao.com:443</span><br><span class="line">停止443端口，即表示停止端口服务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断网站是否存活</span><br><span class="line">1.看他的ip是否存活。ping一下</span><br><span class="line">2.判断出是它的端口挂了</span><br></pre></td></tr></table></figure><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><ul><li>&#x2F;boot，启动分区，系统的引导启动程序，必须放在这里</li></ul><h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><p>window不区分大小写，linux是严格区分大小写的</p><p>linux是不关心后缀的，linux的文件属性是依靠权限位决定的，和文件名无关。</p><p>linux的文件名就是个普通的字符串而已，一堆英文字母</p><p>看到权限位中第一个是-，就是文件，如果是d开头的，就是目录</p><p>压缩文件也是普通文件显示</p><ul><li>echo显示一段话或者输出一段字符串</li><li>touch    创建文件</li></ul><p>linux上一切皆文件</p><ul><li>systemctl linux服务管理命令 status 状态  network 网络</li><li>&#x2F;是linux的根目录</li><li>sda是linux上的第一块硬盘</li></ul><p>linux是否是可执行文件是通过文件属性决定的</p><p>linux上硬盘想要用有3步：</p><ol><li>有物理磁盘，分区</li><li>在linux上有一个目录，和这个分区绑定</li><li>访问这个目录，即访问了这个磁盘的数据</li></ol><h4 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h4><p>一进来的目录就是&#x2F;root，可以用pwd命令显示当前目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux以单根的方式组织文件/</span><br><span class="line">windows：以多根的方式组织文件,如C:\D:\</span><br></pre></td></tr></table></figure><p><img src="image-20230314141456806.png" alt="image-20230314141456806"></p><ol><li><p>&#x2F;bin</p><blockquote><p>是Binary的缩写，这个目录存放着最经常使用的命令，这个文件是个链接，实际是指向usr&#x2F;bin</p></blockquote></li><li><p>sbin</p><blockquote><p>跟bin类似，也是放着系统命令，只有超级用户才可以执行</p></blockquote></li><li><p>lib</p><blockquote><p>等同于windows的system32文件夹，放着一些函数库</p></blockquote></li><li><p>lib64</p><blockquote><p>与lib差不多</p></blockquote></li><li><p>&#x2F;boot</p><blockquote><p>引导启动的一些文件，如内核文件和启动引导程序（grub），很少动</p></blockquote></li><li><p>&#x2F;dev</p><blockquote><p>存放系统的硬件设备文件</p></blockquote></li><li><p>etc</p><blockquote><p>放置系统的配置文件，经常用，采用默认安装方式（rpm安装）的配置文件都在这</p></blockquote></li><li><p>root</p><blockquote><p>除了有root管理员权限的才能进入。别人进不去</p></blockquote></li><li><p>home</p><blockquote><p>存放每个用户的文件</p></blockquote></li><li><p>tmp</p><blockquote><p>放临时文件的文件夹</p></blockquote></li><li><p>usr</p><blockquote><p>安装软件的路径</p></blockquote></li><li><p>var</p><blockquote><p>跟tmp类似，里面有个&#x2F;var&#x2F;log，放了日志文件</p></blockquote></li><li><p>mnt</p><blockquote><p>挂载硬盘时的挂载点</p></blockquote></li><li><p>opt</p><blockquote><p>&#x2F;opt 目录用来安装附加软件包，是用户级的程序目录，可以理解为 D:&#x2F;Software。</p></blockquote></li></ol><p>centos7默认用xfs文件系统</p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><blockquote><p>前面是-的，为文件</p><p>前面为d（directory的缩写）的，是目录</p></blockquote><h5 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h5><p>格式：命令    [选项]     参数</p><ul><li><p>ls -l        以列表形式显示文件的详细信息</p><ul><li>ls  -a        把隐藏文件也显示出来</li></ul></li><li><p>pwd           打印当前路径</p></li><li><p>touch         创建文件</p></li><li><p>mkdir         创建目录</p><blockquote><p>参数有 -p,父系，当创建目录没有上一级时，自动创建</p><ul><li>-v,每次创建新目录都显示信息</li></ul></blockquote></li><li><p>cp    源文件路径       目标文件夹         用于复制文件</p><blockquote><p>参数-r,  用于把一个包含很多文件的文件夹复制到目标路径下</p><ul><li>mv  源文件路径       目标文件路径         用于移动文件也可以用来改名</li></ul></blockquote></li><li><p>rm  -rf         删除文件</p></li></ul><blockquote><p>参数-rf是强制删除，慎用！！！</p><p>要删除指定的多个有共性的文件可以用通配符删除</p></blockquote><ul><li>cat             查看文件内容</li><li>head     -数字        查看文件前几行内容</li><li>more          有翻页功能，查看的文件内容不多的话和cat功能一样</li><li>tail        -数字        查看文件后几行内容</li><li>grep    要查看的关键字   要查看的文件 ，      用于搜索关键字</li><li>su    -   用户名          切换用户命令，加-为了提权</li><li>tty        查看当前终端名字</li></ul><h5 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h5><ul><li><p>重定向</p><blockquote><p>用&gt;进行重定向</p></blockquote></li><li><p>文件编辑器1</p><blockquote><p>图形文件编辑器 gedit，给文件写东西</p></blockquote></li><li><p>文件编辑器2</p><blockquote><p>vi、vim。推荐用vim，有高亮功能，按yy之后按p表示复制粘贴，按dd表示删除，3yy表示复制3行，按u表示撤销</p><p>按v进入可视化模式，可以进行选取</p><p>gg  G  用于页首页尾 ， 3G进入第三行</p><p>&#x2F;后面可以接需要找的字符串，按n选下一个</p><p>保存退出</p><p>：w保存</p><p>：q退出</p><p>：wq保存并退出</p><p>​加！是强制执行的意思</p><p>查找替换</p><p>：范围  s&#x2F;原内容&#x2F;新内容&#x2F;全局</p><p>如 ：1,5   s&#x2F;root&#x2F;qianfeng&#x2F;g    从1-5的root替换成qianfeng</p><p>设置环境</p><p>：set nu    设置行号</p><p>：set  list   显示控制字符</p><p>：set nonu   取消设置行号</p></blockquote></li></ul><h5 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h5><ul><li><p>.swap格式的文件，是服务器给我们的备份，一般是写数据进入文件没有保存意外关闭了就会有这种格式的文件，解决方法如下：</p><ol><li><p>查看隐藏文件</p></li><li><p>使用rm删除它即可</p></li></ol></li></ul><p>隐藏文件直接rm -rf &#x2F;*是删不掉的，要指定文件名字删除</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><h5 id="用户和组的基本概念和作用"><a href="#用户和组的基本概念和作用" class="headerlink" title="用户和组的基本概念和作用"></a>用户和组的基本概念和作用</h5><h5 id="用户基本信息文件：-etc目录下的passwd文件"><a href="#用户基本信息文件：-etc目录下的passwd文件" class="headerlink" title="用户基本信息文件：&#x2F;etc目录下的passwd文件"></a>用户基本信息文件：&#x2F;etc目录下的passwd文件</h5><p>文件里面中每一行都是分成了7列，用：分割开，如：</p><blockquote><p>root：x：0：0：root：&#x2F;root：&#x2F;bin&#x2F;bash,       对应如下;</p><p>用户名：x：uid：gid：描述：HOME：shell</p><p>root：用户名：登录系统的名字</p><p>x：密码占位符，具体内容不在着里</p><p>0：UID：用户的身份证号 </p><p>0：GID：GROUP组号</p><p>root：描述：比如经理manage</p><p>&#x2F;root：家目录：登录系统时，所在的目录</p><p>&#x2F;bin&#x2F;bash：登录shell：命令解释器</p><p>系统约定：RHEL7</p><p>uid：0 特权用户</p><p>uid：1~499 系统用户</p><p>uid 1000+ 普通用户</p></blockquote><h5 id="用户密码信息文件-etc-shadow"><a href="#用户密码信息文件-etc-shadow" class="headerlink" title="用户密码信息文件:&#x2F;etc&#x2F;shadow"></a>用户密码信息文件:&#x2F;etc&#x2F;shadow</h5><p>里面存储是用户的密码信息，这里的密码一般是加密过的。对称性密码是可以破解的，非对称性密码不可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</span><br><span class="line">2）“口令”字段存放的是加密后的用户口令字，为空，则对应用户没有口令，登录不需要口令；</span><br><span class="line">星号代表账号被锁定，双叹号表示这个密码已经过期了。</span><br><span class="line">$+数字代表的加密算法种类</span><br><span class="line">3）最后一次修改时间，一般是距离1970.1.1多少天</span><br><span class="line">4）最小时间间隔，密码允许修改的时间。（0代表当天可以改密码，如果是5那么必须过五天才能改）</span><br><span class="line">5）最大时间间隔，密码有效期的意思，99999代表永久</span><br><span class="line">6）警告时间（）</span><br><span class="line">7）不活动时间</span><br><span class="line">8）失效时间</span><br><span class="line">9）保留</span><br></pre></td></tr></table></figure><h5 id="组信息文件：-etc-group（了解即可）"><a href="#组信息文件：-etc-group（了解即可）" class="headerlink" title="组信息文件：&#x2F;etc&#x2F;group（了解即可）"></a>组信息文件：&#x2F;etc&#x2F;group（了解即可）</h5><p>root：x：0：</p><p>组名：组密码：组ID：组成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell    中文叫壳</span><br><span class="line">功能： 命令解释器</span><br><span class="line">  定义命令</span><br><span class="line">  接收命令</span><br><span class="line">  执行命令</span><br><span class="line">版本多：ashell，bashell，cshell，tshell，bash</span><br></pre></td></tr></table></figure><h6 id="用户管理-1"><a href="#用户管理-1" class="headerlink" title="用户管理"></a>用户管理</h6><ol><li><p>添加用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd  用户名       -用户创建命令</span><br></pre></td></tr></table></figure></li><li><p>查询用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id   用户名         -查询用户命令</span><br></pre></td></tr></table></figure></li><li><p>修改用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd  用户名        -修改用户密码命令</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel  -r  用户名          -删除用户,参数r表示连家用户一块删了</span><br></pre></td></tr></table></figure></li><li><p>修改用户属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   usermod -s 用户名        -修改用户属性命令</span><br><span class="line">   如：usermod  -s /sbin/nologin user01，意思是修改user01这个账号，禁止它登录</span><br><span class="line">   参数 -g    修改用户基本组</span><br><span class="line">参数 -G    修改用户附加组</span><br></pre></td></tr></table></figure></li></ol><h6 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h6><ol><li><p>组添加命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd    组名—创建组</span><br></pre></td></tr></table></figure></li><li><p>组删除命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel   组名            -删除组</span><br></pre></td></tr></table></figure></li><li><p>查询组</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以用grep命令，如 grep  new01  /etc/group</span><br></pre></td></tr></table></figure><ol start="4"><li><p>将用户从组中移除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpasswd  -d   用户A   组名B</span><br><span class="line">表示将用户A从B组中移出</span><br></pre></td></tr></table></figure></li><li><p>修改组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod  -g  gid 组名A        -将A组的gid改</span><br></pre></td></tr></table></figure></li></ol><p>组的类型</p><ul><li><p>基本组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">随用户而创建，组名同用户名</span><br></pre></td></tr></table></figure><p>用户的基本组</p></li><li><p>附加组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户加入其他的组就是附加组</span><br></pre></td></tr></table></figure></li></ul><p>组的存在是为了方便用户与文件之间权限的关系，如用户访问文件需要有文件的访问权限，如果有多个文件，那么用户就需要有多个文件的权限，对用户访问文件授权较为麻烦，这时就可以之间对组进行授权，而用户只需要加入这个组就会拥有这个组所拥有的权限，假如不需要这个用户了，直接把用户从这个组移除，那么这个用户就没有了这个组所拥有的权限。</p><h5 id="提权（了解即可）"><a href="#提权（了解即可）" class="headerlink" title="提权（了解即可）"></a>提权（了解即可）</h5><ol><li>提权方法：su</li><li>提权方法2：sudo（临时提权）<ul><li>使用普通用户登录服务器时。</li><li>完成部分特权指令</li></ul></li></ol><p>在&#x2F;etc&#x2F;sudoers文件中记录了权限记录。</p><p>里面的第107行有wheel。</p><h4 id="用户的权限"><a href="#用户的权限" class="headerlink" title="用户的权限"></a>用户的权限</h4><ol><li><p>权限的三类对象UGO</p><ul><li><p>属主：u</p></li><li><p>属组：g</p></li><li><p>其他人：o</p><p>特殊对象：所有人：a（u+g+o）</p></li></ul></li><li><p>权限的三种类型</p><ul><li>读：r&#x3D;4</li><li>写：w&#x3D;2</li><li>执行：x&#x3D;1</li></ul></li><li><p>设置权限</p><ul><li><p>使用符号授权：u用户   g组   o其他   r读   w写   x执行</p><p>语法：chmod    对象（u&#x2F;g&#x2F;o&#x2F;a)赋值符（+&#x2F;-&#x2F;&#x3D;)权限类型（r&#x2F;w&#x2F;x）  文件&#x2F;目录</p><ul><li>chmod           u+r                1. txt</li></ul><p>​       命令     对象加减权限   文件或目录</p><hr><p><img src="%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%5Cimage-20230321142626458.png" alt="image-20230321142626458"></p></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--               2       root    root   0          Mar 21 14:25   1.txt</span><br><span class="line">类型和权限（11个）        链接      属主    属组   文件大小     文件创建日期   文件名</span><br><span class="line">权限9个，类型前后各一个</span><br><span class="line">属主   属组   其他人</span><br><span class="line">rwx    rwx    rwx</span><br><span class="line"> u      g      o</span><br></pre></td></tr></table></figure><ul><li><p>使用数字授权</p><p> 如 chmod     777     file.txt</p><p>7是4（读）+2（写）+1（执行）得来，0就是啥权限都没有</p></li></ul><ol start="4"><li><p>改变属主</p><p>chown ：设置一个文件属于谁，属主</p><p>语法： chown  用户名.组名    文件</p><p>想改文件夹的权限是和改文件的操作一样的</p><p>当然，若还想改文件夹下的所有文件跟文件夹一样，那可以加一个-R参数。代表递归</p></li><li><p>ACL –限制用户对文件的访问</p><p>ACL是UGO的补充，或者说是加强版</p><p>ACL文件权限管理：设置不同用户，不同的基本权限（r、w、x）。对象数量不同</p><p>UGO设置基本权限：只能一个用户，一个组和其他人</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">setfacl   -m     g：hr：rwx   /home/file   设置文件访控 </span><br><span class="line">        -设置   对象：对象名：权限  文件名</span><br><span class="line"></span><br><span class="line">getfacl       ----查看</span><br><span class="line">setfacl   -x    -g（u/o）：hr   /home/file    删除权限</span><br><span class="line">         -设置      对象：对象名   文件名</span><br><span class="line">         </span><br><span class="line">另外setfacl还有一个参数-b,可以直接移除所有附加权限。</span><br></pre></td></tr></table></figure></li><li><p>特殊权限</p><ul><li><p>如果一个重要文件被超级用户删除了，这时候需要靠特殊的i权限</p><ul><li>特殊位suid</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suid，（sgid）针对文件/程序时，具有临时提升权限</span><br><span class="line">suid是针对文件所设置的一个特别的权限</span><br><span class="line">功能：使调用文件的用户，临时具备属主的能力</span><br><span class="line">例如：chmod u+s /usr/bin/cat</span><br><span class="line">以root身份为cat命令授予suid执行位，当其他普通用户使用cat时，临时有root的能力</span><br></pre></td></tr></table></figure><ul><li><p>文件属性chattr</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用途：常用于锁定某个文件，拒绝修改</span><br><span class="line">加参数i，使用户对文件无法删除、修改、移动。</span><br></pre></td></tr></table></figure></li><li><p>进程掩码umask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目录的默认权限是755。</span><br><span class="line">755是0777-0022得来的</span><br><span class="line">文件的默认权限是644。0666是系统为了安全，所以在创建文件时把执行权限去掉了。</span><br><span class="line">644是0666-0022得来的，</span><br></pre></td></tr></table></figure></li></ul></li><li><p>系统创建文件的时候默认权限是644，文件夹权限是755</p></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue2的学习</title>
      <link href="/2023/02/01/vue2%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/02/01/vue2%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>模板渲染语法中，除了支持绑定简单的数据值之外，还支持javascript表达式的运算</p><h3 id="vue的两个特性"><a href="#vue的两个特性" class="headerlink" title="vue的两个特性"></a>vue的两个特性</h3><ul><li>数据驱动视图</li><li>双向数据绑定</li></ul><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><h3 id="组件的应用"><a href="#组件的应用" class="headerlink" title="组件的应用"></a>组件的应用</h3><ul><li><h4 id="组件的导入"><a href="#组件的导入" class="headerlink" title="组件的导入"></a>组件的导入</h4></li><li><h4 id="props组件交互"><a href="#props组件交互" class="headerlink" title="props组件交互"></a>props组件交互</h4></li><li><h4 id="自定义事件组件交互"><a href="#自定义事件组件交互" class="headerlink" title="自定义事件组件交互"></a>自定义事件组件交互</h4></li></ul><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h3 id="Axios网络请求"><a href="#Axios网络请求" class="headerlink" title="Axios网络请求"></a>Axios网络请求</h3><ul><li><h4 id="Axios网络请求封装"><a href="#Axios网络请求封装" class="headerlink" title="Axios网络请求封装"></a>Axios网络请求封装</h4></li><li><h4 id="网络请求跨域解决方案"><a href="#网络请求跨域解决方案" class="headerlink" title="网络请求跨域解决方案"></a>网络请求跨域解决方案</h4></li></ul><h3 id="Vue引入路由配置"><a href="#Vue引入路由配置" class="headerlink" title="Vue引入路由配置"></a>Vue引入路由配置</h3><h3 id="vue核心原理"><a href="#vue核心原理" class="headerlink" title="vue核心原理"></a>vue核心原理</h3><blockquote><p>MVVM是vue实现数据驱动视图和双向数据绑定的核心原理。MVVM指的是Model、View和ViewModel。</p></blockquote><h3 id="vue的基本使用"><a href="#vue的基本使用" class="headerlink" title="vue的基本使用"></a>vue的基本使用</h3><p>先声明一个将要被vue所控制的dom区域，然后创建vm实列对象（vue实例对象）</p><ul><li>el 属性是固定的写法，表示当前 vm 实例要控制页面上的哪个区域，接收的值是一个选择器</li><li>data属性存储的是数据</li></ul><h3 id="vue指令与过滤器"><a href="#vue指令与过滤器" class="headerlink" title="vue指令与过滤器"></a>vue指令与过滤器</h3><blockquote><p>指令是vue为开发者提供的模板语法，用于辅助开发者渲染DOM元素的文本内容。</p></blockquote><ol><li>常用的内容渲染指令有3个：</li></ol><ul><li><p>v-text 指令的缺点：会覆盖元素内部原有的内容（所以实际开发中用的不多），一般开发中用双括号语法</p></li><li><p>双括号语法专门用来解决v-text会覆盖默认文本内容的问题</p></li><li><p>v-html指令：可以把包含html标签的字符串渲染成真正的html内容</p></li></ul><ol start="2"><li><p>属性绑定指令</p><p>注意：双括号语法只能用在内容节点中，不能用在元素节点中</p><ul><li>v-band：（vue 规定 v-bind: 指令可以简写为 :），一般用于为元素的属性动态绑定值</li></ul></li><li><p>事件绑定指令</p><ul><li><p>v-on：，用来辅助开发者为DOM元素绑定事件监听，可以简写成@，一般绑定的事件处理函数放在methods里，与data平级</p></li><li><p>在 methods 处理函数中，this 就是 new 出来的 vm 实例对象</p></li><li><p>vue 提供了内置变量，名字叫做 $event，它就是原生 DOM 的事件对象 e,通过事件对象e的target属性可以更改元素的样式</p></li><li><p>事件修饰符</p><ul><li>与原生的阻止事件默认行为函数preventDefault（）作用一样</li><li>prevent</li></ul></li><li><p>按键修饰符</p><ul><li>esc，指按esc键会触发</li><li>enter，按回车键触发</li></ul></li></ul></li><li><p>双向绑定事件</p><ul><li><p>v-model</p></li><li><p>通常与表单使用,不用操作dom，自动获取表单数据</p><ul><li>例如input、textrea、select等</li></ul></li><li><p>v-model修饰符</p><ul><li>number   将用户输入值转为数值类型</li><li>trim     自动过滤用户输入的首尾空白字符</li><li>lazy  不希望实时同步数据，想在改变之后同步数据，可以用lazy</li></ul></li></ul></li><li><p>条件渲染</p><ul><li>v-if </li><li>v-show <ul><li>两者隐藏的方式不同，v-if隐藏会被动态清除元素，v-show只是用样式display隐藏了，如果要频繁的切换元素的显示状态，用v-show性能更好 </li><li>如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示处理，此时v-if性能更好</li></ul></li></ul></li><li><p>列表渲染</p><ul><li>v-for，需要用item in items形式的特色语法，还支持一个可选的第二个参数，即当前项的索引。语法为（item，index）in items。只要用到了 v-for 指令，那么一定要绑定一个 :key 属性<ul><li>items是带循环的数组</li><li>item是数组的元素</li></ul></li></ul></li><li><p>过滤器</p><ul><li><p>在filters节点中定义</p></li><li><p>过滤器本质上是函数</p></li><li><p>过滤器函数中，一定要有return值</p></li><li><p>在过滤器的形参中，就可以获取到“管道符”前面待处理的那个值</p></li><li><p>全局过滤器 - 独立于每个vm实例之外</p><ul><li><p>Vue.filter()方法有两个参数</p><ul><li>第一个参数，是全局过滤器的“名字”</li><li>第二个参数，是全局过滤器的“处理函数”</li></ul></li><li><p>一般开发中基本是用全局过滤器</p></li><li><p>vue3中已经剔除了过滤器功能</p></li></ul></li></ul></li></ol><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><ul><li>在watch节点中定义</li><li>要监视哪个数据的变化，就把数据名作为方法名即可</li><li>usename（newVal，oldVal）</li><li>监听器的格式<ul><li>方法格式的监听器<ul><li>缺点1：无法在进入页面的时候，自动触发</li><li>缺点2：如果监听的是一个对象，如果对象中的属性发送了变化，不会触发监听器</li></ul></li><li>对象格式的监听器<ul><li>好处：可以通过immediate选项，让监听器自动触发</li><li>要开启deep选项，就可以监听对象中的任何一个属性变化了</li></ul></li></ul></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ul><li>计算属性要定义在comuted节点下</li><li>定义时要定义成方法。</li><li>用的时候当属性使用</li></ul><h3 id="Vue-cli的使用"><a href="#Vue-cli的使用" class="headerlink" title="Vue-cli的使用"></a>Vue-cli的使用</h3><ol><li><p>assert 文件夹: 存放项目中用到的静态资源文件。例如：css样式表、图片资源</p></li><li><p>compoment文件夹： 程序员封装的、可复用的组件。都要放到compoments目录下</p></li><li><p>main.js 是项目的入口文件。整个项目的运行，要先执行main.js</p></li><li><p>App.vue 是项目的根组件</p></li></ol><p>在工程化中，vue要做的事很简单，就是把App.vue渲染到index.html页面中</p><p>template代表模板结构</p><ol><li>App.vue用来编写待渲染的模板结构</li><li>index.html中需要预留一个el区域</li><li>main.js把App.vue渲染到了index.html所预留的区域中</li></ol><h4 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h4><p>.vue后缀名的都是组件</p><p>​vue组件的三个组成部分</p><ul><li><p>template</p><p>声明vue的ui结构的</p></li><li><p>style</p><p>组件的样式</p></li><li><p>script</p><p>组件的JavaScript行为</p><p>（export  default是固定语法，默认导出）</p><p>.vue组件中的data不能像之前一样，不能指向对象</p><p>组件中的data必须是一个函数</p><p>其中，每个组件中必须包含template模板结构。而script行为和style样式是可选的</p></li></ul><p>template中只能有一个根元素（一个div）</p><p>使用组件的三个步骤</p><ol><li>使用import语法导入需要的组件</li><li>使用components节点注册组件</li><li>以标签形式使用刚才注册的组件</li></ol><h3 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h3><ol><li>vue组件可以使用全局组件</li></ol><p>​比如在main.js中使用import语法导入需要全局的组件，然后使用Vue的component方法注册。</p><ol start="2"><li><p>props自定义属性</p><p>props是自定义属性，运行使用者通过自定义属性，为当前组件指定初始值，放在data中。如：props：[“属性名”]</p><p>自定义属性名要合法</p><ul><li>props也可以用对象形式存储。如：props{ init：{   default：0}   }</li><li>props里面也可以规定值的类型。用type定义</li></ul></li><li><p>样式冲突</p><blockquote><p>可以在style标签中加一个scoped属性。原理是给当前组件自动生成一个自定义属性data-v-*。</p><p>当然，scoped有缺陷。可以用在选择器前加上‘&#x2F;deep&#x2F;’，一般使用第三方组件库时，由修改默认样式的需求，需要用到‘&#x2F;deep&#x2F;‘。</p></blockquote></li></ol><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>​生命周期是指一个组件从创建–&gt;运行–&gt;销毁的整个阶段，强调的是一个时间段。</p><p>​生命周期函数：beforeCreate（）、created（）、createMount（）、mounted（）、beforeUpdate（）、updated（）、beforeDestroy（）、destroy（）</p><ol><li>created（）很常用，经常用来发起Ajax请求</li><li>最早可以操作DOM元素是在mounted（）时。</li><li>beforeUpdate（）时里面的数据是新的，但是页面的DOM元素是旧的</li></ol><h3 id="Vue组件之间的数据共享"><a href="#Vue组件之间的数据共享" class="headerlink" title="Vue组件之间的数据共享"></a>Vue组件之间的数据共享</h3><p>组件之间最常见的关系有两种：1是父子关系，2是兄弟关系</p><ol><li>子向父共享用自定义事件。自定义事件需要用$emit()方法触发。</li><li>父向子用props自定义属性</li><li>兄弟之间用EventBus，发送方调$emit(),接送方调$on()</li></ol><h3 id="Vue-ref引用"><a href="#Vue-ref引用" class="headerlink" title="Vue-$ref引用"></a>Vue-$ref引用</h3><ol><li>ref是用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的</li><li>this.$nextTick(callback)方法，会将cb回调推迟到下一个周期执行。当有延迟到DOM元素渲染成功的需求就可以用this.$nextTick(callback)</li></ol><h3 id="Vue购物车案例"><a href="#Vue购物车案例" class="headerlink" title="Vue购物车案例"></a>Vue购物车案例</h3><ol><li>双括号不能用在属性中，属性中需要用到data中的属性应该用v-band</li><li>全选复选框功能</li></ol><h3 id="Vue动态组件"><a href="#Vue动态组件" class="headerlink" title="Vue动态组件"></a>Vue动态组件</h3><p>vue提供了一个内置的<component>组件，专门用来实现动态组件的渲染，实例如下：</component></p><p><code>&lt;component :*is*=&quot;componentName&quot;&gt;&lt;/component&gt;</code></p><ol><li><p>keep-alive 可以把内部的组件进行缓存，而不是销毁组件。作用就是用在组件切换。</p></li><li><p>keep-alive对应的生命周期函数</p><ol><li>当组件被激活时，会触发activated（）函数</li><li>当组件被缓存时，会触发deactivated()函数</li></ol></li><li><p>keep-alive的include属性</p></li></ol><ul><li>include属性用来指定：只有名称匹配的组件才会被缓存。多个组件名之间用,分割</li></ul><ol start="4"><li><p>组件的注册名称主要应用场景是：以标签的形式，把注册好的组件，渲染和使用到页面结构之中。</p><blockquote><p>而组件声明时候的“name”名称的主要应用场景：结合<keep-alive>标签实现组件缓存功能，以及在调试工具中看到组件的name名称</keep-alive></p></blockquote></li></ol><h3 id="Vue插槽"><a href="#Vue插槽" class="headerlink" title="Vue插槽"></a>Vue插槽</h3><p>插槽是开发者留给用户自定义的区域，简单来说，就是把不确定的、希望由用户指定的部分定义为插槽。</p><ol><li><p>插槽是在被使用组件中使用的。</p></li><li><p>每一个slot插槽，都要有一个name名称，如果省略了slot的name属性，则有一个默认名称叫做default</p></li><li><p>v-slot指令可以指明发在哪个插槽里。另外v-slot只能用在components和<code>&lt;template&gt;</code>中。用法：v-slot：后面跟上插槽的名字</p></li><li><p><code>&lt;template&gt;</code>是一个虚拟的元素，并不会渲染在页面中 </p><p>v-slot指令的简写形式是#符号</p></li></ol><h3 id="Vue自定义指令"><a href="#Vue自定义指令" class="headerlink" title="Vue自定义指令"></a>Vue自定义指令</h3><ol><li><p>私有自定义指令，用法</p><blockquote><p><code>directives 与data、method平级</code></p><p><code>在directives节点里定义自定义指令，如：</code></p><p><code>directives：&#123;</code></p><p><code>color：&#123;</code></p><p><code>//当指令第一次被绑定到元素上的时候，会立即触发bind函数</code></p><p><code>//形参中的el表示当前指令所绑定的那个DOM对象</code></p><p><code>bind（el,binding）&#123;</code></p><p><code>console.log(&quot;ddddd&quot;);</code></p><p><code>el.style.color = binding.value</code></p><p><code>&#125;</code></p><p><code>&#125;</code></p><p><code>&#125;</code></p></blockquote></li><li><p>update函数</p><p>由于bind函数只调用一次，当指令第一次绑定到元素时调用，当DOM更新时bind不会再次触发，所以这时要用到update函数。数据更新时就需要update函数</p></li><li><p>全局定义自定义组件</p><p>在main.js中写以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&#x27;color&#x27;,function(el,binding)&#123;</span><br><span class="line">el.style.color = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Vue挂载"><a href="#Vue挂载" class="headerlink" title="Vue挂载"></a>Vue挂载</h3><ol><li>直接挂载上vue的prototype属性上，可以实现全局变量。缺点是不利于API接口的复用</li></ol><h3 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h3><p>路由就是hash地址与组件间的对应关系</p><ol><li><p>利用锚链接进行跳转</p></li><li><p>一般路由通过第三方库进行开发</p></li><li><p>用vue-router进行路由开发</p><h4 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h4><ol><li><p>在进行模块化导入的时候，如果给定的是文件夹，则默认导入这个文件夹下，名字叫做index.js的文件</p></li><li><p>router-view标签</p><ul><li>只要在项目中安装和配置了vue-router，就可以使用router-view这个组件</li><li>作用：占位符</li></ul></li><li><p>router-link</p><ul><li>当安装和配置了vue-router后，就可以使用router-link代替普通的a链接了</li><li>router-link里属性to与a链接中的href一致，不用写#</li></ul></li><li><p>路由重定向</p><ul><li>路由重定向指定是：用户在访问地址A的时候，强制用户跳转到地址C，从而展示特定的页面。用redirect实现</li></ul></li><li><p>嵌套路由</p><ul><li>通过childen属性声明子路由规则，子路由中path不要加&#x2F;</li></ul></li><li><p>动态路由</p><ul><li>把Hash地址中可变的部分定义为参数项，从而提高路由规则的复用性</li><li>在vue-router中使用英文冒号：来定义路由的参数项。</li><li>可以在vue实例中$route中的parms中的id中找到id</li><li>this.$route是路由的参数对象</li><li>this.$router是路由的导航对象</li></ul></li></ol></li></ol><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><ol><li><p>声明式导航：点击链接实现导航的方式，叫做声明式导航</p></li><li><p>编程式导航：调用API方式实现导航的方式，叫做编程式导航</p></li><li><p>vue-router中的编程式导航API</p><ul><li><p>this.$router.push(“hash地址”)</p><blockquote><p>跳转到指定hash地址的页面（会有浏览历史存在）</p></blockquote></li><li><p>this.$router.replace(“hash地址”)</p><blockquote><p>跳转到指定hash地址的页面（没有历史记录或者说替换掉当前的历史记录）</p></blockquote></li><li><p>this.$router.go(n)</p><blockquote><p>n为1或者-1，前进或者后退，go(-1)表示后退一层，若后退的层数超过上限，则原地不动</p></blockquote><ul><li>vue提供了两个go的简化方法，$router.back（）前进一层和$router.forward（）后退一层，写行内的话this要省略</li></ul></li></ul></li></ol><h3 id="vue-router-导航守卫"><a href="#vue-router-导航守卫" class="headerlink" title="vue-router-导航守卫"></a>vue-router-导航守卫</h3><p>导航守卫可以控制路由的访问权限</p><ol><li><p>全局前置守卫</p><blockquote><p>每次发生路由的导航跳转时，都会触发全局前置守卫。</p><p>router.beforeEach(fn)</p><p>回调函数中的三个形参：to，from，next</p><ol><li>to是将要访问的路由的信息对象</li><li>from是将要离开的路由信息</li><li>next是一个函数，调用next（）表示放行，允许这次路由导航</li></ol></blockquote></li><li><p>next函数的3此调用方式</p><ul><li>当前用户拥有后台主页的访问权限，直接放行：next（）</li><li>当前用户没有后台主页的访问权限，强制其跳转到登陆页面：next（”&#x2F;login”）</li><li>当前用户没有后台主页的访问权限，不允许跳转到后台主页：next（false）</li></ul></li></ol><h3 id="Vue2最后的学习-注意点"><a href="#Vue2最后的学习-注意点" class="headerlink" title="Vue2最后的学习-注意点"></a>Vue2最后的学习-注意点</h3><ol><li><p>在使用组件的时候，如果某个属性名是”小驼峰“的形式，则绑定属性的时候，建议改写成‘连字符’格式。例如：</p><p>cmtCount 建议写出cmt-count</p></li><li><p>通过数组形式，可以为当前属性定义多个可能的类型</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js进阶(ES6新语法)</title>
      <link href="/2023/01/31/js%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/01/31/js%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p><em>一般不确定实参多少个的情况下，可以把实参都接收过来</em></p><ul><li><p>arguments：是在函数内部存的动态参数变量，是一个伪数组，内部包含了调用函数时传入的所有实参</p></li><li><p>伪数组可以遍历，因此可以遍历获取所有实参</p></li><li><p>伪数组是不能用数组的方法的</p></li><li><h5 id="ES6推出了新语法，剩余参数"><a href="#ES6推出了新语法，剩余参数" class="headerlink" title="ES6推出了新语法，剩余参数"></a>ES6推出了新语法，剩余参数</h5><ul><li><h5 id="在形参前写…，如function-getNum（…a）-console-log-a"><a href="#在形参前写…，如function-getNum（…a）-console-log-a" class="headerlink" title="在形参前写…，如function getNum（…a）{console.log(a)},"></a>在形参前写…，如function getNum（…a）{console.log(a)},</h5></li><li><p>取过来的参数会变成数组，就可以使用数组的方法</p></li></ul></li><li><h5 id="数组一般用forEach（callback）方法遍历，不需要用for循环"><a href="#数组一般用forEach（callback）方法遍历，不需要用for循环" class="headerlink" title="数组一般用forEach（callback）方法遍历，不需要用for循环"></a>数组一般用forEach（callback）方法遍历，不需要用for循环</h5></li><li><h5 id="开发一般用剩余参数"><a href="#开发一般用剩余参数" class="headerlink" title="开发一般用剩余参数"></a>开发一般用剩余参数</h5></li><li><p>剩余参数也可以用于将数组、对象进行合并</p></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol><li><p>箭头函数只有一个形参时，可以省略（）</p><ul><li>let fn1 &#x3D; (<em>num</em>) &#x3D;&gt; {</li></ul><p>​      console.log(<em>num</em>);</p><p>​    }</p><p>​    fn1(100)</p><ul><li>let fn1 &#x3D; <em>num</em> &#x3D;&gt; {</li></ul><p>  ​      console.log(<em>num</em>);</p><p>  ​    }</p></li><li><p>如果箭头函数中函数体只有一行代码，此时可以省略{},</p><p>如果只有一行，并且这一行代码是return，此时return可以省略</p><ul><li><p>let fn2 &#x3D; num &#x3D;&gt; console.log(num)</p></li><li><p>let fn3 &#x3D; function(num){return num*num}相当于</p><p>let fn3 &#x3D; num &#x3D;&gt; num*num</p></li></ul></li><li><p>求数组和，以及将一组数组的每一项都求平方，存储到新数组中去</p><ul><li><p>let arr &#x3D; [1,2,3]</p><p>let sum &#x3D; 0</p><p>arr.forEach(item &#x3D;&gt; sum +&#x3D; item)</p></li><li><p>let arr1 &#x3D; [1,2,3,4,5,6,7,8]</p><p>let newArr &#x3D; arr1.map(item &#x3D;&gt; item*item)</p></li></ul></li><li><p>箭头函数没有arguments的</p><ul><li><p>let fn &#x3D; () &#x3D;&gt; {</p><p>console.log(arrguments)</p><p>}</p><p>let fn &#x3D; (**…**arr) &#x3D;&gt; {</p><p>let sum &#x3D; 0</p><p>arr.forEach(item &#x3D;&gt; sum +&#x3D; item)</p><p>console.log(sum)</p><p>}</p><p>fn(10)</p><p>fn(10,100)</p><p>fn(10,100,1000)</p></li></ul></li><li><p>箭头函数this</p><ul><li>普通函数调用-&gt;指向window</li><li>对象函数调用-&gt;指向调用的对象</li><li>注册事件-&gt;指向事件源</li><li><em><strong>注意点</strong></em>：箭头函数内部没有自己的this，如果需要使用，浏览器会按照作用域链依次查找，事件源一般推荐用普通的匿名函数</li></ul></li></ol><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><ul><li><p>正常情况下，变量数和单元数应该一致，</p><ul><li>let [one,two,three]&#x3D;[“喜喜”，“哈哈哈”，“嘤嘤嘤”]；</li></ul></li><li><p>特色情况1：变量多，单元数少，没有接收到的数据的变量，默认是undefined</p></li><li><p>特色情况2：变量少，单元数多，没有接收到的数据的变量，多出的会忽略</p></li><li><p>如果需要把多余的参数一起接收，可以使用剩余参数</p></li><li><p>特色情况3：如果不希望变量值为undefined，此时可以给变量设置默认值</p><ul><li>let [x&#x3D;”默认1”，y&#x3D;”默认值2“，z&#x3D;”默认值3“] &#x3D; [”啧啧啧“]</li></ul></li></ul><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><h3 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h3><h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h3 id="字符串扩展和新增方法"><a href="#字符串扩展和新增方法" class="headerlink" title="字符串扩展和新增方法"></a>字符串扩展和新增方法</h3><h3 id="数组扩展-扩展运算符，新增方法"><a href="#数组扩展-扩展运算符，新增方法" class="headerlink" title="数组扩展_扩展运算符，新增方法"></a>数组扩展_扩展运算符，新增方法</h3><ul><li>filter（function（item，index）{return 条件}），数组的方法，用于过滤、筛选</li></ul><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><h3 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h3><h3 id="ASync函数"><a href="#ASync函数" class="headerlink" title="ASync函数"></a>ASync函数</h3><h3 id="Class的基本语法"><a href="#Class的基本语法" class="headerlink" title="Class的基本语法"></a>Class的基本语法</h3><h3 id="Moule模块"><a href="#Moule模块" class="headerlink" title="Moule模块"></a>Moule模块</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端学习笔记</title>
      <link href="/2023/01/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前端学习笔记"><a href="#前端学习笔记" class="headerlink" title="前端学习笔记"></a>前端学习笔记</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>dom是文档对象模型，核心对象是document</p><p>文档：一个页面就是一个文档，DOM中使用document表示</p><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p><p>节点：网页总的所有内容都是节点（标签、属性等），DOM中使用node表示</p><h5 id="获取元素：getElementById（）"><a href="#获取元素：getElementById（）" class="headerlink" title="获取元素：getElementById（）"></a>获取元素：getElementById（）</h5><p>根据ID获取</p><p>script标签要写在标签的下面，因为我们文档页面从上往下加载，所以得先有标签</p><h4 id="操作元素innerHTML和innerText"><a href="#操作元素innerHTML和innerText" class="headerlink" title="操作元素innerHTML和innerText"></a>操作元素innerHTML和innerText</h4><p>innerText不识别html标签</p><p>innerHTML识别html标签，常用innerHTML</p><p>var nowtime &#x3D; +new Date();&#x2F;&#x2F;得到的就是当下的时间距离1970年1月1日0时0分0秒的毫秒数</p><p>var inputTime &#x3D; +new Date(time); &#x2F;&#x2F; 放回的是用户输入时间总的毫秒数</p><h4 id="DOM重点核心"><a href="#DOM重点核心" class="headerlink" title="DOM重点核心"></a>DOM重点核心</h4><p>主要对元素的操作，主要有增删改查（CRUD）、创建元素、元素属性操作、事件操作。</p><h4 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h4><p>onkeyup keyup 按键弹起的时候触发 </p><p>onkeydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊</p><p>onkeypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊</p><p>三个事件的执行顺序  keydown – keypress – keyup</p><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p>BOM即浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window</p><p>width：auto与100%</p><p>当width设置为100%，会等于父元素的width</p><p>当width设置为auto，会根据元素本身的height这个属性决定。简单的说按照height的缩放比例来设置</p><h4 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h4><ul><li><p>块级元素</p><ol><li>独占一行</li><li>宽度默认是父元素的宽度</li><li>可以设置宽高</li><li>例如div、p、h系列、li、ul、dl、dt、dd、form、header、nav、footer等</li></ol></li><li><p>行内元素</p><ol><li>不换行，一行可以显示多个</li><li>宽度和高度默认由内容撑开</li><li>设置宽高不生效</li><li>例如span、a、b、u、i、strong、ins、em、del等</li></ol></li><li><p>行内块元素</p><ol><li>一行可以显示多个</li><li>可以设置宽高</li><li>例如input、textarea、button、select</li><li>特殊清空：img标签由行内块元素特点，但是chrome调试工具显示为行内标签</li></ol></li><li><p>元素显示模式转换</p><ol><li>目的：改变元素默认的显示特点，让元素符合布局要求</li></ol></li></ul><p>扩展1：HTML嵌套规范注意点</p><ol><li><p>块级元素一般作为大容器，可以嵌套文本。块级元素。行内元素、行内块元素等等</p><ul><li>但是p标签中不要嵌套div、p、h等块级元素</li></ul></li><li><p>a标签内部可以嵌套任意元素</p><ul><li>但是a标签不能嵌套a标签</li></ul></li></ol><h3 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h3><h6 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h6><p>一般子元素会继承父元素里的样式，关于文字的样式会继承，但是有些元素会有默认的文字样式所以就没有继承</p><h6 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h6><h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>绝对定位的盒子使用margin不能居中，可以用left百分比写法，再加上margin，或者用transform：translate(-50%，-50%)位移的写法，这样写的好处就是可以自己计算宽高的一半</p><p>相对定位会使标签元素脱标，并且原有位置依然被占用</p><p>定位习惯子绝夫相的写法</p><h5 id="基线对齐"><a href="#基线对齐" class="headerlink" title="基线对齐"></a>基线对齐</h5><p>属性名：vertical-align，默认文字按基线对齐，浏览器默认将行内块和行内标签认定为文字，改变显示模式也可以解决基线问题</p><p>一般解决文字水平方向对不齐的情况，想居中对齐用middle，顶对齐用top，底对齐用bottom</p><h5 id="overflow：hidden"><a href="#overflow：hidden" class="headerlink" title="overflow：hidden"></a>overflow：hidden</h5><p>隐藏盒子溢出部分</p><h5 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility:hidden"></a>visibility:hidden</h5><p>占位隐藏</p><h5 id="display：none"><a href="#display：none" class="headerlink" title="display：none"></a>display：none</h5><p>不占位隐藏</p><p>常用于子菜单显示，不占位隐藏较为常用</p><h5 id="（扩展），透明度"><a href="#（扩展），透明度" class="headerlink" title="（扩展），透明度"></a>（扩展），透明度</h5><ul><li>opacity</li><li>会使内容都变透明，纯写html、css不会用到，一般用rgba(a,b,c,0.5)这种，不会使内容变透明</li></ul><h5 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h5><ul><li>减少服务器发送次数，减轻服务器压力，提高页面加载速度</li><li>精灵图就是将多张小图片合并成一张大图片，这张大图片就叫做精灵图</li><li></li></ul><h4 id="锚链接"><a href="#锚链接" class="headerlink" title="锚链接"></a>锚链接</h4><ol><li>跳转到当前页面的指定位置</li><li>跳转到当前页面的指定位置</li></ol><blockquote><p>在要跳转到的位置所在的标签中添加了<code>id</code>属性，并为其赋值；</p><p>使用 <a> 标签设置锚点，href 属性值为<code>#</code>+<code>id</code>属性值。</a></p></blockquote><p>网页的顶端默认是<code>#top</code>，所以如果是跳转到浏览器的顶端，不需要写锚点的第一步操作,，也就是说不需要为标签设置 id 属性。</p><blockquote><p>注意：href 属性中的 top 也可以省略，不影响正常使用。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
