<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue2的学习</title>
      <link href="/2023/02/01/vue2%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/02/01/vue2%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>模板渲染语法中，除了支持绑定简单的数据值之外，还支持javascript表达式的运算</p><h3 id="vue的两个特性"><a href="#vue的两个特性" class="headerlink" title="vue的两个特性"></a>vue的两个特性</h3><ul><li>数据驱动视图</li><li>双向数据绑定</li></ul><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><h3 id="组件的应用"><a href="#组件的应用" class="headerlink" title="组件的应用"></a>组件的应用</h3><ul><li><h4 id="组件的导入"><a href="#组件的导入" class="headerlink" title="组件的导入"></a>组件的导入</h4></li><li><h4 id="props组件交互"><a href="#props组件交互" class="headerlink" title="props组件交互"></a>props组件交互</h4></li><li><h4 id="自定义事件组件交互"><a href="#自定义事件组件交互" class="headerlink" title="自定义事件组件交互"></a>自定义事件组件交互</h4></li></ul><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h3 id="Axios网络请求"><a href="#Axios网络请求" class="headerlink" title="Axios网络请求"></a>Axios网络请求</h3><ul><li><h4 id="Axios网络请求封装"><a href="#Axios网络请求封装" class="headerlink" title="Axios网络请求封装"></a>Axios网络请求封装</h4></li><li><h4 id="网络请求跨域解决方案"><a href="#网络请求跨域解决方案" class="headerlink" title="网络请求跨域解决方案"></a>网络请求跨域解决方案</h4></li></ul><h3 id="Vue引入路由配置"><a href="#Vue引入路由配置" class="headerlink" title="Vue引入路由配置"></a>Vue引入路由配置</h3><h3 id="vue核心原理"><a href="#vue核心原理" class="headerlink" title="vue核心原理"></a>vue核心原理</h3><blockquote><p>MVVM是vue实现数据驱动视图和双向数据绑定的核心原理。MVVM指的是Model、View和ViewModel。</p></blockquote><h3 id="vue的基本使用"><a href="#vue的基本使用" class="headerlink" title="vue的基本使用"></a>vue的基本使用</h3><p>先声明一个将要被vue所控制的dom区域，然后创建vm实列对象（vue实例对象）</p><ul><li>el 属性是固定的写法，表示当前 vm 实例要控制页面上的哪个区域，接收的值是一个选择器</li><li>data属性存储的是数据</li></ul><h3 id="vue指令与过滤器"><a href="#vue指令与过滤器" class="headerlink" title="vue指令与过滤器"></a>vue指令与过滤器</h3><blockquote><p>指令是vue为开发者提供的模板语法，用于辅助开发者渲染DOM元素的文本内容。</p></blockquote><ol><li>常用的内容渲染指令有3个：</li></ol><ul><li><p>v-text 指令的缺点：会覆盖元素内部原有的内容（所以实际开发中用的不多），一般开发中用双括号语法</p></li><li><p>双括号语法专门用来解决v-text会覆盖默认文本内容的问题</p></li><li><p>v-html指令：可以把包含html标签的字符串渲染成真正的html内容</p></li></ul><ol start="2"><li><p>属性绑定指令</p><p>注意：双括号语法只能用在内容节点中，不能用在元素节点中</p><ul><li>v-band：（vue 规定 v-bind: 指令可以简写为 :），一般用于为元素的属性动态绑定值</li></ul></li><li><p>事件绑定指令</p><ul><li><p>v-on：，用来辅助开发者为DOM元素绑定事件监听，可以简写成@，一般绑定的事件处理函数放在methods里，与data平级</p></li><li><p>在 methods 处理函数中，this 就是 new 出来的 vm 实例对象</p></li><li><p>vue 提供了内置变量，名字叫做 $event，它就是原生 DOM 的事件对象 e,通过事件对象e的target属性可以更改元素的样式</p></li><li><p>事件修饰符</p><ul><li>与原生的阻止事件默认行为函数preventDefault（）作用一样</li><li>prevent</li></ul></li><li><p>按键修饰符</p><ul><li>esc，指按esc键会触发</li><li>enter，按回车键触发</li></ul></li></ul></li><li><p>双向绑定事件</p><ul><li><p>v-model</p></li><li><p>通常与表单使用,不用操作dom，自动获取表单数据</p><ul><li>例如input、textrea、select等</li></ul></li><li><p>v-model修饰符</p><ul><li>number   将用户输入值转为数值类型</li><li>trim     自动过滤用户输入的首尾空白字符</li><li>lazy  不希望实时同步数据，想在改变之后同步数据，可以用lazy</li></ul></li></ul></li><li><p>条件渲染</p><ul><li>v-if </li><li>v-show <ul><li>两者隐藏的方式不同，v-if隐藏会被动态清除元素，v-show只是用样式display隐藏了，如果要频繁的切换元素的显示状态，用v-show性能更好 </li><li>如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示处理，此时v-if性能更好</li></ul></li></ul></li><li><p>列表渲染</p><ul><li>v-for，需要用item in items形式的特色语法，还支持一个可选的第二个参数，即当前项的索引。语法为（item，index）in items。只要用到了 v-for 指令，那么一定要绑定一个 :key 属性<ul><li>items是带循环的数组</li><li>item是数组的元素</li></ul></li></ul></li><li><p>过滤器</p><ul><li><p>在filters节点中定义</p></li><li><p>过滤器本质上是函数</p></li><li><p>过滤器函数中，一定要有return值</p></li><li><p>在过滤器的形参中，就可以获取到“管道符”前面待处理的那个值</p></li><li><p>全局过滤器 - 独立于每个vm实例之外</p><ul><li><p>Vue.filter()方法有两个参数</p><ul><li>第一个参数，是全局过滤器的“名字”</li><li>第二个参数，是全局过滤器的“处理函数”</li></ul></li><li><p>一般开发中基本是用全局过滤器</p></li><li><p>vue3中已经剔除了过滤器功能</p></li></ul></li></ul></li></ol><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><ul><li>在watch节点中定义</li><li>要监视哪个数据的变化，就把数据名作为方法名即可</li><li>usename（newVal，oldVal）</li><li>监听器的格式<ul><li>方法格式的监听器<ul><li>缺点1：无法在进入页面的时候，自动触发</li><li>缺点2：如果监听的是一个对象，如果对象中的属性发送了变化，不会触发监听器</li></ul></li><li>对象格式的监听器<ul><li>好处：可以通过immediate选项，让监听器自动触发</li><li>要开启deep选项，就可以监听对象中的任何一个属性变化了</li></ul></li></ul></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ul><li>计算属性要定义在comuted节点下</li><li>定义时要定义成方法。</li><li>用的时候当属性使用</li></ul><h3 id="Vue-cli的使用"><a href="#Vue-cli的使用" class="headerlink" title="Vue-cli的使用"></a>Vue-cli的使用</h3><ol><li><p>assert 文件夹: 存放项目中用到的静态资源文件。例如：css样式表、图片资源</p></li><li><p>compoment文件夹： 程序员封装的、可复用的组件。都要放到compoments目录下</p></li><li><p>main.js 是项目的入口文件。整个项目的运行，要先执行main.js</p></li><li><p>App.vue 是项目的根组件</p></li></ol><p>在工程化中，vue要做的事很简单，就是把App.vue渲染到index.html页面中</p><p>template代表模板结构</p><ol><li>App.vue用来编写待渲染的模板结构</li><li>index.html中需要预留一个el区域</li><li>main.js把App.vue渲染到了index.html所预留的区域中</li></ol><h4 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h4><p>.vue后缀名的都是组件</p><p>​vue组件的三个组成部分</p><ul><li><p>template</p><p>声明vue的ui结构的</p></li><li><p>style</p><p>组件的样式</p></li><li><p>script</p><p>组件的JavaScript行为</p><p>（export  default是固定语法，默认导出）</p><p>.vue组件中的data不能像之前一样，不能指向对象</p><p>组件中的data必须是一个函数</p><p>其中，每个组件中必须包含template模板结构。而script行为和style样式是可选的</p></li></ul><p>template中只能有一个根元素（一个div）</p><p>使用组件的三个步骤</p><ol><li>使用import语法导入需要的组件</li><li>使用components节点注册组件</li><li>以标签形式使用刚才注册的组件</li></ol><h3 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h3><ol><li>vue组件可以使用全局组件</li></ol><p>​比如在main.js中使用import语法导入需要全局的组件，然后使用Vue的component方法注册。</p><ol start="2"><li><p>props自定义属性</p><p>props是自定义属性，运行使用者通过自定义属性，为当前组件指定初始值，放在data中。如：props：[“属性名”]</p><p>自定义属性名要合法</p><ul><li>props也可以用对象形式存储。如：props{ init：{   default：0}   }</li><li>props里面也可以规定值的类型。用type定义</li></ul></li><li><p>样式冲突</p><blockquote><p>可以在style标签中加一个scoped属性。原理是给当前组件自动生成一个自定义属性data-v-*。</p><p>当然，scoped有缺陷。可以用在选择器前加上‘&#x2F;deep&#x2F;’，一般使用第三方组件库时，由修改默认样式的需求，需要用到‘&#x2F;deep&#x2F;‘。</p></blockquote></li></ol><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p>​生命周期是指一个组件从创建–&gt;运行–&gt;销毁的整个阶段，强调的是一个时间段。</p><p>​生命周期函数：beforeCreate（）、created（）、createMount（）、mounted（）、beforeUpdate（）、updated（）、beforeDestroy（）、destroy（）</p><ol><li>created（）很常用，经常用来发起Ajax请求</li><li>最早可以操作DOM元素是在mounted（）时。</li><li>beforeUpdate（）时里面的数据是新的，但是页面的DOM元素是旧的</li></ol><h3 id="Vue组件之间的数据共享"><a href="#Vue组件之间的数据共享" class="headerlink" title="Vue组件之间的数据共享"></a>Vue组件之间的数据共享</h3><p>组件之间最常见的关系有两种：1是父子关系，2是兄弟关系</p><ol><li>子向父共享用自定义事件。自定义事件需要用$emit()方法触发。</li><li>父向子用props</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js进阶(ES6新语法)</title>
      <link href="/2023/01/31/js%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/01/31/js%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p><em>一般不确定实参多少个的情况下，可以把实参都接收过来</em></p><ul><li><p>arguments：是在函数内部存的动态参数变量，是一个伪数组，内部包含了调用函数时传入的所有实参</p></li><li><p>伪数组可以遍历，因此可以遍历获取所有实参</p></li><li><p>伪数组是不能用数组的方法的</p></li><li><h5 id="ES6推出了新语法，剩余参数"><a href="#ES6推出了新语法，剩余参数" class="headerlink" title="ES6推出了新语法，剩余参数"></a>ES6推出了新语法，剩余参数</h5><ul><li><h5 id="在形参前写…，如function-getNum（…a）-console-log-a"><a href="#在形参前写…，如function-getNum（…a）-console-log-a" class="headerlink" title="在形参前写…，如function getNum（…a）{console.log(a)},"></a>在形参前写…，如function getNum（…a）{console.log(a)},</h5></li><li><p>取过来的参数会变成数组，就可以使用数组的方法</p></li></ul></li><li><h5 id="数组一般用forEach（callback）方法遍历，不需要用for循环"><a href="#数组一般用forEach（callback）方法遍历，不需要用for循环" class="headerlink" title="数组一般用forEach（callback）方法遍历，不需要用for循环"></a>数组一般用forEach（callback）方法遍历，不需要用for循环</h5></li><li><h5 id="开发一般用剩余参数"><a href="#开发一般用剩余参数" class="headerlink" title="开发一般用剩余参数"></a>开发一般用剩余参数</h5></li><li><p>剩余参数也可以用于将数组、对象进行合并</p></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol><li><p>箭头函数只有一个形参时，可以省略（）</p><ul><li>let fn1 &#x3D; (<em>num</em>) &#x3D;&gt; {</li></ul><p>​      console.log(<em>num</em>);</p><p>​    }</p><p>​    fn1(100)</p><ul><li>let fn1 &#x3D; <em>num</em> &#x3D;&gt; {</li></ul><p>  ​      console.log(<em>num</em>);</p><p>  ​    }</p></li><li><p>如果箭头函数中函数体只有一行代码，此时可以省略{},</p><p>如果只有一行，并且这一行代码是return，此时return可以省略</p><ul><li><p>let fn2 &#x3D; num &#x3D;&gt; console.log(num)</p></li><li><p>let fn3 &#x3D; function(num){return num*num}相当于</p><p>let fn3 &#x3D; num &#x3D;&gt; num*num</p></li></ul></li><li><p>求数组和，以及将一组数组的每一项都求平方，存储到新数组中去</p><ul><li><p>let arr &#x3D; [1,2,3]</p><p>let sum &#x3D; 0</p><p>arr.forEach(item &#x3D;&gt; sum +&#x3D; item)</p></li><li><p>let arr1 &#x3D; [1,2,3,4,5,6,7,8]</p><p>let newArr &#x3D; arr1.map(item &#x3D;&gt; item*item)</p></li></ul></li><li><p>箭头函数没有arguments的</p><ul><li><p>let fn &#x3D; () &#x3D;&gt; {</p><p>console.log(arrguments)</p><p>}</p><p>let fn &#x3D; (**…**arr) &#x3D;&gt; {</p><p>let sum &#x3D; 0</p><p>arr.forEach(item &#x3D;&gt; sum +&#x3D; item)</p><p>console.log(sum)</p><p>}</p><p>fn(10)</p><p>fn(10,100)</p><p>fn(10,100,1000)</p></li></ul></li><li><p>箭头函数this</p><ul><li>普通函数调用-&gt;指向window</li><li>对象函数调用-&gt;指向调用的对象</li><li>注册事件-&gt;指向事件源</li><li><em><strong>注意点</strong></em>：箭头函数内部没有自己的this，如果需要使用，浏览器会按照作用域链依次查找，事件源一般推荐用普通的匿名函数</li></ul></li></ol><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><ul><li><p>正常情况下，变量数和单元数应该一致，</p><ul><li>let [one,two,three]&#x3D;[“喜喜”，“哈哈哈”，“嘤嘤嘤”]；</li></ul></li><li><p>特色情况1：变量多，单元数少，没有接收到的数据的变量，默认是undefined</p></li><li><p>特色情况2：变量少，单元数多，没有接收到的数据的变量，多出的会忽略</p></li><li><p>如果需要把多余的参数一起接收，可以使用剩余参数</p></li><li><p>特色情况3：如果不希望变量值为undefined，此时可以给变量设置默认值</p><ul><li>let [x&#x3D;”默认1”，y&#x3D;”默认值2“，z&#x3D;”默认值3“] &#x3D; [”啧啧啧“]</li></ul></li></ul><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><h3 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h3><h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h3 id="字符串扩展和新增方法"><a href="#字符串扩展和新增方法" class="headerlink" title="字符串扩展和新增方法"></a>字符串扩展和新增方法</h3><h3 id="数组扩展-扩展运算符，新增方法"><a href="#数组扩展-扩展运算符，新增方法" class="headerlink" title="数组扩展_扩展运算符，新增方法"></a>数组扩展_扩展运算符，新增方法</h3><ul><li>filter（function（item，index）{return 条件}），数组的方法，用于过滤、筛选</li></ul><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><h3 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h3><h3 id="ASync函数"><a href="#ASync函数" class="headerlink" title="ASync函数"></a>ASync函数</h3><h3 id="Class的基本语法"><a href="#Class的基本语法" class="headerlink" title="Class的基本语法"></a>Class的基本语法</h3><h3 id="Moule模块"><a href="#Moule模块" class="headerlink" title="Moule模块"></a>Moule模块</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端学习笔记</title>
      <link href="/2023/01/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前端学习笔记"><a href="#前端学习笔记" class="headerlink" title="前端学习笔记"></a>前端学习笔记</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>dom是文档对象模型，核心对象是document</p><p>文档：一个页面就是一个文档，DOM中使用document表示</p><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p><p>节点：网页总的所有内容都是节点（标签、属性等），DOM中使用node表示</p><h5 id="获取元素：getElementById（）"><a href="#获取元素：getElementById（）" class="headerlink" title="获取元素：getElementById（）"></a>获取元素：getElementById（）</h5><p>根据ID获取</p><p>script标签要写在标签的下面，因为我们文档页面从上往下加载，所以得先有标签</p><h4 id="操作元素innerHTML和innerText"><a href="#操作元素innerHTML和innerText" class="headerlink" title="操作元素innerHTML和innerText"></a>操作元素innerHTML和innerText</h4><p>innerText不识别html标签</p><p>innerHTML识别html标签，常用innerHTML</p><p>var nowtime &#x3D; +new Date();&#x2F;&#x2F;得到的就是当下的时间距离1970年1月1日0时0分0秒的毫秒数</p><p>var inputTime &#x3D; +new Date(time); &#x2F;&#x2F; 放回的是用户输入时间总的毫秒数</p><h4 id="DOM重点核心"><a href="#DOM重点核心" class="headerlink" title="DOM重点核心"></a>DOM重点核心</h4><p>主要对元素的操作，主要有增删改查（CRUD）、创建元素、元素属性操作、事件操作。</p><h4 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h4><p>onkeyup keyup 按键弹起的时候触发 </p><p>onkeydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊</p><p>onkeypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊</p><p>三个事件的执行顺序  keydown – keypress – keyup</p><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p>BOM即浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window</p><p>width：auto与100%</p><p>当width设置为100%，会等于父元素的width</p><p>当width设置为auto，会根据元素本身的height这个属性决定。简单的说按照height的缩放比例来设置</p><h4 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h4><ul><li><p>块级元素</p><ol><li>独占一行</li><li>宽度默认是父元素的宽度</li><li>可以设置宽高</li><li>例如div、p、h系列、li、ul、dl、dt、dd、form、header、nav、footer等</li></ol></li><li><p>行内元素</p><ol><li>不换行，一行可以显示多个</li><li>宽度和高度默认由内容撑开</li><li>设置宽高不生效</li><li>例如span、a、b、u、i、strong、ins、em、del等</li></ol></li><li><p>行内块元素</p><ol><li>一行可以显示多个</li><li>可以设置宽高</li><li>例如input、textarea、button、select</li><li>特殊清空：img标签由行内块元素特点，但是chrome调试工具显示为行内标签</li></ol></li><li><p>元素显示模式转换</p><ol><li>目的：改变元素默认的显示特点，让元素符合布局要求</li></ol></li></ul><p>扩展1：HTML嵌套规范注意点</p><ol><li><p>块级元素一般作为大容器，可以嵌套文本。块级元素。行内元素、行内块元素等等</p><ul><li>但是p标签中不要嵌套div、p、h等块级元素</li></ul></li><li><p>a标签内部可以嵌套任意元素</p><ul><li>但是a标签不能嵌套a标签</li></ul></li></ol><h3 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h3><h6 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h6><p>一般子元素会继承父元素里的样式，关于文字的样式会继承，但是有些元素会有默认的文字样式所以就没有继承</p><h6 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h6><h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>绝对定位的盒子使用margin不能居中，可以用left百分比写法，再加上margin，或者用transform：translate(-50%，-50%)位移的写法，这样写的好处就是可以自己计算宽高的一半</p><p>相对定位会使标签元素脱标，并且原有位置依然被占用</p><p>定位习惯子绝夫相的写法</p><h5 id="基线对齐"><a href="#基线对齐" class="headerlink" title="基线对齐"></a>基线对齐</h5><p>属性名：vertical-align，默认文字按基线对齐，浏览器默认将行内块和行内标签认定为文字，改变显示模式也可以解决基线问题</p><p>一般解决文字水平方向对不齐的情况，想居中对齐用middle，顶对齐用top，底对齐用bottom</p><h5 id="overflow：hidden"><a href="#overflow：hidden" class="headerlink" title="overflow：hidden"></a>overflow：hidden</h5><p>隐藏盒子溢出部分</p><h5 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility:hidden"></a>visibility:hidden</h5><p>占位隐藏</p><h5 id="display：none"><a href="#display：none" class="headerlink" title="display：none"></a>display：none</h5><p>不占位隐藏</p><p>常用于子菜单显示，不占位隐藏较为常用</p><h5 id="（扩展），透明度"><a href="#（扩展），透明度" class="headerlink" title="（扩展），透明度"></a>（扩展），透明度</h5><ul><li>opacity</li><li>会使内容都变透明，纯写html、css不会用到，一般用rgba(a,b,c,0.5)这种，不会使内容变透明</li></ul><h5 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h5><ul><li>减少服务器发送次数，减轻服务器压力，提高页面加载速度</li><li>精灵图就是将多张小图片合并成一张大图片，这张大图片就叫做精灵图</li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
