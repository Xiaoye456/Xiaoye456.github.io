<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaoye456的个人博客</title>
  
  <subtitle>✌嘻嘻</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-14T13:47:45.129Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Xiaoye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>selenium的学习-（一）</title>
    <link href="http://example.com/2023/09/14/selenium/"/>
    <id>http://example.com/2023/09/14/selenium/</id>
    <published>2023-09-14T13:45:03.000Z</published>
    <updated>2023-09-14T13:47:45.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h1><blockquote><p>id<br>name<br>class_name<br>tag_name<br>link_text<br>partial_link_text<br>Xpath<br>css</p><p>123给予元素属性特有定位方式<br>45基于元素标签内容定位<br>6基于元素路径定位<br>7基于选择器</p></blockquote><hr><h3 id="link-text"><a href="#link-text" class="headerlink" title="link_text"></a>link_text</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.只能定位a标签</span><br><span class="line">2.定位的元素内容必须为全部匹配</span><br></pre></td></tr></table></figure><h3 id="partial-link-text"><a href="#partial-link-text" class="headerlink" title="partial_link_text"></a>partial_link_text</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定位a标签</span><br><span class="line">partial_link_text定位元素的内容可以模糊部分值，但是必须能代表唯一性。假如不具有唯一性，它默认操作符合条件的第一个元素，不报错。</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id,name,class:依赖于元素对应的三个属性，如果元素没有这三个属性，就无法定位。</span><br><span class="line">link_text/partial_link_text只能适合超链接（即a标签）</span><br><span class="line">tag_name:只能找页面唯一元素，或者页面中多个相同元素中的第一个元素（非常不友好,一般页面基本会有很多相同的元素）</span><br></pre></td></tr></table></figure><hr><h3 id="xpath（重点）"><a href="#xpath（重点）" class="headerlink" title="xpath（重点）"></a>xpath（重点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpath依赖于元素的路径定位，是一门在xml文档中查找元素信息的语言。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xpath定位策略</span><br><span class="line">1.路径</span><br><span class="line">2.路径结合属性</span><br><span class="line">//*[@id=&#x27;id值&#x27;]</span><br><span class="line">3.路径结合逻辑（多个属性）</span><br><span class="line">//*[@id=&#x27;id值&#x27; and @属性=&#x27;属性值&#x27;]</span><br><span class="line">4.路径结合层级</span><br><span class="line">//*[@id=&#x27;父级id属性值&#x27;]/input</span><br><span class="line"></span><br><span class="line">提示：一般使用指定标签名称，不使用*代替，效率慢。</span><br><span class="line">无论是绝对还是相对路径，/后面必须为元素的名称或者*</span><br><span class="line">扩展：能使用相对路径绝对不使用绝对路径。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相对路径是//开头，后面也是用/，//后边跟元素名称，不知道元素名称可以用*代替。如：//input 、 //*</span><br><span class="line">绝对路径以/开头,不能跳级，根是html不是document。</span><br><span class="line"></span><br><span class="line">要写元素的属性要以@开头，如：//input[@name=&#x27;aaa&#x27;]</span><br><span class="line">结合多属性用and，如：//input[@name=&#x27;aaa&#x27; and @class=&#x27;login-text&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="xpath扩展"><a href="#xpath扩展" class="headerlink" title="xpath扩展"></a>xpath扩展</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.文本元素定位：//*[text()=&#x27;文本内容&#x27;]</span><br><span class="line">text()=&#x27;文本内容&#x27;</span><br><span class="line">一般适合p、a标签</span><br><span class="line">2.属性值模糊定位：//*[contains(@type,&#x27;password&#x27;)]</span><br><span class="line">语法：//*[contains(@attribute,&#x27;属性值&#x27;)]，属性值可以写部分</span><br><span class="line">contains是关键字，不可更改。</span><br><span class="line">3.属性值开头值定位：//*[starts-with(@type,&#x27;pass&#x27;)]</span><br><span class="line">语法：//*[starts-with(@attriture,&#x27;属性值&#x27;)]，属性值可以写值的开头部分值</span><br><span class="line">starts-with是关键字，不可更改。</span><br></pre></td></tr></table></figure><hr><h3 id="css定位（重点）"><a href="#css定位（重点）" class="headerlink" title="css定位（重点）"></a>css定位（重点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在selenium中推荐使用css定位，因为比xpath定位速度快</span><br><span class="line">主要用css选择器定位</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.id选择器</span><br><span class="line">2.class选择器</span><br><span class="line">3.元素选择器</span><br><span class="line">4.属性选择器</span><br><span class="line">5.层级选择器</span><br></pre></td></tr></table></figure><ol><li>id选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：#id</span><br></pre></td></tr></table></figure><ol start="2"><li>class选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：.class_name</span><br></pre></td></tr></table></figure><ol start="3"><li>元素选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：元素名</span><br></pre></td></tr></table></figure><ol start="4"><li>属性选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：[属性=&quot;属性值&quot;]</span><br><span class="line">任何属性都可以</span><br></pre></td></tr></table></figure><ol start="5"><li>层级选择器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：父级&gt;子级，或者用空格间隔。</span><br><span class="line">提示：&gt;必须为直属子元素，空格不用。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="css扩展"><a href="#css扩展" class="headerlink" title="css扩展"></a>css扩展</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input[type^=&#x27;p&#x27;]   type属性以p字母开头的元素</span><br><span class="line">input[type$=&#x27;d&#x27;]   type属性以d字母结束的元素</span><br><span class="line">input[type*=&#x27;w&#x27;]   type属性包含w字母的元素</span><br></pre></td></tr></table></figure><hr><h1 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h1><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.输入方法</span><br><span class="line">send_keys()</span><br><span class="line">2.点击方法</span><br><span class="line">click()</span><br><span class="line">3.清空方法</span><br><span class="line">clear()</span><br><span class="line"></span><br><span class="line">注意：输入内容之前要清空输入框，不然会在已有内容之后追加</span><br></pre></td></tr></table></figure><h3 id="操作浏览器常用方法"><a href="#操作浏览器常用方法" class="headerlink" title="操作浏览器常用方法"></a>操作浏览器常用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.最大化浏览器窗口</span><br><span class="line">maximize_window()</span><br><span class="line">2.设置浏览器窗口大小</span><br><span class="line">set_window_size(width,height)</span><br><span class="line">3.设置浏览器窗口位置</span><br><span class="line">set_window_position(x,y)</span><br><span class="line">4.后退</span><br><span class="line">back（）</span><br><span class="line">5.前进</span><br><span class="line">forward（）</span><br><span class="line">6.刷新</span><br><span class="line">refresh()</span><br><span class="line">7.关闭当前窗口（只关闭当前主窗口，默认启动哪个界面，哪个就是主窗口）</span><br><span class="line">close()</span><br><span class="line">8.关闭浏览器驱动对象(关闭由驱动对象打开的全部窗口)</span><br><span class="line">quit()</span><br><span class="line">9.获取页面title</span><br><span class="line">title</span><br><span class="line">10.获取当前页面URL</span><br><span class="line">current_url</span><br></pre></td></tr></table></figure><h3 id="获取元素信息常用方法"><a href="#获取元素信息常用方法" class="headerlink" title="获取元素信息常用方法"></a>获取元素信息常用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.返回元素大小</span><br><span class="line">size</span><br><span class="line">2.获取元素文本</span><br><span class="line">text</span><br><span class="line">3.获取属性值，传递的参数为元素的属性名</span><br><span class="line">get_attribute(&#x27;xxx&#x27;)</span><br><span class="line">4.判断元素是否可见</span><br><span class="line">is_displayed()</span><br><span class="line">5.判断元素是否可用</span><br><span class="line">is_enabled()</span><br><span class="line">6.判断元素是否选中，用来检查复选框或单选按钮是否被选中</span><br><span class="line">is_selected()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在selenium中将操作鼠标的方法封装在ActionChains类中</span><br><span class="line">实例化对象：</span><br><span class="line">action = ActionChains(driver)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">1.鼠标右击</span><br><span class="line">context_click(element)</span><br><span class="line">2.双击</span><br><span class="line">double_click(element)</span><br><span class="line">3.拖动</span><br><span class="line">drag_and_drop(source,target)</span><br><span class="line">4.悬停</span><br><span class="line">move_to_element(element)</span><br><span class="line">5.执行以上鼠标操作</span><br><span class="line">perform()</span><br><span class="line"></span><br><span class="line">注意：selenium虽然提供了右击鼠标方法，但是没有提供选中右击菜单方法，右击出来的浏览器菜单是点不了的。。。。。。</span><br></pre></td></tr></table></figure><h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.删除键（backspace）</span><br><span class="line">send_keys(Keys.BACK_SPACE)</span><br><span class="line">2.空格键（space）</span><br><span class="line">send_keys(Keys.SPACE)</span><br><span class="line">3.制表键（tab）</span><br><span class="line">send_keys(Keys.TAB)</span><br><span class="line">4.回退键（esc）</span><br><span class="line">send_keys(Keys.ESC)</span><br><span class="line">5.回车键（enter）</span><br><span class="line">send_keys(Keys.ENTER)</span><br><span class="line">6.全选（Ctrl+A）</span><br><span class="line">send_keys(Keys.CONTROL,&#x27;a&#x27;)</span><br><span class="line">7.复制（Ctrl+C）</span><br><span class="line">send_keys(Keys.CONTROL,&#x27;c&#x27;)</span><br></pre></td></tr></table></figure><h3 id="元素等待"><a href="#元素等待" class="headerlink" title="元素等待"></a>元素等待</h3><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法：driver.implicitly_wait(timeout)</span><br><span class="line">说明：隐式等待为全局设置（只需要设置一次，就会作用于所有元素）</span><br></pre></td></tr></table></figure><h4 id="显示等待-重点"><a href="#显示等待-重点" class="headerlink" title="显示等待(重点)"></a>显示等待(重点)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法：WebDriverWait(driver,timeout,poll_frequency=0.5)</span><br><span class="line">1.driver:浏览器驱动对象</span><br><span class="line">2.timeout：超时的时长，单位为秒</span><br><span class="line">3.poll_frequency:检测间隔时间，默认为0.5秒</span><br><span class="line">调用方法：until（method）：直到...时</span><br><span class="line">method：函数名称，该函数用来实现对元素的定位</span><br><span class="line">一般使用匿名函数来实现：lambda x:x.find_element_by_id(&#x27;userA&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待，如果不能定位到该元素，则间隔一段时间后再去定位元素，如果在达到最大时长时还没有找到指定元素，则抛出超时异常TimeoutException.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">操作：</span><br><span class="line">1.实例化WebDriverWait（）类并调用until（method）方法</span><br><span class="line">method：写匿名函数，如lambada x:x.find_element_by_id()</span><br><span class="line">x为driver，它是webDriverWait类将传入的driver赋值给了类self._driver,until方法调用了self.driver;</span><br><span class="line">timeout为超时时间</span><br><span class="line">poll_frequency为访问频率，默认0.5s找一次元素</span><br></pre></td></tr></table></figure><h2 id="切换frame-iframe"><a href="#切换frame-iframe" class="headerlink" title="切换frame&#x2F;iframe"></a>切换frame&#x2F;iframe</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原因：不切换frame会导致元素找不到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切换方法：driver.switch_to.frame()</span><br><span class="line">切回默认主页面：driver.switch_to.default_content()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多窗口切换"><a href="#多窗口切换" class="headerlink" title="多窗口切换"></a>多窗口切换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明：在HTML页面中，当点击超链接或者按钮时，有的会在新的窗口打开页面。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">1) driver.current_window_handle ---获取当前窗口句柄</span><br><span class="line">2) driver.window_handles ---获取所有窗口句柄</span><br><span class="line">3) driver.switch_to.window(handle) ---切换指定句柄窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">应用场景：失败时截图，让错误看的更直观</span><br><span class="line">方法：driver.get_screenshot_as_file（imgagepath）</span><br><span class="line">imagepath：为图片保存地址</span><br></pre></td></tr></table></figure><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录cookie进行跳过验证码登录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cookie是由web服务器生成的，并且保存在用户浏览器上的小文本文件，它可以包含用户相关的信息。</span><br><span class="line">cookie数据格式：键值对组成</span><br><span class="line">cookie的生成：客户端请求服务器，如果服务器需要记录该用户状态，就向客户端颁发一个cookie，客户端浏览器会自动记录下cookie，在下一次请求中会将cookie信息自动附加在请求中。</span><br><span class="line">cookie使用：当浏览器再次请求该网站时，浏览器把请求的数据和cookie数据一同提交给服务器，服务器检查该cookie，以此来辨认用户状态。</span><br></pre></td></tr></table></figure><h2 id="Selenium操作cookie"><a href="#Selenium操作cookie" class="headerlink" title="Selenium操作cookie"></a>Selenium操作cookie</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">1、get_cookie(name)  --&gt;获取指定cookie，name为cookie名称</span><br><span class="line">2、get_cookies() --&gt;获取本网站所有本地cookies</span><br><span class="line">3、add_cookie(cookie_dict)  --&gt;添加cookie</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;元素定位&quot;&gt;&lt;a href=&quot;#元素定位&quot; class=&quot;headerlink&quot; title=&quot;元素定位&quot;&gt;&lt;/a&gt;元素定位&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;id&lt;br&gt;name&lt;br&gt;class_name&lt;br&gt;tag_name&lt;br&gt;link_text</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>API测试</title>
    <link href="http://example.com/2023/09/14/API%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2023/09/14/API%E6%B5%8B%E8%AF%95/</id>
    <published>2023-09-14T13:45:00.000Z</published>
    <updated>2023-09-14T13:46:09.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="postman基础使用"><a href="#postman基础使用" class="headerlink" title="postman基础使用"></a>postman基础使用</h3><ul><li>postman建立collection管理用例</li><li>导出用例集</li><li>导入用例集</li></ul><h3 id="postman断言"><a href="#postman断言" class="headerlink" title="postman断言"></a>postman断言</h3><ul><li>Status code: Code is 200（是否返回码为200）</li><li>Response body : Contains string(是否包含某个指定的字符串)</li><li>Response body:JSON value check（）</li><li>Response body : is equal to a string（）</li></ul><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><ul><li>全局变量：pm.globals.set(“var_name”,value);</li><li>环境变量：pm.environment.set(“en_name”,value);</li></ul><h4 id="获取变量值"><a href="#获取变量值" class="headerlink" title="获取变量值"></a>获取变量值</h4><ul><li>全局变量<ol><li>请求参数中获取：</li><li>代码中获取：var value &#x3D; pm.globals.get(“var_name”)</li></ol></li><li>环境变量<ol><li>请求参数中获取：</li><li>代码中获取：var value &#x3D; pm.environment.get(“var_name”)</li></ol></li></ul><h3 id="postman关联"><a href="#postman关联" class="headerlink" title="postman关联"></a>postman关联</h3><blockquote><p>应用于多个http请求之间，有数据关联，或依赖关系时。</p></blockquote><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>A接口依赖于B接口的数据</p><ol><li>向B接口发送http请求，获取数据</li><li>将数据设置至全局变量中</li><li>A接口获取全局变量中数据值，进行使用。</li></ol><h3 id="newman插件生成测试报告"><a href="#newman插件生成测试报告" class="headerlink" title="newman插件生成测试报告"></a>newman插件生成测试报告</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newman run 测试脚本文件 -e 环境变量文件 -d 测试数据文件 -r html --reporter-html-export report.html</span><br></pre></td></tr></table></figure><h3 id="postman读取外部文件（参数化）"><a href="#postman读取外部文件（参数化）" class="headerlink" title="postman读取外部文件（参数化）"></a>postman读取外部文件（参数化）</h3><blockquote><p>当http请求，使用的数据有较高相似度时，相同的请求时，考虑使用参数化（将数据组织到数据文件中）</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>第一种：</li><li>第二种：代码里用：data.字段名</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;postman基础使用&quot;&gt;&lt;a href=&quot;#postman基础使用&quot; class=&quot;headerlink&quot; title=&quot;postman基础使用&quot;&gt;&lt;/a&gt;postman基础使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;postman建立collection管理用例&lt;/li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>K8S的浅要认知</title>
    <link href="http://example.com/2023/09/14/K8S/"/>
    <id>http://example.com/2023/09/14/K8S/</id>
    <published>2023-09-14T07:29:03.000Z</published>
    <updated>2023-09-14T13:49:14.556Z</updated>
    
    <content type="html"><![CDATA[<ul><li>DaemonSet</li></ul><blockquote><p>适合监控、日志等任务</p></blockquote><ul><li>Deployment</li></ul><blockquote><p>管理Pod</p></blockquote><ul><li>StatefulSets</li><li>Jobs</li><li>CustomObjects</li><li>Serivce</li></ul><blockquote><p>负责将服务提供给同一个集群内的其他服务使用</p><p>serivce是一个完全虚拟的网络层，通过修改集群内部的路由规则，仅对集群内部有效。</p></blockquote><ul><li>ingress</li></ul><blockquote><p>对集群外提供服务</p></blockquote><ul><li>Pod</li></ul><blockquote><p>Pod处理多个容器之间的关系</p><p>同一个Pod内的容器可以共享很多信息，也可能需要读取同一份配置</p><p>相关的配置信息写在ConfigMap里，敏感信息写在Secret中</p></blockquote><ul><li>Helm</li></ul><blockquote><p>Helm 是 Kubernetes 的一个包管理工具，用来简化应用的部署和管理。可以把 Helm 比作 CentOS 的 yum 工具。</p></blockquote><p>容器技术（代表：docker）</p><p>容器技术主要利用linux中的两种机制：namespace与cgroups机制</p><p>隔离技术：利用namespace技术营造出一种各自为营的环境，可以使每个容器只看到自己里面的情况。</p><p>资源限制：利用cgroups限制一个进程组能够使用的资源上限。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;DaemonSet&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;适合监控、日志等任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;管理Pod&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>最近的一些学习</title>
    <link href="http://example.com/2023/09/14/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/09/14/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-14T07:29:03.000Z</published>
    <updated>2023-09-14T13:51:33.573Z</updated>
    
    <content type="html"><![CDATA[<ol><li>T1测试：一般是对于基层版本的更新点的一个测试，一般存在于协助开发一个项目的情况，合并代码时会保留一部分基版本更新的一些功能点，这时就得对于这部分功能点进行测试，这些测试就是T1测试，基于这些功能编写的测试点也叫T1测试点。</li><li>T2测试：有T1测试情况才会有T2测试的一种叫法，其实就是对于自己直接负责的这个项目的需求进行测试的点。</li><li>PRD文档：也就是需求分析文档，有Ctest（协助开发平台）的情况下一般就是Ctest平台中产品上传的一些需求项。</li></ol><p>一般测试点&#x2F;测试用例的编写是基于需求项和UI提供的设计稿的。</p><p>如果是新开的项目，一般流程为：TR1（项目需求的一些梳理及项目立项）–&gt;TR2（需求评审，就是三方在场看看需求合不合理）–&gt;TR3（技术评估，就是前后端对需求实现的一些技术预研以及开发所用技术的一些讲解，还有此时也是测试的测试方案的讲解及输出，一般没有要求的话是没有测试计划的单独编写的，这样是为了减轻测试的一个工作量）–&gt;TR4（目前还没参与，不清楚情况）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在TR3之后一般第二天就会出开发的排期以及提测时间，测试用例的评审呢一般是在产品体验前一周就应该发起，100条测试用例以内的一般是用例评审，100条外的一般是测试点评审。测试用例评审完后需要输出用例评审缺陷表，简单的说就是统计评审过程中哪些用例被修改和被删除。产品体验完后就会发起提测，测试这时就得进行一个系统测试，测试完后呢就得输出一个测试反馈表，然后TR4会出一个测试报告</span><br></pre></td></tr></table></figure><h3 id="测试点的编写："><a href="#测试点的编写：" class="headerlink" title="测试点的编写："></a>测试点的编写：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试点编写最好是先从主要的功能模块入手，然后先写业务主流程的正向测试点，然后再写逆向，还有剩余的就再加个操作的分级以及UI，其实测试点的编写大方向应该是从操作和显示入手，如何操作呢又可以分为正向和逆向，显示呢其实也就是UI层面的东西，这部分的优先级一般是P2，主流程一律为P0级，主流程不通的话往下也测不了。另外研发的自测用例可以从已经编写好的用例中抽出主流程用例来作为研发自测用例，一般是给p0级用例给开发测。</span><br></pre></td></tr></table></figure><h3 id="接口测试的一个学习："><a href="#接口测试的一个学习：" class="headerlink" title="接口测试的一个学习："></a>接口测试的一个学习：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.打开需要抓包的网页</span><br><span class="line">2.打开浏览器f12</span><br><span class="line">3.选择network</span><br><span class="line">4.操作网页执行动作</span><br><span class="line">5.查看接口的请求报文和响应报文</span><br><span class="line"></span><br><span class="line">一般是在headers看，headers有三个下拉框：General(概要，里面有请求地址、状态码、请求方式)，Response Headers(响应头)，Request Headers(请求头)</span><br><span class="line"></span><br><span class="line">发送请求需要有请求URL，请求方式，请求体</span><br></pre></td></tr></table></figure><p><img src="Users\Lenovo\Desktop\图片\image-20230803171756040.png" alt="image-20230803171756040"></p><h4 id="接口用例的编写："><a href="#接口用例的编写：" class="headerlink" title="接口用例的编写："></a>接口用例的编写：</h4><ol><li><p>接口用例设计方法</p><ol><li>单接口测试</li></ol><ul><li>正向测试<ul><li>必选参数：所有必选都包含</li><li>必选+任意一个或多个非必选</li><li>全部参数：所有的必选+所有的可选参数</li></ul></li><li>反向测试<ul><li>多参：多出一个或多个必选参数</li><li>少参：缺少一个或多个必选参数</li><li>无参：没有必选参数</li><li>错误参数：参数名输入错误</li></ul></li></ul><ol><li>业务场景测试（多接口）</li></ol><ul><li>针对业务功能用例中操作步骤，分析对应的接口请求</li></ul></li></ol><h4 id="接口测试10要素："><a href="#接口测试10要素：" class="headerlink" title="接口测试10要素："></a>接口测试10要素：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编号、用例标题、模块、优先级、预置条件、请求方法、URL、请求头、请求体、预期结果</span><br></pre></td></tr></table></figure><p>接口测试测试点分析与功能测试相同</p><h3 id="对于python深浅拷贝的认知和学习"><a href="#对于python深浅拷贝的认知和学习" class="headerlink" title="对于python深浅拷贝的认知和学习"></a>对于python深浅拷贝的认知和学习</h3><blockquote><p>深浅拷贝主要是对python中copy模块中的copy()和deepcopy()的用法</p></blockquote><ul><li>这里先总结下深拷贝（深拷贝较好理解）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深拷贝其实就是完全拷贝，可以理解为复制出来了一份新的东西，与原先的值完全无瓜葛，内存的地址是完全不一样的（即id()不同），无论改变深拷贝之后的值还是拷贝的值都不会互相影响。</span><br></pre></td></tr></table></figure><ul><li><p>接下来说说浅拷贝（浅拷贝需要分可变类型和不可变类型）</p><ul><li>可变类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python的可变类型有列表、字典、集合。</span><br></pre></td></tr></table></figure><ul><li>不可变类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python的不可变类型有字符串、元组、数值。</span><br></pre></td></tr></table></figure><ul><li>不可变类型的浅拷贝</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不可变类型的浅拷贝是和赋值一样的，拷贝的变量和被拷贝的变量id()一样。也就是改变值会互相影响</span><br></pre></td></tr></table></figure><ul><li>可变类型的浅拷贝（无嵌套复杂子对象）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可变类型的浅拷贝也是分两种情况，首先说说第一种，无嵌套复杂子对象的情况。如：l = [1,2,3,4]</span><br><span class="line">这种时候浅拷贝的变量和被拷贝的变量的id()是不一样的，也就是改变值不会互相影响</span><br></pre></td></tr></table></figure><ul><li>可变类型的浅拷贝（有嵌套复杂子对象）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二种情况是有嵌套复杂子对象，如：l = [1，2，3，[1,2]]</span><br><span class="line">这种情况只要浅拷贝的变量或者被拷贝的变量对复杂子对象的值即l[3]进行变更，那么都会影响到另一个变量。对外面一层即l[0]、l[1]、l[2]这些值进行变更就不会影响另外的变量。</span><br></pre></td></tr></table></figure></li></ul><h3 id="Linux一些命令的学习"><a href="#Linux一些命令的学习" class="headerlink" title="Linux一些命令的学习"></a>Linux一些命令的学习</h3><ul><li>查看GPU</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navi</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;T1测试：一般是对于基层版本的更新点的一个测试，一般存在于协助开发一个项目的情况，合并代码时会保留一部分基版本更新的一些功能点，这时就得对于这部分功能点进行测试，这些测试就是T1测试，基于这些功能编写的测试点也叫T1测试点。&lt;/li&gt;
&lt;li&gt;T2测试：有T1测</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重温python</title>
    <link href="http://example.com/2023/09/08/python%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/09/08/python%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-08T07:29:03.000Z</published>
    <updated>2023-09-14T13:48:29.377Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python特点"><a href="#Python特点" class="headerlink" title="Python特点"></a>Python特点</h3><ol><li>解释型语言,运行速度慢，代码要一行一行解释成机器码运行，编译型语言（C语言）在运行前就转换成机器码，所以非常快。</li><li>简单、代码量少。</li><li>代码透明，不能加密，这是解释型语言的特点。</li></ol><h3 id="Python语法"><a href="#Python语法" class="headerlink" title="Python语法"></a>Python语法</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li>逻辑运算符：and not or</li><li>算术运算符：&#x2F;(精确除法，结果为浮点数)，&#x2F;&#x2F;（结果向下取整），%（结果取余数）</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>可变类型：列表，字典</li><li>不可变类型：元组，字符串，数字</li></ul><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ol><li>append（）添加元素</li><li>insert（index，value），第一个参数填写要插入的索引号，第二个参数是要插入的值</li><li>pop（）删除末尾的元素，pop（index）删除指定索引位置的值，均会返回被删除的值</li><li>列表拼接可以直接用+</li></ol><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><ol><li>元组没有列表对元素进行变更的方法，因为tuple不可变，其他获取元素的方法和list一样。</li><li>要定义元组可以用以下方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = （1，2） #定义2个元素的tuple</span><br><span class="line">t = （）#定义空的tuple</span><br><span class="line">t = （1，） #定义一个元素的tuple，要在元素后加逗号，以此来消除数学括号带来的歧义。</span><br></pre></td></tr></table></figure><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;michael&#x27;:95,&#x27;Bob&#x27;:&#x27;75&#x27;&#125;</span><br><span class="line">key in d,判断key是否存在，或者用d.get(key),key不存在返回None，存在返回对应的value</span><br><span class="line">d.pop(key)删除对应的key和value，dict中的key是不可变对象。在python中字符串、整数等都是不可变的，因此，可以放心作为key。而list是可变的，就不能作为key。</span><br></pre></td></tr></table></figure><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">要创建一个set，需要提供一个list作为输入集合：s = set([1,2,3])</span><br><span class="line">添加元素：add(key),可以重复添加，但不会有效果</span><br><span class="line">删除元素：remove(key)</span><br><span class="line">set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</span><br><span class="line">s1 = set([1, 2, 3])</span><br><span class="line">s2 = set([2, 3, 4])</span><br><span class="line">s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</span><br></pre></td></tr></table></figure><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if addition ：</span><br><span class="line">代码块</span><br><span class="line">else：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if addition :</span><br><span class="line">代码块</span><br><span class="line">elif addition :</span><br><span class="line">代码块</span><br><span class="line">else :</span><br><span class="line">代码块</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for...in循环，依次把list或tuple中的每个元素迭代出来</span><br><span class="line">for l in lis ：</span><br><span class="line">代码块</span><br><span class="line">while循环，只要条件满足，就不断循环，条件不满足时退出循环。</span><br><span class="line">while n &gt; 0:</span><br><span class="line">   代码块</span><br><span class="line">break，在循环中，break语句可以提前退出循环。</span><br><span class="line">continue,跳出当前的循环，直接开始下一次的循环</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一是必选参数在前，默认参数在后，否则Python的解释器会报错。</span><br><span class="line">定义默认参数要牢记一点：默认参数必须指向不变对象！</span><br><span class="line">可变参数*args，参数args接收到的是一个元组。</span><br><span class="line">关键字参数**kwargs，这些关键字参数在函数内部自动组装为一个dict。</span><br></pre></td></tr></table></figure><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = [1,2,3,4]</span><br><span class="line">l[0:3]表示从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</span><br><span class="line">如果第一个索引是0还可以简写成：l[:3]。</span><br><span class="line">也可以从索引1开始，如：l[1:3]。</span><br><span class="line">这种切片操作理解为左闭右开就好了。</span><br><span class="line">[::2]这种操作表示每隔2个取1个。</span><br><span class="line">tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。</span><br><span class="line">字符串&#x27;xxx&#x27;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串。</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</span><br><span class="line">默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。</span><br></pre></td></tr></table></figure><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[s for s in str]</span><br></pre></td></tr></table></figure><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这种一边循环一边计算的机制，称为生成器：generator。</span><br><span class="line">要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()。</span><br><span class="line">g = (x for x in range(1,11))</span><br><span class="line">通过next()获取generator的下一个返回值，当然，一个个调用next（）不是很现实，可以用for循环，因为generator也是可迭代对象</span><br><span class="line">一般定义一个generator函数可以在里面加yield（作用相当于return，可以当函数使用，返回参数，下次用next（）调用同个generator对象的时候，从上次执行到的yield位置继续执行）。如：</span><br><span class="line">def odd():</span><br><span class="line">    print(&#x27;step 1&#x27;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&#x27;step 2&#x27;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&#x27;step 3&#x27;)</span><br><span class="line">    yield(5)</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">凡是可作用于for循环的对象都是Iterable类型；</span><br><span class="line"></span><br><span class="line">凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</span><br><span class="line">集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</span><br><span class="line"></span><br><span class="line">Python的for循环本质上就是通过不断调用next()函数实现的</span><br></pre></td></tr></table></figure><h4 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h4><h5 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关键字lambda表示匿名函数，冒号前面的x表示函数参数。</span><br><span class="line"></span><br><span class="line">匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</span><br><span class="line"></span><br><span class="line">用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</span><br></pre></td></tr></table></figure><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包是用来组织模块，避免相同模块名冲突。包的下面会有一个__init__.py文件，它可以是一个空文件，这样python就会把这个目录当成一个包。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Python特点&quot;&gt;&lt;a href=&quot;#Python特点&quot; class=&quot;headerlink&quot; title=&quot;Python特点&quot;&gt;&lt;/a&gt;Python特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;解释型语言,运行速度慢，代码要一行一行解释成机器码运行，编译型语言（C语言）在运</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>conda和django的学习</title>
    <link href="http://example.com/2023/08/25/conda&amp;&amp;django%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/08/25/conda&amp;&amp;django%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-08-25T07:29:03.000Z</published>
    <updated>2023-09-14T13:46:51.896Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>pip下载出现SSL连接超时问题可以在下载第三方库后面指定镜像：</p><blockquote><p>-i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p></blockquote></li><li><p>配置selenium：先下载selenium</p></li></ol><blockquote><p>pip install selenium -i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com –ignore-installed</p></blockquote><ol start="3"><li><p>下载对应浏览器版本的浏览器驱动</p></li><li><p>将浏览器驱动放置与python解释器一个目录下</p></li></ol><hr><p>添加Anaconda的TUNA镜像</p><blockquote><p>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></p></blockquote><blockquote><p>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</a></p></blockquote><blockquote><p>conda config –set show_channel_urls yes</p></blockquote><p>创建一个3.6版本的python环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name py36 python=3.6</span><br></pre></td></tr></table></figure><p>创建一个2.7版本的python环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name py27 python=2.7</span><br></pre></td></tr></table></figure><p>在window上使用activate激活环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate py36</span><br></pre></td></tr></table></figure><p>在Linux &amp; Mac中使用source activate激活</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate py36</span><br></pre></td></tr></table></figure><p>激活后，会发现terminal输入的地方多了(py34)的字样，这表示我们已经进入了py34的环境中。</p><ul><li>退出环境</li></ul><p>在windows环境下使用deactivate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>在Linux &amp; Mac中使用source deactivate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source deactivate</span><br></pre></td></tr></table></figure><ul><li>删除环境</li></ul><p>如果你不想要这个名为py36的环境，可以通过以下命令删除这个环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n py36 --all</span><br></pre></td></tr></table></figure><p>可以通过以下命令查看已有的环境列表，现在py34已经不在这个列表里，所以我们知道它已经被删除了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br></pre></td></tr></table></figure><ul><li>查看已安装的包</li></ul><p>使用这条命令来查看在当前环境中，已安装的包和对应版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><ul><li>查看可安装的包</li></ul><p>我们可以通过search命令检查pandas这个包是否可以通过conda来安装</p><p>命令返回了这个包的信息，所以是可以通过conda安装的</p><p>我们可以通过<!--search-->命令检查pandas这个包是否可以通过conda来安装</p><p> #命令返回了这个包的信息，所以是可以通过conda安装的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search pandas</span><br></pre></td></tr></table></figure><ul><li>安装包</li></ul><p>如果pandas已经存在于环境中，会提示已经安装，否则在提示proceed ([y]&#x2F;n)? 中输入y进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pandas</span><br></pre></td></tr></table></figure><ul><li>更新包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update pandas</span><br></pre></td></tr></table></figure><ul><li>卸载包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove pandas</span><br></pre></td></tr></table></figure><p>conda将conda、python等都视为包，因此，完全可以使用conda来管理conda和python的版本</p><ul><li>更新python</li></ul><p>例如我们所启用的环境是py34，使用的是python3.6,那么conda会将python升级为3.6.x系列中的最新版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update python </span><br></pre></td></tr></table></figure><blockquote><p>selenium自动化需要设置等待时间，给予网页元素显现出来，不然会报错</p></blockquote><hr><ul><li><p>定义变量不需要用上$符号</p></li><li><p>使用一个已经定义过的变量需要用${变量名}。</p></li><li><p>删除变量使用unset var_name</p></li><li><p>shell中只有字符串和数字两种变量，其中字符串可以单引号或者双引号</p><ul><li><p>单引号中任何字符都会原样输出，单引号字符串中的变量是无效的</p></li><li><p>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p></li><li><p>双引号里可以有变量，可以出现转义字符</p></li></ul></li><li><p>$</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;pip下载出现SSL连接超时问题可以在下载第三方库后面指定镜像：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-i &lt;a href=&quot;http://pypi.douban.com/simple&quot;&gt;http://pypi.douban.com/simple&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>selenium的学习(一)</title>
    <link href="http://example.com/2023/07/23/selenium%E7%9A%84%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <id>http://example.com/2023/07/23/selenium%E7%9A%84%E5%AD%A6%E4%B9%A0-%E4%B8%80/</id>
    <published>2023-07-23T12:50:56.000Z</published>
    <updated>2023-07-23T13:54:34.482Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selenium的send_keys（）可以上传文件，参数填文件路径即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">今日学习目标：</span><br><span class="line">1.下拉选择框</span><br><span class="line">2.弹出框</span><br><span class="line">3.滚动条操作</span><br><span class="line">4.frame表单切换</span><br><span class="line">5.多窗口切换</span><br><span class="line">6.窗口截图、验证码处理</span><br></pre></td></tr></table></figure><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><h4 id="Select类操纵select元素"><a href="#Select类操纵select元素" class="headerlink" title="Select类操纵select元素"></a>Select类操纵select元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.导入Select包</span><br><span class="line">2.实例化Select对象</span><br><span class="line"></span><br><span class="line">注意：Select类是通过select标签来控制其下的option元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">通过索引切换</span><br><span class="line">select_by_index()</span><br><span class="line">通过属性value值切换</span><br><span class="line">select_by_value()</span><br><span class="line">通过显示文本切换</span><br><span class="line">select_by_visible_text()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以直接用css方法定位</span><br></pre></td></tr></table></figure><h3 id="弹出框处理"><a href="#弹出框处理" class="headerlink" title="弹出框处理"></a>弹出框处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见的弹出框：</span><br><span class="line">1.警告框alert</span><br><span class="line">2.确认框confirm</span><br><span class="line">3.提示框prompt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">不处理掉弹出框的话，下面的操作会不生效</span><br><span class="line"></span><br><span class="line">如何处理？</span><br><span class="line">以上三种弹出框处理方法一样</span><br><span class="line">步骤：</span><br><span class="line">1.切换到对话框</span><br><span class="line">方法：driver.switch_to.alert默认返回的是alert对话框的对象</span><br><span class="line">2.处理对话框</span><br><span class="line">alert.text 获取文本</span><br><span class="line">alert.accept 同意</span><br><span class="line">alert.dismiss 取消</span><br><span class="line"></span><br><span class="line">提示：无论以上哪个对话框，都可以使用取消、同意；因为调用的是后台的事件，跟页面显示的按钮数量无关。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.driver.switch_to.alert 方法适合以上三种类型对话框，调用时没有括号</span><br><span class="line">2.获取文本的方法，调用时没有括号，如：alert.text</span><br><span class="line">3.在项目中不是所有的小窗口都是以上三种对话框。</span><br></pre></td></tr></table></figure><h3 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于前端技术框架的原因，现在的页面元素基本为动态显示。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.设置js脚本控制滚动条</span><br><span class="line">js = “window.scrollTo(0,1000)”</span><br><span class="line">(0:左边距,1000:上边距)</span><br><span class="line">2.selenium调用执行js脚本的方法</span><br><span class="line">driver.execute_script(js) </span><br></pre></td></tr></table></figure><h3 id="Frame切换-多窗口切换"><a href="#Frame切换-多窗口切换" class="headerlink" title="Frame切换&#x2F;多窗口切换"></a>Frame切换&#x2F;多窗口切换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试（五）--web自动化测试</title>
    <link href="http://example.com/2023/07/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%94%EF%BC%89-web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2023/07/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%94%EF%BC%89-web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2023-07-16T08:29:02.000Z</published>
    <updated>2023-07-16T09:17:17.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动化测试能解决什么问题？"><a href="#自动化测试能解决什么问题？" class="headerlink" title="自动化测试能解决什么问题？"></a>自动化测试能解决什么问题？</h2><ol><li>回归测试（重点）</li><li>压力测试</li><li>兼容性测试（1、浏览器 ，2、分辨率，3、操作系统）</li></ol><h2 id="什么Web项目适合做自动化测试？"><a href="#什么Web项目适合做自动化测试？" class="headerlink" title="什么Web项目适合做自动化测试？"></a>什么Web项目适合做自动化测试？</h2><ol><li>需求变动不频繁</li><li>项目周期长</li><li>项目需要回归测试</li></ol><h2 id="Web自动化测试在什么阶段开始？"><a href="#Web自动化测试在什么阶段开始？" class="headerlink" title="Web自动化测试在什么阶段开始？"></a>Web自动化测试在什么阶段开始？</h2><p>功能测试完毕（手动测试之后），1是时间问题，2是手工测试的时候功能还不完善。</p><h2 id="Web自动化测试所属分类"><a href="#Web自动化测试所属分类" class="headerlink" title="Web自动化测试所属分类"></a>Web自动化测试所属分类</h2><ol><li>黑盒测试（功能测试）</li><li>白盒测试（单元测试）</li><li>灰盒测试（接口测试）</li></ol><blockquote><ol><li><p>以上分类是站在代码可见度上划分</p></li><li><p>web自动化测试属于黑盒测试</p></li></ol></blockquote><h2 id="自动化测试分类"><a href="#自动化测试分类" class="headerlink" title="自动化测试分类"></a>自动化测试分类</h2><ol><li>Web自动化测试</li><li>移动自动化测试（app自动化）</li><li>接口自动化（可以用工具或者代码实现）</li><li>单元测试</li></ol><h2 id="主流的web自动化测试工具"><a href="#主流的web自动化测试工具" class="headerlink" title="主流的web自动化测试工具"></a>主流的web自动化测试工具</h2><ol><li>qtp（收费）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">支持web、桌面自动化测试</span><br></pre></td></tr></table></figure><ol><li>selenium（免费）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个开源的web自动化测试工具，主要做功能测试</span><br></pre></td></tr></table></figure><ol><li>robot framework</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个基于python可扩展的关键字驱动的测试自动化框架（已淘汰）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自动化测试能解决什么问题？&quot;&gt;&lt;a href=&quot;#自动化测试能解决什么问题？&quot; class=&quot;headerlink&quot; title=&quot;自动化测试能解决什么问题？&quot;&gt;&lt;/a&gt;自动化测试能解决什么问题？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;回归测试（重点）&lt;/li&gt;
&lt;li&gt;压力</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试（四）--阶段性总结</title>
    <link href="http://example.com/2023/07/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89-%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/07/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89-%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-15T14:07:57.000Z</published>
    <updated>2023-07-30T14:58:59.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><blockquote><p>功能测试阶段主要是用例的编写，测试点的提取。</p></blockquote><ul><li>测试点主要可以根据需求分为功能和非功能两点来编写，额外的功能模块可以通过显示与操作两点来提取。</li><li>功能方面就是一些功能性的模块，如输入框，列表，表单之类的。</li><li>非功能一般是兼容性，如浏览器兼容性，操作系统兼容性，或者还有安全测试等方面。</li><li>缺陷的判断主要根据需求、原型图、以及用户体验等等方面。</li><li>写测试点的时候比较熟悉的情况下可以之间按正向逆向划分编写，正向即有效等价类，逆向即无效等价类，统计用例数量的时候，正向一般按最多的算，而逆向呢就是每一条逆向测试点都算一条测试用例。</li><li>测试用例编写首先要先编写业务用例，其次才是编写单功能用例</li><li>如何保证设计用例最大可能覆盖需求？<ul><li>先功能<ul><li>覆盖面：正向、逆向</li><li>操作：1、提取测试点，2、编写用例覆盖测点</li></ul></li><li>后非功能<ul><li>易用性、兼容性、安全性等等</li></ul></li></ul></li></ul><blockquote><p>下个阶段为web自动化测试的学习。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;功能测试&quot;&gt;&lt;a href=&quot;#功能测试&quot; class=&quot;headerlink&quot; title=&quot;功能测试&quot;&gt;&lt;/a&gt;功能测试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;功能测试阶段主要是用例的编写，测试点的提取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试（三）-缺陷</title>
    <link href="http://example.com/2023/07/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BC%BA%E9%99%B7/"/>
    <id>http://example.com/2023/07/09/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89-%E7%BC%BA%E9%99%B7/</id>
    <published>2023-07-09T03:46:18.000Z</published>
    <updated>2023-07-16T09:12:20.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><blockquote><p>定义：软件中存在的各种问题，都为缺陷，简称bug。</p></blockquote><h3 id="缺陷标准"><a href="#缺陷标准" class="headerlink" title="缺陷标准"></a>缺陷标准</h3><ol><li>少功能</li><li>功能错误</li><li>多功能</li><li>缺少隐形功能</li><li>易用性（软件测试人员专业角度）</li></ol><h3 id="缺陷产生的原因"><a href="#缺陷产生的原因" class="headerlink" title="缺陷产生的原因"></a>缺陷产生的原因</h3><ol><li>需求文档</li><li>架构设计</li><li>编码实现</li><li>环境（硬件、软件）</li></ol><h3 id="缺陷类型"><a href="#缺陷类型" class="headerlink" title="缺陷类型"></a>缺陷类型</h3><ol><li>功能错误</li><li>UI页面错误</li><li>兼容性</li><li>数据库</li><li>易用性</li><li>建议</li><li>架构缺陷</li></ol><ul><li>工作流程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设计用例-&gt;执行用例（执行测试）-&gt;缺陷（提交、验证、关闭）</span><br><span class="line">缺陷管理流程：提交、验证、关闭</span><br><span class="line">缺陷定义：任何问题</span><br><span class="line">缺陷标准：多功能、少功能、功能错误、缺少隐形功能、易用性</span><br><span class="line">描述缺陷：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注。</span><br><span class="line">提交缺陷信息：指派人、缺陷等级、修复优先级、类型</span><br></pre></td></tr></table></figure><h3 id="提交缺陷注意事项"><a href="#提交缺陷注意事项" class="headerlink" title="提交缺陷注意事项"></a>提交缺陷注意事项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">确定缺陷是否可重现</span><br><span class="line">确定是否为bug</span><br><span class="line">确定是否具有唯一性</span><br></pre></td></tr></table></figure><ul><li>缺陷标题模板<ul><li>测试数据描述+实际结果（预期结果）</li><li>测试数据描述+预期结果（实际结果）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缺陷&quot;&gt;&lt;a href=&quot;#缺陷&quot; class=&quot;headerlink&quot; title=&quot;缺陷&quot;&gt;&lt;/a&gt;缺陷&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;定义：软件中存在的各种问题，都为缺陷，简称bug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;缺陷标准&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试-用例方法</title>
    <link href="http://example.com/2023/07/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/07/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95/</id>
    <published>2023-07-02T07:29:03.000Z</published>
    <updated>2023-09-24T17:09:51.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用例设计方法"><a href="#用例设计方法" class="headerlink" title="用例设计方法"></a>用例设计方法</h1><h2 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在所有测试数据中，具有某种共同特征的数据集进行划分。</span><br><span class="line">有效等价类：满足需求的数据集合</span><br><span class="line">无效等价类：不满足需求的数据集合</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重点：有效和单个无效等价各取其1即可。</span><br><span class="line">用法：有效等价取1个值</span><br><span class="line"> 每个无效集合取1个</span><br><span class="line">步骤：</span><br><span class="line">1.明确需求</span><br><span class="line">2.划分有效等价和无效等价</span><br><span class="line">3.设计数据编写用例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">适用场景：能对穷举场景设计测试点（解决穷举场景）</span><br><span class="line">针对：需要有大量数据测试输入，但是没法穷举测试的地方；</span><br><span class="line">输入框</span><br><span class="line">下拉列表</span><br><span class="line">单选复选框</span><br><span class="line">典型代表：页面的输入框类测试。</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote><p>需求：验证6-10位自然数的qq合法性</p></blockquote><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230702155542254.png" alt="image-20230702155542254"></p><h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用场景：能对限定边界规则设计测试点（解决边界位数限制问题）</span><br><span class="line">典型代表：有边界范围的输入框类测试</span><br><span class="line">选取正好等于、刚好大于、刚好小于边界的值作为测试数据</span><br><span class="line">上点：边界上的点</span><br><span class="line">离点：离边界最近的点</span><br><span class="line">内点：范围内的点</span><br><span class="line">提示：</span><br><span class="line">1、有关范围限制，最多7条用例（暂时未优化）</span><br><span class="line">2、边界值能解决位数限制问题，但是不能解决类型问题（要结合等价类）</span><br><span class="line">3、开内闭外</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">边界值法设计用例步骤</span><br><span class="line">1.明确需求</span><br><span class="line">2.确定有效和无效等价类</span><br><span class="line">3.确定边界范围值</span><br><span class="line">4.提取数据编写测试用例</span><br></pre></td></tr></table></figure><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230704234340477.png" alt="image-20230704234340477"></p><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230704234247774.png" alt="image-20230704234247774"></p><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230704234402702.png" alt="image-20230704234402702"></p><h3 id="边界值分析优化"><a href="#边界值分析优化" class="headerlink" title="边界值分析优化"></a>边界值分析优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结论：7个优化为5个点</span><br><span class="line">上点：必选（不考虑区间开闭）</span><br><span class="line">内点：必选（建议选择中间范围）</span><br><span class="line">离点：开内闭外（考虑开闭区间，开区间选择内部离点，闭区间选择外部离点）</span><br></pre></td></tr></table></figure><h2 id="判定表方法"><a href="#判定表方法" class="headerlink" title="判定表方法"></a>判定表方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用场景：解决多条件依赖测试问题，使用判定表来进行测试覆盖。</span><br><span class="line">定义：是一种以表格形式表达多条件逻辑判断的工具</span><br><span class="line">组成：</span><br><span class="line">条件桩：列出问题中的所有条件，列出条件的次序无关紧要。</span><br><span class="line">动作桩：列出问题中可能采取的操作，操作的排列顺序没有约束。</span><br><span class="line">条件项：列出条件对应的取值，所有可能情况下的真假值</span><br><span class="line">动作项：列出条件项的、各种取值情况下应该采取的动作结果。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1、明确需求</span><br><span class="line">2、画出判定表</span><br><span class="line">1.列出条件桩和动作桩</span><br><span class="line">2.填写条件项，对条件进行全组合</span><br><span class="line">3.根据条件项的组合确定动作项</span><br><span class="line">4.简化、合并相似规则（有相同的动作）</span><br><span class="line">3、根据规则编写测试用例</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用场景：</span><br><span class="line">判定表一般适用于条件组合数量较少的情况（比如4个条件以下）</span><br><span class="line">有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖（制约）关系</span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="判断表"><a href="#判断表" class="headerlink" title="判断表"></a>判断表</h4><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230706235527348.png" alt="image-20230706235527348"></p><h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%5Cimage-20230706235951966.png" alt="image-20230706235951966"></p><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><blockquote><p>覆盖业务测试，需要使用流程图法</p><p>先测试业务，在测试单功能、单模块、单页面</p><p>场景法也可以叫流程图法。</p></blockquote><h2 id="错误推荐法"><a href="#错误推荐法" class="headerlink" title="错误推荐法"></a>错误推荐法</h2><blockquote><p>通过经验推测系统可能出现的问题</p><p>应用场景：当项目用例都执行完毕，且bug修复完成，离上线还有一段时间，在这段时间中可以使用错误推荐法复测主要业务或测试未覆盖的主要功能。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>等价类划分</p><ol><li><p>能对穷举场景设计测试点</p></li><li><p>难点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度：边界</span><br><span class="line">类型：等价</span><br><span class="line">规则：等价</span><br></pre></td></tr></table></figure></li></ol></li><li><p>边界值分析</p><ol><li>能对限定边界规则进行设计测试点</li></ol></li><li><p>判定表</p><ol><li>能对多条件依赖关系进行设计测试点</li></ol></li><li><p>流程图法（场景法）</p><ol><li><p>能对项目业务进行设计测试点</p></li><li><p>重点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先测业务，再测单功能、单模块</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用例设计方法&quot;&gt;&lt;a href=&quot;#用例设计方法&quot; class=&quot;headerlink&quot; title=&quot;用例设计方法&quot;&gt;&lt;/a&gt;用例设计方法&lt;/h1&gt;&lt;h2 id=&quot;等价类划分法&quot;&gt;&lt;a href=&quot;#等价类划分法&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件测试-了解测试</title>
    <link href="http://example.com/2023/06/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2023/06/28/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95/</id>
    <published>2023-06-28T12:47:02.000Z</published>
    <updated>2023-09-24T17:10:03.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><blockquote><p>软件测试的定义：使用技术手段验证软件是否满足需求。</p></blockquote><h2 id="测试发展方向"><a href="#测试发展方向" class="headerlink" title="测试发展方向"></a>测试发展方向</h2><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95%5Cimage-20230628204736929.png" alt="image-20230628204736929"></p><ul><li>功能测试+接口测试</li><li>功能测试+web自动化</li><li>功能测试+性能测试</li></ul><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><h3 id="按阶段划分"><a href="#按阶段划分" class="headerlink" title="按阶段划分"></a>按阶段划分</h3><ul><li>单元测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对程序源代码进行测试</span><br></pre></td></tr></table></figure><ul><li>集成测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">又称接口测试，针对模块之间访问地址进行测试</span><br></pre></td></tr></table></figure><ul><li>系统测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对整个系统进行测试包括功能、兼容、文档等测试</span><br></pre></td></tr></table></figure><ul><li>验收测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要分为公测、内测。使用不同人群来发掘项目缺陷。</span><br></pre></td></tr></table></figure><h3 id="按代码可见度划分"><a href="#按代码可见度划分" class="headerlink" title="按代码可见度划分"></a>按代码可见度划分</h3><ul><li>黑盒测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不关注源代码，针对程序UI功能进行测试（系统测试）</span><br></pre></td></tr></table></figure><ul><li>灰盒测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对程序部分代码进行测试（集成测试）</span><br></pre></td></tr></table></figure><ul><li>白盒测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对程序源代码进行测试（单元测试）</span><br></pre></td></tr></table></figure><h3 id="专项"><a href="#专项" class="headerlink" title="专项"></a>专项</h3><ul><li>性能测试</li><li>安全测试</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><blockquote><p>一个优秀软件可以从以下八个维度进行衡量。</p></blockquote><p><img src="%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-%E4%BA%86%E8%A7%A3%E6%B5%8B%E8%AF%95%5Cimage-20230628211432755.png" alt="image-20230628211432755"></p><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><ol><li>需求分析与评审</li><li>编写测试计划</li><li>编写测试用例与评审</li><li>执行用例与缺陷管理</li><li>编写测试报告及总结</li></ol><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="测试的作用"><a href="#测试的作用" class="headerlink" title="测试的作用"></a>测试的作用</h3><ul><li>防止漏测</li><li>实施测试的标准</li></ul><h3 id="测试用例设计编写格式"><a href="#测试用例设计编写格式" class="headerlink" title="测试用例设计编写格式"></a>测试用例设计编写格式</h3><ul><li>用例编号<ul><li>项目_模块__编号</li></ul></li><li>用例标题<ul><li>预期结果（测试点）</li></ul></li><li>模块&#x2F;项目<ul><li>所属项目或模块</li></ul></li><li>优先级<ul><li>表示用例的重要程度或者影响力p0~p4（p0最高）</li></ul></li><li>前置条件<ul><li>要执行此条用例，有哪些前置操作</li></ul></li><li>测试步骤<ul><li>描述操作步骤</li></ul></li><li>测试数据<ul><li>操作的数据，没有的话可以为空</li></ul></li><li>预期结果<ul><li>期望达到的结果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件测试&quot;&gt;&lt;a href=&quot;#软件测试&quot; class=&quot;headerlink&quot; title=&quot;软件测试&quot;&gt;&lt;/a&gt;软件测试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;软件测试的定义：使用技术手段验证软件是否满足需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维中段学习(二)</title>
    <link href="http://example.com/2023/05/20/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
    <id>http://example.com/2023/05/20/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0-%E4%BA%8C/</id>
    <published>2023-05-20T06:32:10.000Z</published>
    <updated>2023-09-24T16:52:46.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h3 id="Nginx的简介"><a href="#Nginx的简介" class="headerlink" title="Nginx的简介"></a>Nginx的简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx可以用来做http服务与反向代理服务器。</span><br></pre></td></tr></table></figure><h3 id="Nginx的优势"><a href="#Nginx的优势" class="headerlink" title="Nginx的优势"></a>Nginx的优势</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IO多路复用</span><br><span class="line">时分多路复用</span><br><span class="line">频分多路复用</span><br></pre></td></tr></table></figure><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一种方法：最传统的多进程并发模型（每进来一个新的I/O流就分配一个新的进程管理）</span><br><span class="line">第二种方法：I/O多路复用（单个线程，通过记录跟踪每个I/O流（sock）的状态，来同时管理多个I/O流。）</span><br><span class="line">发明它的原因，是尽量多的提高服务器的吞吐能力</span><br><span class="line">在同一个线程里，通过拨开关的方式，来同时传输多个I/O流。</span><br><span class="line"></span><br><span class="line">技术类型：select、poll、epoll，epoll可以说是I/O多路复用最新的一个实现，epoll修复了poll和sellect绝大部分问题，比如：</span><br><span class="line">epoll现在是线程安全的。epoll现在不仅告诉你sock组里面数据，还会告诉你具体哪个sock有数据，不用自己找了。</span><br><span class="line">特点是异步，非阻塞。</span><br></pre></td></tr></table></figure><h3 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nginx-部署-yum"><a href="#Nginx-部署-yum" class="headerlink" title="Nginx 部署-yum"></a>Nginx 部署-yum</h3><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%5Cimage-20230522183750594.png" alt="image-20230522183750594"></p><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%5Cimage-20230522185948862.png" alt="image-20230522185948862"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rpm -lq nginx   ----查看nginx所有文件和路径的列表</span><br><span class="line">常用的配置文件：</span><br><span class="line">/etc/logrotate.d/nginx ---日志轮转</span><br><span class="line">/etc/nginx/nginx.conf  ---总配置文件</span><br><span class="line">/etc/nginx/conf.d  ---子配置文件夹</span><br><span class="line">/etc/nginx/conf.d/default.conf  ---默认的网站配置文件</span><br><span class="line">/etc/nginx/mime.type  ---文件关联程序，网站文件类型和相关处理程序。</span><br><span class="line">/etc/nginx/moubles   ---nginx模块，第三方模块在这放</span><br><span class="line">/usr/lib/systemd/system/nginx.service.systemctl   ---服务脚本</span><br><span class="line">/usr/sbin/nginx  ---主程序</span><br><span class="line">/var/cache/nginx  ---程序缓存</span><br><span class="line">/var/log/nginx    ---日志文件夹</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nginx编译参数"><a href="#Nginx编译参数" class="headerlink" title="Nginx编译参数"></a>Nginx编译参数</h3><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%5Cimage-20230522192254763.png" alt="image-20230522192254763"></p><h3 id="Nginx虚拟主机"><a href="#Nginx虚拟主机" class="headerlink" title="Nginx虚拟主机"></a>Nginx虚拟主机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx/conf.d/default.conf</span><br><span class="line">虚拟主机可以写在上面文件中的server，也可以写在/etc/nginx/nginx.conf中的http中去嵌套server</span><br><span class="line"></span><br><span class="line">用户默认访问 /usr/share/nginx/html</span><br><span class="line">实验：</span><br><span class="line">创建 /lifei目录</span><br><span class="line">创建 /lifei/index.html文件并写入内容</span><br><span class="line"></span><br><span class="line">创建nginx的配置文件，在/etc/nginx/conf.d/下创建lifei.conf,内容如下：</span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">        listen 80;   //访问端口</span><br><span class="line">        server_name www.lifei.com;  //服务器域名</span><br><span class="line">location / &#123;</span><br><span class="line">        root /lifei;      //网站文件存放目录</span><br><span class="line">        index index.html;  //网站默认首页</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">建立本地域名解析（如有真实域名可填写），在/etc/hosts文件内配置域名解析</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nginx日志Log"><a href="#Nginx日志Log" class="headerlink" title="Nginx日志Log"></a>Nginx日志Log</h3><h4 id="日志相关配置"><a href="#日志相关配置" class="headerlink" title="日志相关配置"></a>日志相关配置</h4><ul><li>相关指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  ---日志格式</span><br><span class="line">access_log  ---访问日志</span><br><span class="line">error_log   ---错误日志</span><br><span class="line">open_log_file_cache</span><br></pre></td></tr></table></figure><ul><li>日志的格式与命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_format</span><br><span class="line">定义位置：vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>访问日志和错误日志</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">access_log</span><br><span class="line"></span><br><span class="line">error_log</span><br><span class="line">在 /var/log/nginx/目录下。</span><br><span class="line">可以个性化404页面</span><br></pre></td></tr></table></figure><ul><li>日志缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大量访问到来时，对于每一条日志记录都是先打开文件，再写入文件，然后关闭文件，这样会占用大量的系统IO，所以可以用open_log_file_cache来设置。即用缓存来先记录日志。可以再/etc/nginx/conf.d/目录下的相应网站配置文件配置</span><br></pre></td></tr></table></figure><ul><li>日志轮转</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再/etc/logrotate.d/nginx文件下</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h1&gt;&lt;h3 id=&quot;Nginx的简介&quot;&gt;&lt;a href=&quot;#Nginx的简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维中段学习(一)</title>
    <link href="http://example.com/2023/05/02/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <id>http://example.com/2023/05/02/%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0-%E4%B8%80/</id>
    <published>2023-05-02T13:28:10.000Z</published>
    <updated>2023-09-24T16:53:08.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ansible自动化运维"><a href="#Ansible自动化运维" class="headerlink" title="Ansible自动化运维"></a>Ansible自动化运维</h1><h3 id="ansible简介"><a href="#ansible简介" class="headerlink" title="ansible简介"></a>ansible简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible是基于python开发，实现了批量系统配置、批量程序部署登功能。无客户端。</span><br><span class="line"></span><br><span class="line">ansible工作原理：</span><br><span class="line">有一个management node（管理节点），若干个node。</span><br></pre></td></tr></table></figure><h3 id="ansible部署"><a href="#ansible部署" class="headerlink" title="ansible部署"></a>ansible部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install -y ansible（如果没有epel.repo，请先安装epel的yum源）</span><br><span class="line">换yum源后出现404问题可以用yum clean all与rpm --rebuilddb解决。</span><br><span class="line">检查安装是否完成：</span><br><span class="line">yum list | grep ansible或者rpm -ql ansible（列出所有文件）</span><br><span class="line">rpm -qc ansible ---查看配置文件</span><br><span class="line">ansible-doc-l  ---查看所有模块</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh-key"></a>ssh-key</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh keygen  ---生成密钥</span><br><span class="line">ssh-copy-id IP地址  ---推送公钥</span><br></pre></td></tr></table></figure><h3 id="ansible基础"><a href="#ansible基础" class="headerlink" title="ansible基础"></a>ansible基础</h3><ul><li><p>1.定义主机清单</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在/etc/anisble/hosts文件下写入控制的主机如host1、host2</span><br></pre></td></tr></table></figure></li><li><p>2.测试连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible localhost -m ping或</span><br><span class="line">ansible host1 -m ping</span><br><span class="line">简洁输出加选项o即：</span><br><span class="line">ansible host1 -m ping -o</span><br></pre></td></tr></table></figure></li><li><p>4.know_hosts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible host2 —m ping -u root -k    ---未设置免密登录的主机host2的连接</span><br><span class="line">去掉yes/no询问</span><br><span class="line"> vim /etc/ssh/ssh_config</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line"> systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>5.inventory-主机清单</p><ul><li>1.增加主机组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">vim /etc/ansible/hosts</span><br><span class="line">  [webserver]</span><br><span class="line">host1</span><br><span class="line">host2</span><br><span class="line">host3</span><br><span class="line">连接组：ansible webserver -m ping -o</span><br></pre></td></tr></table></figure><ul><li><p>2.增加用户名密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">host1 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host2 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host3 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">或者：</span><br><span class="line">host[1:3] ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br></pre></td></tr></table></figure></li><li><p>3.修改端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">Port 22 改为 Port 要修改的端口</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>4.增加端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">host[1:2] ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host3 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27; ansible_ssh_port=&#x27;2222&#x27;</span><br></pre></td></tr></table></figure></li><li><p>5.组：变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">host[1:2] ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27;</span><br><span class="line">host3 ansible_ssh_user=&#x27;root&#x27; ansible_ssh_pass=&#x27;66666&#x27; ansible_ssh_port=&#x27;2222&#x27;</span><br></pre></td></tr></table></figure></li><li><p>6.子分组</p></li></ul><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%B8%80)%5Cimage-20230508203542570.png"></p><ul><li>7.自定义清单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先写一份主机清单格式的文件，比如hostlist</span><br><span class="line">然后用命令：ansible -i 清单名字 组名字 -m ping -o</span><br><span class="line">如 ansible -i hostlist dockers -m ping -o</span><br></pre></td></tr></table></figure></li><li><ol start="6"><li>Ad-Hoc-点对点模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">临时的，在ansible中是指需要快速执行的指令，如果是比较复杂的就需要playbook</span><br></pre></td></tr></table></figure><ul><li>1.shell模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible webserver -m shell -a &#x27;linux命令&#x27; -o</span><br><span class="line">安装mariadb-server</span><br><span class="line">ansible webserver -m shell -a &#x27;yum install -y mariadb-server&#x27; -o</span><br></pre></td></tr></table></figure><ul><li>2.复制模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">ansible webserver -m copy -a &#x27;src=/etc/hosts dest=/tmp/2.txt owner=root group=bin mode=777&#x27;</span><br><span class="line">ansible webserver -m copy -a &#x27;src=/etc/hosts dest=/tmp/2.txt owner=root group=bin mode=777 backup&#x27;</span><br><span class="line">加了backup起到备份的作用，以前的文件会改了后缀，不会被覆盖</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>3.用户模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.创建用户</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei state=present&#x27;</span><br><span class="line"></span><br><span class="line">2.修改密码</span><br><span class="line">  1.生成加密密码</span><br><span class="line">  echo ‘20230508’ | openssl passwd -1 -stdin</span><br><span class="line">  2.修改密码</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei password=&quot;步骤1生成的加密密码&quot;&#x27;</span><br><span class="line">  3.修改shell</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei shell=/sbin/nologin append=yes&#x27;            ---设置账号lifei不能登录，append是追加、修改的意思</span><br><span class="line">  4.删除用户</span><br><span class="line">  ansible webserver -m user -a &#x27;name=lifei state=absent&#x27;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>4.软件包管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">帮助手册：ansible-doc yum</span><br><span class="line">ansible webserver -m yum -a &#x27;name=&quot;*&quot; state=latest&#x27;   升级所有包</span><br><span class="line">ansible webserver -m yum -a &#x27;name=&quot;httpd&quot; state=latest&#x27;  安装最新版http</span><br><span class="line">ansible webserver -m yum -a &#x27;name=&quot;httpd&quot; state=absent&#x27;  卸载http</span><br></pre></td></tr></table></figure><ul><li>5.服务模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">设置httpd开机自启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=started enabled=yes&#x27;</span><br><span class="line">将httpd开启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=started&#x27;</span><br><span class="line">将httpd关闭</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=stopped&#x27;</span><br><span class="line">将httpd重启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=restarted&#x27;</span><br><span class="line">将httpd启动并设置开机不自启</span><br><span class="line">ansible webserver -m service -a &#x27;name=httpd state=started enabled=no&#x27;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>6.文件模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建文件</span><br><span class="line">ansible webserver -m file -a &#x27;path=/tmp/88.txt mode=777 state=touch&#x27;</span><br><span class="line">创建目录</span><br><span class="line">ansible webserver -m file -a &#x27;path=/tmp/99 mode=777 state=directory&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>7.收集模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">帮助文档：ansible-doc setup</span><br><span class="line">收集信息</span><br><span class="line">ansiblehost1 -m setup</span><br><span class="line">收集过滤后的信息</span><br><span class="line">ansiblehost1 -m setup -a &#x27;filter=ansible_all_ipv4_addresses &#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>非标记语言</p><ul><li>准备工作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">卸载httpd与httpd-tools</span><br><span class="line">ansible all -m yum -a &#x27;name=httpd state=removed&#x27; -o</span><br><span class="line">ansible all -m yum -a &#x27;name=httpd-tools state=removed&#x27; -o</span><br><span class="line">服务器安装httpd</span><br><span class="line">yum install -y httpd</span><br><span class="line">准备工作目录</span><br><span class="line">mkdir apache</span><br><span class="line">cd apache</span><br><span class="line">cp -rf /etc/httpd/conf/httpd.conf .</span><br><span class="line">ls</span><br><span class="line">查看端口号</span><br><span class="line">grep &#x27;^Listen&#x27; httpd.conf</span><br><span class="line">默认为80端口，需要改为8080</span><br></pre></td></tr></table></figure><ul><li>编写剧本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim apache.yaml</span><br><span class="line">内容如下：</span><br><span class="line">- hosts: host2</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install apache packages</span><br><span class="line">    yum: name=httpd state=present</span><br><span class="line">  - name: copy apache conf</span><br><span class="line">    copy: src=./httpd.conf dest=/etc/httpd/conf/httpd.conf</span><br><span class="line">  - name: ensure apache is running</span><br><span class="line">    service: name=httpd state=started enabled=yes</span><br><span class="line">##name是一个别名，作为解释下方模块的作用。 </span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">检查语法是否有错</span><br><span class="line">ansible-playbook apache.yaml --syntax-check</span><br><span class="line">列出任务</span><br><span class="line">ansible-playbook apache.yaml  --list-tasks</span><br><span class="line">列出任务主机</span><br><span class="line">ansible-playbook apache.yaml  --list-hosts</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>handlers</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">假如配置文件发生改变需要</span><br><span class="line">  在剧本中加入handler：</span><br><span class="line">  handlers:</span><br><span class="line">   - name: restart apache service</span><br><span class="line">     service: name=httpd state=restarted</span><br><span class="line">     </span><br><span class="line">  handlers与tasks同级</span><br><span class="line">  </span><br><span class="line">  在apche.yaml文件中：</span><br><span class="line">  - hosts: host2</span><br><span class="line">    tasks:</span><br><span class="line">    - name: install apache packages</span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: copy apache conf</span><br><span class="line">      copy: src=./httpd.conf dest=/etc/httpd/conf/httpd.conf</span><br><span class="line">      notify: restart apache service </span><br><span class="line">    - name: ensure apache is running</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">       - name: restart apache service</span><br><span class="line">    handlers:</span><br><span class="line">    - name: restart apache service</span><br><span class="line">      service: name=httpd state=restarted</span><br><span class="line">  ###解释：假如httpd.conf文件中发生改变，则会启动handlers中的service模块。copy模块中的notify值要与handlers中的name值相同，用以触发handlers</span><br></pre></td></tr></table></figure></li><li><p>Role-角色扮演</p><ul><li>简介</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roles是在ansible中，playbooks的目录组织结构。将代码或文件进行模块化，成为roles的文件目录组织结构，易读，代码可重用，层次清晰。</span><br></pre></td></tr></table></figure><ul><li>目标</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过role运程部署nginx并配置</span><br></pre></td></tr></table></figure><ul><li>目录结构</li></ul><blockquote><p>准备目录结构，文件夹名字固定</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir roles/nginx/&#123;files,handlers,tasks,templates,vars&#125; -p</span><br><span class="line">touch roles/site.yaml roles/nginx/&#123;handlers,tasks,vars&#125;/main.yaml</span><br><span class="line">echo 1234 &gt; roles/nginx/files/index.html</span><br><span class="line">yum install -y nginx &amp;&amp; cp /etc/nginx/nginx.conf roles/nginx/templates/nginx.conf.j2</span><br></pre></td></tr></table></figure><p><img src="%E8%BF%90%E7%BB%B4%E4%B8%AD%E6%AE%B5%E5%AD%A6%E4%B9%A0(%E4%B8%80)%5Cimage-20230514121011679.png" alt="image-20230514121011679"></p><ul><li>编写任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/tasks/main.yaml</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">- name: install epel-release package</span><br><span class="line">  yum: name=epel-release state=latest</span><br><span class="line">- name: install nginx package</span><br><span class="line">  yum: name=nginx state=latest</span><br><span class="line">- name: copy index.html</span><br><span class="line">  copy: src=index.html dest=/usr/share/nginx/html/index.html</span><br><span class="line">- name: copy nginx.conf template</span><br><span class="line">  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  notify: restart nginx</span><br><span class="line">- name: make sure nginx service running</span><br><span class="line">  service: name=nginx state=started enabled=yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>准备配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/tmplates/nginx.conf.j2(金甲文件是带有变量的文件)</span><br><span class="line">里面有两个变量：worker_processes&#123;&#123;ansible_processor_cores&#125;&#125;  ---调用内部已知的变量</span><br><span class="line"> worker_connections&#123;&#123;worker_connections&#125;&#125;  ---自定义变量</span><br></pre></td></tr></table></figure><ul><li>编写变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/vars/main.yaml</span><br><span class="line"></span><br><span class="line">worker_connections: 10241</span><br></pre></td></tr></table></figure><ul><li>编写处理程序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/handlers/main.yaml</span><br><span class="line">---</span><br><span class="line">- name: restart nginx</span><br><span class="line">  service: name=nginx state=restarted</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>编写剧本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim roles/nginx/site.yaml </span><br><span class="line">- hosts: webserver</span><br><span class="line">  roles:</span><br><span class="line">  - nginx       </span><br></pre></td></tr></table></figure><ul><li>实施</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd roles</span><br><span class="line">ansible-playbook site.yaml --syntax-check  --检查site.yaml的语法</span><br><span class="line"></span><br><span class="line">ansible-playbook site.yaml   --实施剧本</span><br></pre></td></tr></table></figure><blockquote><p>总结：其实编写剧本是一套流程，如同写一套系统项目代码一样，每个文件夹里的文件是各司其职的，如roles中nginx文件夹，里面的5个文件夹名字是固定的，files，handlers，vars，tasks，templates。，运行剧本是运行roles文件夹下的site.yaml，它才是整个剧本的核心运行文件。一般来指定运行哪个剧本，假如roles下有mysql、k8s、dockers等等已经写好的如同nginx文件夹一样的文件夹，site.yaml就可以指定运行哪个文件夹，并指定对象服务器集群</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ansible自动化运维&quot;&gt;&lt;a href=&quot;#Ansible自动化运维&quot; class=&quot;headerlink&quot; title=&quot;Ansible自动化运维&quot;&gt;&lt;/a&gt;Ansible自动化运维&lt;/h1&gt;&lt;h3 id=&quot;ansible简介&quot;&gt;&lt;a href=&quot;#ansi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维学习（七）</title>
    <link href="http://example.com/2023/04/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://example.com/2023/04/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89/</id>
    <published>2023-04-30T14:56:23.000Z</published>
    <updated>2023-05-02T03:50:09.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="域名服务"><a href="#域名服务" class="headerlink" title="域名服务"></a>域名服务</h1><ul><li>hosts文件(老的)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：实现名字解析，主要为本地主机名、集群节点提供快速解析</span><br><span class="line">Linux位置:/etc/hosts</span><br><span class="line">缺点：不便于查询，更新</span><br></pre></td></tr></table></figure><ul><li>DNS</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：实现名字解析。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>FQDN（完全合格域名&#x2F;全称域名）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机名.二级域.顶级域.（根域）</span><br></pre></td></tr></table></figure><ul><li>命名空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name space ： 用于给互联网上的主机命名的一种机制</span><br></pre></td></tr></table></figure><ul><li>域名解析过程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.客户端先查询自己的缓存（包括hosts中的记录）和浏览器中的DNS解析器缓存</span><br><span class="line">2.如果没有，将查询发送到/etc/resolv.conf中的DNS服务器（即本地的DNS服务器）</span><br><span class="line">3.如果还没有，就往根服务器查询，根服务器往下一级级查询，然后找到之后返回给客户机。</span><br><span class="line">客户机--&gt;本地DNS服务器 （递归查询）</span><br><span class="line">本地DNS服务器--&gt;DNS服务器（迭代查询）</span><br><span class="line"></span><br><span class="line">服务器类型：主服务器、从服务器、缓存服务器</span><br><span class="line"></span><br><span class="line">正向解析：可把对应域名解析为对应的IP地址叫正向解析。</span><br><span class="line">反向解析：可把对应IP地址解析为对应的域名叫反向解析。（反垃圾邮件）</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;域名服务&quot;&gt;&lt;a href=&quot;#域名服务&quot; class=&quot;headerlink&quot; title=&quot;域名服务&quot;&gt;&lt;/a&gt;域名服务&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;hosts文件(老的)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维学习（六）</title>
    <link href="http://example.com/2023/04/29/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://example.com/2023/04/29/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2023-04-29T12:14:17.000Z</published>
    <updated>2023-04-30T09:17:58.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站服务"><a href="#网站服务" class="headerlink" title="网站服务"></a>网站服务</h1><h2 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h2><ul><li>LAMP<ul><li>Linux+Apache+MySQL+PHP</li><li>PHP是中间件（网站和数据库之间的程序）</li><li>Apache是服务器程序</li></ul></li></ul><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Apache软件包名称：httpd</span><br><span class="line">服务器端口：80/tcp(http)  443/tcp(https)</span><br><span class="line">配置文件：/etc/httpd/conf/httpd.conf</span><br><span class="line">子配置文件：/etc/httpd/conf.d/*.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装httpd：</span><br><span class="line">yum install -y httpd</span><br><span class="line">软件启动：</span><br><span class="line">systemctl start httpd</span><br><span class="line">检查httpd状态：</span><br><span class="line">systemctl status httpd</span><br><span class="line">开机自启：</span><br><span class="line">systemctl enable httpd</span><br><span class="line">关闭防火墙：</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">关闭selinux防火墙：</span><br><span class="line">setenforce 0</span><br><span class="line">查看httpd版本及下载时间：</span><br><span class="line">httpd -v</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">firewalld简介：保护互联网对服务器的影响</span><br><span class="line">selinux简介：保护服务器内部程序（ftp）对内部文件（/var/ftp)的访问</span><br><span class="line">firewall临时关闭：systemctl stop firewalld</span><br><span class="line">firewall永久关闭：systemctl disable firwalld</span><br><span class="line"></span><br><span class="line">selinux临时关闭：setenforce 0</span><br><span class="line">selinux永久关闭：vim /etc/selinux/config，修改内容SELINUX=disabled</span><br><span class="line">selinux状态查看：getenforce(enfircing开启，permi放行，disable关闭)</span><br></pre></td></tr></table></figure><hr><h3 id="Apache主目录"><a href="#Apache主目录" class="headerlink" title="Apache主目录"></a>Apache主目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache默认工作目录：/var/www/html/</span><br><span class="line">主页面：/var/www/html/index.html</span><br></pre></td></tr></table></figure><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">虚拟主机目的：虚拟主机VirtualHost,作用：在一台物理服务器上运行多个网站</span><br><span class="line">类型：</span><br><span class="line">基于域名</span><br><span class="line">配置虚拟主机目标：在一台服务器上，实现两个网站的架构</span><br><span class="line">网站域名：网站资源存放目录</span><br><span class="line">例如：www.a.org  /var/www/html/a.org</span><br><span class="line">  www.b.org  /var/www/html/b.org</span><br><span class="line">  </span><br><span class="line">服务器：</span><br><span class="line">www.a.org站点设置：</span><br><span class="line">准备网站源码目录：mkdir /var/www/html/a.org</span><br><span class="line">创建a.org的网站配置文件：</span><br><span class="line">vim /etc/httpd/conf.d/a.org.conf，写如下内容：</span><br><span class="line">    &lt;VirtualHost *:80&gt;---某个虚拟主机</span><br><span class="line">    ServerName www.a.org---设置域名</span><br><span class="line">    DocumentRoot /var/www/html/a.org    ---网站的根目录</span><br><span class="line">    &lt;/VirtualHost&gt;</span><br><span class="line">检测配置文件语法，重启服务：</span><br><span class="line">httpd -t</span><br><span class="line">systemctl restart httpd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">www.b.org站点设置：</span><br><span class="line">准备网站源码目录：mkdir /b.org</span><br><span class="line">创建a.org的网站配置文件：</span><br><span class="line">vim /etc/httpd/conf.d/b.org.conf，写如下内容：</span><br><span class="line">    &lt;VirtualHost *:80&gt;---某个虚拟主机</span><br><span class="line">    ServerName www.b.org---设置域名</span><br><span class="line">    DocumentRoot /b.org    ---网站的根目录</span><br><span class="line">    &lt;/VirtualHost&gt;</span><br><span class="line">    ###授权部分，因为/b.org不是apache的默认工作目录，所以要有授权部分</span><br><span class="line">    &lt;Directory &quot;/b.org&quot;&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">要在真机windows做客户机访问要修改C:\Windows\System32\drivers\etc下的hosts</span><br></pre></td></tr></table></figure><h4 id="部署动态站点-论坛"><a href="#部署动态站点-论坛" class="headerlink" title="部署动态站点-论坛"></a>部署动态站点-论坛</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">基础环境：</span><br><span class="line">关闭firewalld与selinux</span><br><span class="line">yum install -y httpd mariadb-server mariadb php php-mysql gd php-gd</span><br><span class="line">启动：</span><br><span class="line">systemctl start httpd mariadb</span><br><span class="line">下载Discuz源码 wget https://gitee.com/Discuz/DiscuzX/attach_files/1344965/download</span><br><span class="line">解压包：</span><br><span class="line">unzip download</span><br><span class="line">复制源代码到指定目录下：</span><br><span class="line">cp -rf upload/* /webroot/discuz/</span><br><span class="line">然后对/webroot/discuz/里的目录授权：</span><br><span class="line">chown -R apache.apache /webroot/discuz/</span><br><span class="line"></span><br><span class="line">在/etc/httpd/conf.d/discuz.conf写入以下内容：</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">ServerName www.discuz.com</span><br><span class="line">DocumentRoot /webroot/discuz</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory &quot;/webroot/discuz&quot;&gt;</span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">写完配置文件重启http：</span><br><span class="line">systemctl restart httpd</span><br><span class="line">准备数据库：</span><br><span class="line">在mysql环境下：</span><br><span class="line">create database discuz;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网站服务&quot;&gt;&lt;a href=&quot;#网站服务&quot; class=&quot;headerlink&quot; title=&quot;网站服务&quot;&gt;&lt;/a&gt;网站服务&lt;/h1&gt;&lt;h2 id=&quot;网站架构&quot;&gt;&lt;a href=&quot;#网站架构&quot; class=&quot;headerlink&quot; title=&quot;网站架构&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维学习（五）</title>
    <link href="http://example.com/2023/04/14/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://example.com/2023/04/14/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2023-04-14T14:31:31.000Z</published>
    <updated>2023-04-29T09:11:00.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h3><h4 id="FTP（File-Transfer-Protocol-文件传输协议）"><a href="#FTP（File-Transfer-Protocol-文件传输协议）" class="headerlink" title="FTP（File Transfer Protocol 文件传输协议）"></a>FTP（File Transfer Protocol 文件传输协议）</h4><ul><li>作用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提供文件共享服务</span><br><span class="line">互联网上多的媒体资源和软件资源。绝大部分都是通过FTP服务器传递</span><br></pre></td></tr></table></figure><ul><li>FTP Server</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">软件包：vsftpd</span><br><span class="line">控制端口command 21/tcp</span><br><span class="line">数据端口data 20/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装vsftpd： yum install -y vsftpd</span><br><span class="line">准备分发的文件：touch /var/ftp/abc.txt</span><br><span class="line">注释：FTP服务器的主目录：“/var/ftp/”，是FTP程序分享内容的本机目录，这个目录是固定的，vsftpd下载下来就有这个目录</span><br><span class="line">启动服务：</span><br><span class="line">systemctl start vsftpd</span><br><span class="line">systemctl enable vsftpd ---开机自启</span><br><span class="line">关闭防火墙：</span><br><span class="line">systemctl stop firewalld  </span><br><span class="line">systemctl disable firewalld ---禁用防火墙，防止下次开机自启</span><br><span class="line">关闭selinux防火墙：</span><br><span class="line">setenfore 0</span><br><span class="line">设置selinux防火墙开机不自启：</span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">修改内容为：SELINUX=disabled</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>FTP Client</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">纯字符界面访问FTP服务器</span><br><span class="line">LinuxFTP客服端程序1：lftp</span><br><span class="line">安装客服端工具：yum -y install lftp</span><br><span class="line">访问服务器：lftp  服务器的IP地址</span><br><span class="line">ls  ----查看ftp服务器下的文件</span><br><span class="line">get 文件名 ---下载文件</span><br><span class="line">mirror 目录名  ---下载目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LinuxFTP客服端程序2：wget</span><br><span class="line">wget ftp://ip地址/文件名</span><br><span class="line">wget -m ftp://ip地址/文件名 ---下载文件夹</span><br><span class="line"></span><br><span class="line">启动上传功能</span><br><span class="line">配置文件--用于设定FTP服务器的功能开启或关闭的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>NFS（network file system）</li></ul><blockquote><p>Linux&#x2F;Unix系统之间共享文件的一种协议，它最大的功能就是可以<strong>通过网络，让不同的机器、不同的操作系统可以共享彼此的文件</strong>。NFS的客户端主要为linux，支持多节点同时挂载，以及并发写入</p></blockquote><p>  NFS存储器端（NAS【网络存储】）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">安装NFS服务器：</span><br><span class="line">yum install nfs-utils</span><br><span class="line">mkdir /webdata  --存储网站代码（网站目录创建非必须）</span><br><span class="line">echo &#x27;nfs test00&#x27; &gt; /webdata/index.html  --放置测试页面</span><br><span class="line"></span><br><span class="line">配置NFS服务器：</span><br><span class="line">vim /etc/exports</span><br><span class="line">/webdata 192.168.26.0/24(rw)  ---/webdata指的是发布资源的目录，192.168.26.0/24允许访问NFS的客户机，（rw）可读可写</span><br><span class="line"></span><br><span class="line">启动NFS服务器：</span><br><span class="line">systemctl start nfs-server</span><br><span class="line">systemctl enble  enble nfs-server ---设置开机自启</span><br><span class="line">exportfs -v    ----检查nfs输出是否正常</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  NFS客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">安装NFS客户端：</span><br><span class="line">yum install -y nfs-utilshttpd</span><br><span class="line">systemctl start httpd</span><br><span class="line">systemctl enble httpd</span><br><span class="line">查看存储端共享：</span><br><span class="line">showmount -e 192.168.26.128  ---查询nfs服务器可用目录</span><br><span class="line">Export list for 192.168.26.128</span><br><span class="line">/webdata 192.168.26.0/24</span><br><span class="line">mount -t nfs  192.168.26.128:/webdata   /var/www/html  ---挂载文件</span><br><span class="line">取消挂载用umount</span><br><span class="line">查看挂载用df</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以用elinks命令工具查看web页面，格式为elinks <a href="http://ip地址/">http://ip地址</a></p></blockquote><p>总结</p><p>NFS是网络文件系统</p><ul><li><p>目的：通过网络分发文件，这不跟FTP冲突。</p></li><li><p>核心：集中的管理多台WEB服务器文件系统，一对多：一个文件服务器，对应多个客户端（WEB）</p></li><li><p>步骤</p><ul><li>安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line">systemctl start nfs-server</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>输出目录设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建输出目录</span><br><span class="line">mkdir /webdata</span><br><span class="line">写入要显示的网页文件</span><br><span class="line">输出目录设置</span><br><span class="line">vim /etc/exports</span><br><span class="line">/webdata   192.168.26.0/24(rw)</span><br></pre></td></tr></table></figure><ul><li>客户端挂载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line">mount -t 192.168.26.128(存储端ip地址):/webdata  /var/www/html</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件服务&quot;&gt;&lt;a href=&quot;#文件服务&quot; class=&quot;headerlink&quot; title=&quot;文件服务&quot;&gt;&lt;/a&gt;文件服务&lt;/h3&gt;&lt;h4 id=&quot;FTP（File-Transfer-Protocol-文件传输协议）&quot;&gt;&lt;a href=&quot;#FTP（File-Tr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维学习（四）</title>
    <link href="http://example.com/2023/04/05/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2023/04/05/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2023-04-05T13:41:15.000Z</published>
    <updated>2023-04-14T09:35:42.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ol><li>网卡</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置路径：/etc/sysconfig/network-script/</span><br><span class="line">NetworkManager服务：</span><br><span class="line">systemctl status NetworkManager </span><br><span class="line">systemctl status network</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令行配置：修改/etc/sysconfig/network-script/下的网卡，如ifcfg-ens33名字之类的文件，也可以用emcli命令</span><br></pre></td></tr></table></figure><ol start="3"><li>配置网络参数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network-script/ens33文件：</span><br><span class="line">ONBOOT=yes    ---开机是否启用该设备</span><br><span class="line">BOOTPROTO=none     ---ip地址手动（none/static）还是自动（dhcp）</span><br><span class="line">protocol协议分三种：dhcp（自动）、none（手动）、static（静态）</span><br><span class="line">IPADDR=ip地址</span><br><span class="line">NETMASK=掩码          ---掩码是用来定义网络的</span><br><span class="line"></span><br><span class="line">GATEWAY=             ----网关，也叫默认路由，带我们上网的路由器地址</span><br><span class="line">DNS=                ----域名解析</span><br><span class="line"></span><br><span class="line">网卡信息：</span><br><span class="line">NAME</span><br><span class="line">UUID</span><br><span class="line">DEVICE</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>主机名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hostname  ---查看主机名</span><br><span class="line">改名方式1：</span><br><span class="line">hostnamectl set-hostname  要改的名字  ---配置主机名</span><br><span class="line">改名方式2：</span><br><span class="line">cat  /etc/hostname    ---查看和配置主机名</span><br><span class="line">vim  /etc/hostname      ---改名</span><br><span class="line">reboot       ---重启生效</span><br></pre></td></tr></table></figure><ol start="5"><li>网络测试工具</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip a      ----查看所有ip</span><br><span class="line">ip route  ---查看路由，查看网关</span><br><span class="line">ip neigh    ---另一台主机ping通，查看邻居</span><br><span class="line">ss -tnl       ---查看端口号</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭selinux</span><br><span class="line">临时关闭：setenforece 0</span><br><span class="line">永久关闭：vim /etc/sysconfig/selinux     ---设置SELINUX=disabled</span><br></pre></td></tr></table></figure><hr><p>OSI开放系统互联模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开放式系统互联，定义了不同计算机互联的标准</span><br><span class="line">OSI7层次结构：全世界网络通信的工作分为7层，应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</span><br><span class="line"></span><br><span class="line">TCP/IP5层结构：应用层、传输层、网络层、数据链路层、物理层</span><br><span class="line">TCP/IP4层结构：应用层、传输层、网络层、网络接口层</span><br><span class="line"></span><br><span class="line">OSI模型和TCP/IP模型的区别：OSI推出的时间早，只有理论，没有实践。实践上现在用的都是TCP/IP结构模型，当今通信标准。</span><br></pre></td></tr></table></figure><p>TCP&#x2F;IP：数据单元&#x2F;DU</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据传输中数据会以不一样的形式呈现</span><br><span class="line">应用层数据：APDU：应用协议数据单元</span><br><span class="line">传输层数据：分段数据</span><br><span class="line">网络层数据：包数据</span><br><span class="line">数据链路层数据：帧数据</span><br><span class="line">物理层数据：比特数据</span><br><span class="line"></span><br><span class="line">数据通过网络进行传输，在发送端从高层一层层向下传送，先把数据装到一个特殊协议报头中，这个过程叫做封装。接收端会从底层一层层向上进行解封装。</span><br></pre></td></tr></table></figure><hr><p>TCP&#x2F;IP协议族</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层：http（超文本传输协议/网站）、SSH（远程连接协议/远程控制）、FTP（文件传输协议）、SMTP（简单邮件传输协议/Email）、DNS(域名服务/www)</span><br><span class="line"></span><br><span class="line">传输层：TCP（传输控制协议）、UDP（用户数据报协议）</span><br><span class="line"></span><br><span class="line">网络层：IP（互联网协议）、ICMP（网络消息管理协议）</span><br><span class="line"></span><br><span class="line">数据链路层：MAC </span><br><span class="line"></span><br><span class="line">物理层：网线、光纤</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单位换算：</span><br><span class="line">比特=bit=b=1/0</span><br><span class="line">字节=byte=B=8个比特</span><br><span class="line">1KB=1024B</span><br><span class="line">1MB=1024KB</span><br><span class="line">1GB=1024MB</span><br><span class="line">1TB=1024GB</span><br></pre></td></tr></table></figure><hr><p>物理层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">物理层</span><br><span class="line"></span><br><span class="line">信号是数字信号传递。用分立脉冲信号表示0和1</span><br><span class="line"></span><br><span class="line">传输介质：双绞线、光纤（传输光信号）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>数据链路层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数据链路层</span><br><span class="line"> MAC地址（媒体访问控制地址）</span><br><span class="line"> 数字结构：48位2进制数字，12位16进制数字</span><br><span class="line">前六位是厂商标识，后六位是硬件标识</span><br><span class="line"> 帧封装：</span><br><span class="line">  MAC地址写入到信息中</span><br><span class="line">  目标MAC-源AMC-数据（通信一定是双向的）-CRC循环冗余校验和</span><br><span class="line"></span><br><span class="line"> 交换机工作原理（switch）：</span><br><span class="line">MAC地址表（将双方通信的MAC地址记录下来，第二列记录端口号）</span><br><span class="line">VLAN（虚拟局域网）：</span><br><span class="line">划分VLAN的方法：1、创建VLAN（2~1024），2、根据接口和VLAN的关系</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">划分VLAN：</span><br><span class="line">enable         ---特权</span><br><span class="line">config t     ---进入配置模式</span><br><span class="line">vlan 10        ---创建局域网10</span><br><span class="line">vlan 20          ---创建局域网20</span><br><span class="line">interface fastethernet0/1   ---接口模式下输入</span><br><span class="line">switch access vlan 10 ---将端口加入vlan</span><br><span class="line"></span><br><span class="line">所有交换机买回来默认将接口都划分到vlan1，设置了trunk的接口不属于任何vlan</span><br><span class="line">交换机核心技术：vlan标签技术</span><br><span class="line">交换机的接口有两种模式：</span><br><span class="line">1.access访问模式某个VLAN（连接计算机用的）</span><br><span class="line">2.trunk模式承载多个VLAN（连接交换机用的）</span><br><span class="line"></span><br><span class="line">Trunk（干道）理论：在同一条线缆上，传递多个VLAN的信息，适用于多个交换机之间相同vlan之间的通信</span><br><span class="line">vlan标签只存在trunk线路，交换机之间的线路才叫trunk线路</span><br><span class="line">连接两台交换机，在连接的端口上需要配置trunk</span><br><span class="line">实验2：</span><br><span class="line">1.准备交换机1</span><br><span class="line">2.在交换机1，划分VLAN10和VLAN20.主机配置IP地址</span><br><span class="line">3.准备交换机2</span><br><span class="line">4.在交换机2，划分VLAN10和VLAN20.主机配置IP地址</span><br><span class="line">5.连接两台交换机，在连接的端口上，配置TRUNK</span><br><span class="line">6.相同VLAN的主机互通</span><br><span class="line">7.不同VLAN的主机不可通信</span><br><span class="line"></span><br><span class="line">实验步骤：</span><br><span class="line">en（enable简写）</span><br><span class="line">config t</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">int f0/1</span><br><span class="line">sw ac vlan 10</span><br><span class="line">int f0/2</span><br><span class="line">sw ac vlan 20</span><br><span class="line">在两头接口配置trunk：</span><br><span class="line">int f0/3</span><br><span class="line">switch mode trunk</span><br></pre></td></tr></table></figure><hr><p>网络层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">跨域网络通信，需要网络层，需要IP地址</span><br><span class="line">网络层的核心目的：分割广播域、便于寻址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">路由器第一要务就是分割广播域</span><br><span class="line"></span><br><span class="line">网络层：</span><br><span class="line">ip地址有32位二进制数  ip地址每八位二进制为1组，用’.‘分割，用十进制标识。</span><br><span class="line">4组十进制表示范围就是0.0.0.0~255.255.255.255</span><br><span class="line">ip地址分类为5类：</span><br><span class="line">A类（1~126）                 ---127：被作为回环地址：我</span><br><span class="line">B类（128~191）</span><br><span class="line">C类（192~223）</span><br><span class="line">D类（224~239）组播</span><br><span class="line">E类（240~255）科研</span><br><span class="line">ip地址总数43亿个</span><br><span class="line"></span><br><span class="line">私有IP（私有IP用在局域网内）分类：</span><br><span class="line">A类：10.0.0.0~10.255.255.255</span><br><span class="line">B类：172.16.0.0~172.31.255.255</span><br><span class="line">C类：192.168.0.0~192.168.255.255</span><br><span class="line"></span><br><span class="line">子网掩码：</span><br><span class="line">作用：32位2进制数字，运算出IP地址的网络部分</span><br><span class="line">分类：</span><br><span class="line">A类：255.0.0.0</span><br><span class="line">B类：255.255.0.0</span><br><span class="line">C类：255.255.255.0</span><br><span class="line"> 子网掩码：把IP和子网掩码逻辑运算，得出网络地址。</span><br><span class="line">两个IP地址是不是同一网络，依靠以下四步骤：</span><br><span class="line">1.IP地址转换2进制</span><br><span class="line">192.168.1.254</span><br><span class="line">1100 0000.1010 1000.0000 0001.1111 1110</span><br><span class="line">2.子网掩码转换2进制</span><br><span class="line">255.255.255.0</span><br><span class="line">1111 1111.1111 1111.1111 1111.0000 0000</span><br><span class="line">3.IP地址和子网掩码逻辑运算。</span><br><span class="line">1100 0000.1010 1000.0000 0001.1111 1110</span><br><span class="line">1111 1111.1111 1111.1111 1111.0000 0000</span><br><span class="line">---------------------------------------</span><br><span class="line">1100 0000.1010 1000.0000 0001.0000 0000</span><br><span class="line">4.得出网络地址（这个IP属于哪个网络）</span><br><span class="line">192.168.1.0（网络地址，代表一大片地址）</span><br><span class="line"></span><br><span class="line">如下地址，</span><br><span class="line">192.168.1.2</span><br><span class="line">192.168.1.254</span><br><span class="line">是同一网段，可以直接通信。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">192.168.1.2这个IP。</span><br><span class="line">问题1：哪个网段的：192.168.1.0网段</span><br><span class="line">      总数是256个。192.168.1.0~192.168.1.255</span><br><span class="line">      可用的IP地址是254个。因为去掉网络地址（1.0）和广播地址（1.255）</span><br><span class="line">      工程师可以分配的地址：192.168.1.1-192.168.1.254</span><br><span class="line">      经验之谈，不要配第一个地址和最后一个。</span><br><span class="line">      </span><br><span class="line">问题2：我有260个人的公司，能否用标准的C类地址？</span><br><span class="line">不能。</span><br><span class="line">解决方案：使用B类地址。</span><br><span class="line">172.16.1.1  IP地址</span><br><span class="line">255.255.0.0   子网掩码</span><br><span class="line">172.16.0.0    网络地址</span><br><span class="line">172.16.0.0~172.16.255.255   网络范围</span><br><span class="line">B类地址主机位有16位，可以分配2的16次方个主机</span><br><span class="line"></span><br><span class="line">问题3：超过6万人的局域网，使用什么类型的地址呢？</span><br><span class="line">解决方案：使用A类地址。</span><br><span class="line">A类地址主机位有24位。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小结：私有IP地址是由路由器生成的，用于识别。</span><br></pre></td></tr></table></figure><p>包封装</p><ul><li>网络层封装<ul><li>20字节160位</li><li>32位版本号。首部长度，检验和，标识标志偏移量，TTL，协议类型，可选项。</li><li>网络层封装时会携带2个ip，目的ip和源ip</li><li>如果计算发现，访问的地址是其他网段，会把这个数据包丢给网关（路由器）。</li></ul></li></ul><p>路由器</p><ul><li><p>两个不同网段之间实现通信中间必须要有路由器</p></li><li><p>路由器分割网络，连接不同的网络，需要寻址。</p></li><li><p>路由</p><ul><li>跨越从源主机到目标主机的一个互联网络来转发数据包的过程</li></ul></li><li><p>路由器工作原理</p><ul><li><p>路由器的每个接口处于不同的网段</p></li><li><p>网关一定要是同一网段的</p></li><li><p>路由器之间的连接接口要设置同一网段</p></li><li><p>路由表</p><ul><li><p>路由表记网段地址，记自身接口</p></li><li><p>路由表是路由器中维护的路由条目的集合。</p></li><li><p>路由表的形成</p><ul><li>直连网段</li></ul><p>​      自动配置IP地址，自动将这个接口的网段添加到路由表</p><ul><li><p>非直连网段</p><p>对于非直连网段，需要静态路由或动态路由，将网段添加到路由表</p></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络管理&quot;&gt;&lt;a href=&quot;#网络管理&quot; class=&quot;headerlink&quot; title=&quot;网络管理&quot;&gt;&lt;/a&gt;网络管理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;网卡&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维学习（三）</title>
    <link href="http://example.com/2023/03/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2023/03/30/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2023-03-30T07:58:36.000Z</published>
    <updated>2023-04-28T14:04:48.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查找和压缩"><a href="#查找和压缩" class="headerlink" title="查找和压缩"></a>查找和压缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">which      ----命令查找</span><br><span class="line">find       ----文件查找，针对文件名</span><br><span class="line">locate     ----文件查找，依赖数据库</span><br><span class="line">查找ls命令的位置</span><br><span class="line">which ls或whereis vim</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">按文件名</span><br><span class="line">find   /etc  -name  &#x27;文件名&#x27;</span><br><span class="line">find   /etc  -iname  &#x27;文件名&#x27;</span><br><span class="line"></span><br><span class="line">按文件大小</span><br><span class="line">find   /etc  -size   +5M           ----查找文件大小大于5M的</span><br><span class="line">find   /etc  -size   5M             ----查找文件大小等于5M的</span><br><span class="line">find   /etc  -size   -5M            ----查找文件大小小于5M的</span><br><span class="line"></span><br><span class="line">按指定查找目录深度查找</span><br><span class="line">find / -maxdepth 4 -a -name ifcfg-en*    ---查找文件在第4级的，名字叫ifcg-en..的文件</span><br><span class="line"></span><br><span class="line">按属组</span><br><span class="line">find /home/  -group  jack      ---查找属组为jack的文件</span><br><span class="line">find /home/  -user  jack----查找属主为jack的文件</span><br><span class="line"></span><br><span class="line">按文件类型</span><br><span class="line">find /tmp  -type f</span><br><span class="line">find /tmp -type d</span><br><span class="line">find /tmp -type b         ----搜索块文件</span><br><span class="line"></span><br><span class="line">按文件权限</span><br><span class="line">find  ./  -perm  644 -ls        ----带文件类型显示文件，-ls是find的动作之一，精准权限</span><br><span class="line">find默认print动作，也就是find  ./  -perm  644 -print</span><br><span class="line"></span><br><span class="line">先找到文件后复制</span><br><span class="line">find /etc/ -name ifclg*  -ok cp -rvf &#123;&#125;   /tmp  \;</span><br><span class="line">ok是引用符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语法：find 【path】【option】【expression】【action】</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="打包tar"><a href="#打包tar" class="headerlink" title="打包tar"></a>打包tar</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -cf   etc.tar   /etc ----未压缩，只是打包</span><br><span class="line">tar -cf  打包文件名  要打包的文件或目录  </span><br><span class="line">tar -czf   etc.gzip.tar.gz   /etc ----压缩成.gip文件</span><br><span class="line">tar -czf 打包文件名  要打包的文件或目录 加z压的更小</span><br><span class="line"></span><br><span class="line">wc -l 统计命令</span><br></pre></td></tr></table></figure><p>解压tar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xf  要解压的文件名          --解压 -xf 要解压文件要带f</span><br><span class="line"></span><br><span class="line">tar -xf  要解压的文件名  -C  解压后放的目录  ---指定存放解压文件的目录</span><br></pre></td></tr></table></figure><hr><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><ol><li>RPM包管理</li></ol><blockquote><p>RPM包是由Red HAt公司提出，被众多Linux发行版使用</p><p>也称二进制，无需编译，可以直接使用</p><p>无法设定个人设置，开关功能</p><p>软件包后缀为.rpm</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPM包是二进制，无需编译，直接使用，但是无法设定个人设置，开关功能</span><br><span class="line">源码需要GCC，C++编译环境编译才能运行，可以设定个人设置</span><br></pre></td></tr></table></figure><ul><li>yum工具</li></ul><blockquote><p>是一个在Fedora和RedHat以及CentOS中的SHell前端软件包管理器<br>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装<br>可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐一次次安装。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1. yum本地源：系统安装光盘，目的是通知linux服务器，通过本机的系统光盘获取软件包，并安装软件。所以第一步需要换源，</span><br><span class="line">yum核心配置目录：/etc/yum.repos.d</span><br><span class="line">repo中文是报告</span><br><span class="line">这里目录下的文件都是.repo后缀</span><br><span class="line">    编写本地yum库配置文件</span><br><span class="line">    [文件名]</span><br><span class="line">    name</span><br><span class="line">    baseurl</span><br><span class="line">    gpgcheck</span><br><span class="line">   【dvd】某一个库的名称，中括号【】是必须的</span><br><span class="line">    name=dvd是库的说明，name是必须的</span><br><span class="line">    baseurl=file:///mnt/cdrom下载库的具体地址</span><br><span class="line">    gpgcheck=0是关闭校验</span><br><span class="line"></span><br><span class="line">cdrom是光盘、光驱的意思，里面有自带的压缩rpm包，可以选择一个路径挂载到/dev/cdrom，然后在dvd.repo的baseurl选择挂载点作为下载地址</span><br><span class="line">当然，仅仅用mount挂载是不行的，要对其进行永久挂载。</span><br><span class="line">可以通过/root/.bashrc文件进行永久挂载。因为/root/.bashrc文件是开机启动项。可以将挂载命令直接写在这个文件里，开机自动挂载。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">2. 使用yum管理RPM包</span><br><span class="line">yum install -y 软件名  ----安装软件命令，参数y是yes的意思，可以自动回复是否安装。</span><br><span class="line">yum reinstall -y 软件名 ----当软件缺失文件时，可尝试重新安装。</span><br><span class="line">yum update -y 软件名   ----升级安装</span><br><span class="line">yum update -y        ----升级系统</span><br><span class="line">yum list 软件名      ----搜索已安装的软件包，第三列带@就是已安装的意思</span><br><span class="line">yum remove -y 软件名  ----卸载软件包</span><br><span class="line">systemctl start 软件名  ----启动软件</span><br><span class="line">systemctl stop firewalld  ----关闭防火墙</span><br><span class="line">systemctl  disable  firewalld  ----禁用防火墙开机自启</span><br><span class="line"></span><br><span class="line">yum makecache  ----更新yum仓库</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>rpm工具</li></ul><blockquote><p>自带的，但不太好用，是rpm包管理工具，它无法处理依赖</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 安装</span><br><span class="line"> rpm  -ivh 包名.rpm    ----安装，参数i是安装，v是可视，h是百分比</span><br><span class="line"> rpm -q  包名    ----查询是否安装成功，参数q是询问</span><br><span class="line"> rpm -evh  包名    ----卸载，参数e是卸载</span><br></pre></td></tr></table></figure><ol start="2"><li>源码包管理</li></ol><ul><li>下载tengine</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://tengine.taobao.org/download/tengine-2.3.0.tar.gz</span><br></pre></td></tr></table></figure><ul><li>配置tengine</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure  --user=www --group=www  --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure><ul><li>编译及安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编译：make</span><br><span class="line">安装：make install</span><br><span class="line">报错的话是编译环境出问题</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><hr><h3 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h3><h4 id="一次性调度执行at（了解）"><a href="#一次性调度执行at（了解）" class="headerlink" title="一次性调度执行at（了解）"></a>一次性调度执行at（了解）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法格式：at&lt;timespec&gt;</span><br><span class="line">如：at now +2min    ----在两分钟后执行以下输入的命令</span><br><span class="line">atq         ----查询未执行的命令</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环调度执行cron"><a href="#循环调度执行cron" class="headerlink" title="循环调度执行cron"></a>循环调度执行cron</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cron的概念和crontab是不可分割的</span><br><span class="line">crontab是一个命令</span><br><span class="line">用于设置周期性被执行的指令</span><br><span class="line">该命令从标准输入设备读取指令，并被其存放于crontab文件中，以供以后调度和执行</span><br><span class="line">----查看进程状态</span><br><span class="line">systemctl status crond.service   </span><br><span class="line">ps aux | grep crond          </span><br><span class="line">crond程序运行是计划任务执行的根本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建计划：crontab -e </span><br><span class="line">查询计划：crontab -l</span><br><span class="line">管理员可以使用-u username，去管理其他用户的计划任务</span><br><span class="line">删除计划：crontab -r</span><br><span class="line"></span><br><span class="line">语法格式：</span><br><span class="line">* * * * * command</span><br><span class="line">五颗*代表分时日月周</span><br><span class="line">例如：</span><br><span class="line">*/5 * * * * /usr/bin/ls /tmp</span><br><span class="line">每隔5分钟查一次tmp目录，以邮件的方式将结果返回</span><br><span class="line">0 2 1，4，6 * *  /usr/bin/ls </span><br><span class="line">0 * * * *表示每月每周每日每小时的0点执行</span><br><span class="line">0 2 14 * *表示每月14号的2点整执行</span><br><span class="line">月周都写的话，两者都运行。</span><br></pre></td></tr></table></figure><hr><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><h4 id="日志进程rsyslog"><a href="#日志进程rsyslog" class="headerlink" title="日志进程rsyslog"></a>日志进程rsyslog</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/var/log/messages ----系统主日志文件</span><br><span class="line">tail -f /var/log/messages  ----动态查看日志文件的尾部</span><br><span class="line">常见的日志文件：均在/var/log/目录下</span><br><span class="line">secure  ---安全</span><br><span class="line">yum.log  ---yum</span><br><span class="line">maillog   ---跟邮件postfix相关</span><br><span class="line">cron          ---跟crond 、at进程产生的日志</span><br><span class="line">dmesg    ---和系统启动相关</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rsyslogd：系统专职日志程序，处理绝大部分日志记录</span><br><span class="line">rsyslogd配置</span><br><span class="line">yum install rsyslog  logrotate  ---有问题可以重装</span><br><span class="line">systemtcl start rsyslog.service  ---启动程序</span><br><span class="line"></span><br><span class="line"> rpm -qc rsyslog ---查询相关程序：/etc/rsyslog.conf  ---主配置文件</span><br><span class="line">   /etc/sysconfig/rsyslog</span><br><span class="line">   /etc/logrotate.d/syslog</span><br><span class="line"> 主配置文件一般有共同特征：在/etc/目录下，程序名+.conf后缀。</span><br><span class="line"> /etc/rsyslog.conf告诉rsyslogd进程什么日志，应该存到哪里。</span><br><span class="line"> 日志记录问题级别：emerg、error、info、debug，配置文件里的.*代表的任何级别，所有问题都记录下来的意思</span><br></pre></td></tr></table></figure><p>日志轮转logrotate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主文件：/etc/logrotae.conf</span><br><span class="line">子文件夹：/etc/logrotate.d/*</span><br><span class="line">（带.d的是子配置文件）</span><br><span class="line">工作原理：按配置进行轮转</span><br><span class="line"></span><br><span class="line">主配置文件是程序启动必须运行的文件</span><br></pre></td></tr></table></figure><blockquote><p>总结：日志一般是由rsyslog这个程序产生的</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;查找和压缩&quot;&gt;&lt;a href=&quot;#查找和压缩&quot; class=&quot;headerlink&quot; title=&quot;查找和压缩&quot;&gt;&lt;/a&gt;查找和压缩&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运维学习--二</title>
    <link href="http://example.com/2023/03/22/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0--%E4%BA%8C/"/>
    <id>http://example.com/2023/03/22/%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0--%E4%BA%8C/</id>
    <published>2023-03-22T09:37:36.000Z</published>
    <updated>2023-09-24T17:01:57.559Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>进程是已启动的可执行程序的运行实例，进程有以下组成部分：</p><ul><li><p>一个文件</p></li><li><p>被配内存的地址空间</p></li><li><p>有权限限制</p></li><li><p>程序代码的一个或多个副本（也叫执行线程）</p></li><li><p>像人一样拥有状态</p></li><li><p>查看资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps aux    静态查看进程ps</span><br><span class="line">里面的状态STAT有sleeping（S）、running（R）、zombie（非正常结束进程Z）、stopped（T），状态后有+代表优先级较高</span><br><span class="line">PID是进程ID</span><br><span class="line">%CPU cpu占用率</span><br><span class="line">%MEM:内存占用率</span><br><span class="line">VSZ：占用虚拟内存</span><br><span class="line">RSS：占用实际内存</span><br><span class="line">TTY：进程运行的终端</span><br><span class="line">TIME：进程占用CPU的总时间</span><br><span class="line">COMMAND：进程文件，进程名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef      查看进程的父子关系，观察PID和PPID</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top        动态查看进程top</span><br></pre></td></tr></table></figure></li><li><p>信号控制进程</p><p>9）SIGKILL  强制退出，无条件</p><p>15）正常退出。</p></li><li><p>进程优先级nice</p><p>在top中显示的优先级有两个，PR值和nice值</p><p>nice的范围在-20~+19，有40个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看系统的优先级</span><br><span class="line">ps axo pid，command，nice --sort=-nice</span><br><span class="line">赋予优先级</span><br><span class="line">nice -n 优先值</span><br><span class="line">修改nice值</span><br><span class="line">renice nice值 pid</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep --倒计时程序，让系统睡眠一段时间，没什么意义</span><br></pre></td></tr></table></figure></li><li><p>作业控制jobs（了解）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;命令（重点）。是把放在后台运行，不占用终端。当然，通过ps仍然看得见</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jobs命令。查看后台运行程序。</span><br><span class="line">fg 进程序号    将进程放回前台终端</span><br><span class="line">bg 进程序号    将进程重新运行起来</span><br></pre></td></tr></table></figure><p>kill命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill 1  与  kill  %1区别</span><br><span class="line">kill 1 是杀死前台进程程序</span><br><span class="line">kill %1是杀死后台进程程序</span><br></pre></td></tr></table></figure></li><li><p>虚拟文件系统（了解）</p><p>&#x2F;proc&#x2F;，虚拟文件系统：采集服务器自身内核、进程运行的状态信息</p><p>cpu：&#x2F;proc&#x2F;cpuinfo里面放在cpu的硬件各种信息</p><p>内存：&#x2F;proc&#x2F;meminfo 里面放着内存的各种信息</p><p>内核：&#x2F;proc&#x2F;cmdline 里面放着内核信息</p></li></ul><hr><h4 id="管道和重定向"><a href="#管道和重定向" class="headerlink" title="管道和重定向"></a>管道和重定向</h4><ol><li><p>输出重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   正确输出：</span><br><span class="line">   &gt;:将左边的东西定向到右边，会覆盖原来的内容。1&gt;等价于&gt;</span><br><span class="line">   &gt;&gt;:追加内容。1&gt;&gt;等价于&gt;&gt;</span><br><span class="line">   错误输出：</span><br><span class="line">   2&gt; </span><br><span class="line">   2&gt;&gt;</span><br><span class="line">   加了&gt;等于调用了FD文件</span><br><span class="line">   FD(file descriptors)文件描述符，进程使用文件描述符来管理打开的文件，每个文件都有fd，为了省去冗长的绝对路径</span><br><span class="line">   0 标准输入</span><br><span class="line">1 标准输出</span><br><span class="line">   2 标准错误输出</span><br><span class="line">   3+普通文件</span><br><span class="line">   要想将错误正确信息均将其输入到文件内可用：</span><br><span class="line">   &amp;&gt;符号</span><br><span class="line">   如果不想看输出错误和正确结果可以将其丢入垃圾桶/dev/null</span><br></pre></td></tr></table></figure></li><li><p>输入重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt;  文件</span><br><span class="line">以文本内容，作为进程的标准输入，通常在编程中使用。</span><br><span class="line">主要用于将文件的内容一次性输入到一些命令，如发邮件案例，可以创建一个邮件格式模板，然后一次性发放到其他人手中。</span><br></pre></td></tr></table></figure></li><li><p>管道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">管道命令可以将多条命令组合起来，一次性完成复杂的处理任务</span><br><span class="line">命令1的输出，作为命令2的输入，命令2的输出作为命令3的输入</span><br><span class="line">|</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>tee管道</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tee命令</span><br><span class="line">三通，把输出保留副本·如：</span><br><span class="line">cat /etc/passwd | tee 1.txt</span><br></pre></td></tr></table></figure><ul><li><p>参数传递xargs</p><p>把输入和输出进行格式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp、rm是不服从管道命令的。</span><br><span class="line">在一个1.txt文件中写入/home/file1</span><br><span class="line">                   /home/file2</span><br><span class="line">                   /home/file3</span><br><span class="line"> 如果直接输入命令：cat 1.txt | rm -rvf，当然删不了/home/下的文件，因为两者性质不同，一个是文件，一个是文本内容。</span><br><span class="line"> 可以用以下命令：</span><br><span class="line"> cat 1.txt | xargs rm -rvf，就可以删除/home/下的文件，当然1.txt中的文本内容还在。</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><h4 id="1-基本分区"><a href="#1-基本分区" class="headerlink" title="1.基本分区"></a>1.基本分区</h4><p><code>磁盘、硬盘、disk是同一个东西。</code></p><ul><li><p>命名：SATA(串口)：&#x2F;dev&#x2F;sda，&#x2F;dev&#x2F;sdb</p><ul><li><p>&#x2F;dev&#x2F;sda:&#x2F;dev设备文件目录</p><pre><code>            sda是一个文件</code></pre><p>​s代表sata就是串口</p><p>​d代表磁盘</p><p>​a第一块</p></li><li><p>&#x2F;dev&#x2F;sdb:第二块硬盘名字</p></li></ul></li><li><p>硬盘的分区方式</p><ul><li><p>MBR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MBR有64字节大小,64字节又划分4个部分，所以有四个主分区</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ul><p>默认分为4个主分区</p><pre><code> 为了多几个分区，MBR有了扩展分区的概念。 扩展分区:扩展分区一般是放弃最后一个主分区作为扩展分区。当然扩展分区是不放数据的，想放东西、文件必须要放在逻辑分区。 当然，扩展分区也不用挂载  逻辑分区：逻辑分区是扩展分区划分出来的，想划分多少都可以  只能管理&lt;2T的硬盘</code></pre></li></ul><p>​<br>​       一块硬盘<br>​       使用MBR，划分分区。数量上只能由如下选择：<br>​       1、4主<br>​       2、3主+1扩展（N个逻辑）<br>​       ~~~</p><p>​<br>​<br>​     + GPT</p><h4 id="2-管理硬盘三部曲"><a href="#2-管理硬盘三部曲" class="headerlink" title="2.管理硬盘三部曲"></a>2.管理硬盘三部曲</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分区（MBR或GPT）--&gt;格式化/文件系统Filesystem--&gt;挂载mount</span><br></pre></td></tr></table></figure>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll   /dev/sd*  查看系统有几块硬盘</span><br></pre></td></tr></table></figure><p>   <img src="image-20230325220749609.png" alt="image-20230325220749609"></p><p>   图中brw中b开头的是block的缩写，其中&#x2F;dev&#x2F;sda、&#x2F;dev&#x2F;sda1、&#x2F;dev&#x2F;sda2是一块硬盘</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk命令能看块设备，可以查看硬盘</span><br></pre></td></tr></table></figure><ol><li>创建分区</li></ol><ul><li><p>启动分区工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk  硬盘路径（/dev/sdb或/dev/sdc)</span><br></pre></td></tr></table></figure><ul><li>操作</li></ul></li></ul><p>   <img src="%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0--%E4%BA%8C%5Cimage-20230325222559152.png" alt="image-20230325222559152"></p><ul><li>刷新分区表</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partprobe /dev/sdb</span><br></pre></td></tr></table></figure><ul><li>查看磁盘信息</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sdb或者lsblk命令查看</span><br></pre></td></tr></table></figure><ol start="2"><li>创建文件系统(格式化)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4  /dev/sdb1</span><br></pre></td></tr></table></figure><ol start="3"><li>创建挂载点，一个分区一个挂载点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/disk1</span><br><span class="line">mount -t ext4   /dev/sdb1   /mnt/disk1</span><br><span class="line">当然，mount这种挂载方式是临时的。</span><br></pre></td></tr></table></figure><ol start="4"><li><p>查看挂载信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -hT或者mount命令</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-逻辑卷"><a href="#3-逻辑卷" class="headerlink" title="3. 逻辑卷"></a>3. 逻辑卷</h4><p><code>物理磁盘的空间是固定的，单靠物理磁盘，是解决不了空间增长的问题的</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">逻辑卷LVM的目的：管理磁盘的一种方式，性质与基本磁盘无异。</span><br><span class="line"></span><br><span class="line">特点：随意扩张大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">逻辑卷管理方式：</span><br><span class="line">1.买物理盘</span><br><span class="line">2.变成物理卷</span><br><span class="line">3.加入卷组</span><br><span class="line">4.在卷组中，抽调空间，制作逻辑卷</span><br><span class="line">5.格式化</span><br><span class="line">6.挂载</span><br><span class="line"></span><br><span class="line">基本磁盘管理：</span><br><span class="line">1.买物理盘，分区</span><br><span class="line">2.格式化</span><br><span class="line">3.挂载</span><br><span class="line">-------------</span><br><span class="line">逻辑卷管理方式比基本磁盘管理方式就多了三步。</span><br></pre></td></tr></table></figure><hr><p>术语：</p><p>PV：物理卷（physical volume）</p><p>VG：卷组(volume Group)</p><p>LV：逻辑卷(Logical Volume)</p><hr><h5 id="创建LVM"><a href="#创建LVM" class="headerlink" title="创建LVM"></a>创建LVM</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. pv:pvcreate /dev/磁盘名字   ---创建物理卷</span><br><span class="line">2. vg：vgcreate  卷组名字  /dev/磁盘名字   ---创建卷组</span><br><span class="line">3. lv：lvcreate -L 大小  -n 卷名  组名     ---创建逻辑卷</span><br><span class="line">4. mkfs.ext4  /dev/vg1/lv1  ---格式化</span><br><span class="line">注意：/dev/卷组名/逻辑卷名</span><br><span class="line">5. mount /dev/vg1/lv1  /mnt/lv1</span><br></pre></td></tr></table></figure><hr><h5 id="VG扩容"><a href="#VG扩容" class="headerlink" title="VG扩容"></a>VG扩容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. pvcreate /dev/磁盘名字   ---创建PV</span><br><span class="line">2. vgextend 卷组名字 /dev/磁盘名字  ---扩展卷组</span><br><span class="line">额外命令：</span><br><span class="line">pvs  ---查看物理卷</span><br><span class="line">vgs  ---查看卷组信息</span><br></pre></td></tr></table></figure><hr><h5 id="LV扩容"><a href="#LV扩容" class="headerlink" title="LV扩容"></a>LV扩容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. vgs        ---查看VG空间，观察VG是否有剩余空间</span><br><span class="line">2. lvextend -Ｌ　扩容大小　/dev/卷组名/逻辑卷名    ---逻辑卷扩容</span><br><span class="line">3. resize2fs /dev/卷组名/逻辑卷名     ---重置文件系统</span><br></pre></td></tr></table></figure><hr><h4 id="4-交换分区管理Swap"><a href="#4-交换分区管理Swap" class="headerlink" title="4.交换分区管理Swap"></a>4.交换分区管理Swap</h4><ul><li>作用：‘提升’内存的容量，防止OOM（Out Of Memory）</li><li>硬盘上的一个分区</li><li>设置交换分区大小一般为内存的2倍</li></ul><p>如何设置交换分区swap？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">准备将/dev/sdc硬盘，划分为1G分区为例</span><br><span class="line">划分分区后，将类型设置为82(也可以不改)</span><br><span class="line"></span><br><span class="line">格式化：mkswap  /dev/sdc1</span><br><span class="line"></span><br><span class="line">交换分区的挂载:swapon /dev/sdc1</span><br><span class="line">取消挂载：swapoff  /dev/sdc2</span><br><span class="line"></span><br><span class="line">验证/查看结果：free -m</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">卸载挂载：umount /dev/sdb5(卸载挂载只是把挂载目录取消了，重新挂载之后，文件依然还在。相当于把u盘拔了)</span><br></pre></td></tr></table></figure><hr><p>小总结：</p><p>1.LVM磁盘管理是为了更方便的扩容磁盘大小，毕竟物理磁盘大小是固定的。</p><p>LVM磁盘管理可以帮助我们把多个物理磁盘变为一个整体，变相的扩容。</p><p>2.基本磁盘管理无非是三步：先要有物理磁盘，然后分区，格式化，挂载。</p><p>3.sda这个硬盘并不能格式化，这个硬盘是系统启动盘，如果格式化，那可能系统就崩溃了。</p><p>4.先要卷组里有空间才可以对逻辑卷进行扩容。</p><p>5.嗯，，当把一个硬盘变为物理卷之后，这个盘就变相“不存在”了，df -hT查看的时候，只能看到&#x2F;dev&#x2F;卷组&#x2F;逻辑卷这个盘名(文件)。</p><hr><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>window：FAT16、FAT32、NTFS</p><p>Liunx：EXT3、EXT4、XFS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">索引文件系统</span><br><span class="line">系统限制：EXT3-&gt;文件系统最大16TB</span><br><span class="line">EXT4-&gt;文件系统最大16TB</span><br><span class="line">XFS：文件系统最大100TB</span><br><span class="line"></span><br><span class="line">inode：记录文件的属性（文件的元数据metadata）</span><br><span class="line">   一个文件占用一个inode，同时记录此文件数据所在的block number</span><br><span class="line">   inode大小为128bytes</span><br><span class="line"></span><br><span class="line">block：存储文件的实际数据</span><br><span class="line">  实际存储文件的内容，若文件较大，会占用多个block。</span><br><span class="line">  block大小默认为4k</span><br><span class="line"></span><br><span class="line">superblock：block与inode的总量</span><br><span class="line">   未使用与已使用的inode/block数量</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>inode决定了文件系统中文件的数量</p><p>block决定了存储空间。</p></blockquote><hr><h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><ul><li>创建软链接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令：ln -s 文件绝对路径  文件被链接的路径</span><br><span class="line">软连接记录的只是源文件的绝对路径</span><br><span class="line">软连接失去源文件不可用</span><br><span class="line">软连接源文件没了，会对链接文件产生影响</span><br></pre></td></tr></table></figure><h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><ul><li>创建硬链接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令：ln 文件绝对路径  文件被链接的路径</span><br><span class="line">硬链接只能针对文件做，不能对目录做</span><br><span class="line">硬链接只能在同分区做</span><br><span class="line">硬链接相当于做了一个备份，删除原文件对被链接的文件没有影响</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="RAID（了解）"><a href="#RAID（了解）" class="headerlink" title="RAID（了解）"></a>RAID（了解）</h5><p>RAID是廉价磁盘冗余陈列，作用是容错、提升对写速率</p><p>类型</p><ul><li>RAID0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAID0条带集2块磁盘以上，读写速率快100%*N，但不容错。</span><br></pre></td></tr></table></figure><ul><li>RAID1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAID1俗称镜像集 2块硬盘，核心是容错</span><br></pre></td></tr></table></figure><ul><li>RAID5</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要相同容量的硬盘，核心是可靠、高速</span><br><span class="line">RAID5带奇偶校验条集  3块磁盘以上</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h4&gt;&lt;p&gt;进程是已启动的可执行程序的运行实例，进程有以下组成部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个文件&lt;/p&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
</feed>
